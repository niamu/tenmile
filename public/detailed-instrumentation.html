<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>detailed instrumentation</title>
    <script src="lib/pako.min.js" defer></script>
    <script src="lib/emitter.js"></script>
    <script src="lib/gameboy.js"></script>
  </head>
  <body>
    This tool can be used to estimate the range of unique addresses from various hardware memories needed to play through certain gameplay sequences. Open the browser console for messages. Use 'd' key to dump statistics on how many unique addresses were used. Use 'r' to reset the hitmaps. View source for more clues or to change the test ROM.
    <hr>
    <canvas id="screen" width="160" height="144"></canvas>
  </body>
  <script>
    const keyToButton = {
      ArrowRight: "right",
      ArrowLeft: "left",
      ArrowUp: "up",
      ArrowDown: "down",
      x: "a",
      z: "b",
      Shift: "select",
      Enter: "start"
    };

    const buttonToKeycode = {
      right: 0,
      left: 1,
      up: 2,
      down: 3,
      a: 4,
      b: 5,
      select: 6,
      start: 7
    };

    const elements = ["ROM", "memory", "MBCRam", "VRAM", "GBCMemory"];

    (async function() {
      let buffer = await (await fetch(
        //"https://bonsaiden.github.io/Tuff.gb/roms/game.gb"
        "https://cdn.glitch.com/80f5a65b-f7e3-4b40-b639-8e2c014de0ca%2Finfinity.gb?v=1628111377657"
      )).arrayBuffer();

      window.debug = () => {};

      let canvas = document.getElementById("screen");
      let gameboy = (window.gameboy = GameBoyCore(
        canvas,
        new Uint8Array(buffer),
        {}
      ));

      gameboy.stopEmulator = 1; // required for some reason
      gameboy.start();

      // skip startup
      for (let i = 0; i < 125 * 10; i++) {
        gameboy.run();
      }

      // initialize hitmaps
      let hitmaps = {};
      let unproxied = {};

      function resetHitmaps() {
        console.log("resetting hitmaps");
        for (let e of elements) {
          hitmaps[e] = new Set();
        }
      }

      function dumpHitmaps() {
        let report = {};
        for (let e of elements) {
          let nz = 0;
          for (let v of Object.values(unproxied[e])) {
            nz += v != 0;
          }
          report[e] = `${hitmaps[e].size} / ${unproxied[e].length} / ${nz}`;
        }
        console.log(report);
      }

      resetHitmaps();

      // install spies
      for (let e of elements) {
        unproxied[e] = gameboy[e];
        gameboy[e] = new Proxy(gameboy[e], {
          get: function(target, prop) {
            if (prop != "length" && !hitmaps[e].has(prop)) {
              hitmaps[e].add(prop);
              //console.count(e);
            }
            return target[prop];
          }
        });
      }

      // schedule continuous running
      setInterval(function() {
        gameboy.run();
      }, 8);

      // handle keys
      function handleKey(event) {
        event.preventDefault();
        let down = event.type == "keydown";
        let key = event.key;
        if (down) {
          if (key == "r") {
            resetHitmaps();
          } else if (key == "d") {
            dumpHitmaps();
          }
        }

        if (key in keyToButton) {
          gameboy.JoyPadEvent(buttonToKeycode[keyToButton[key]], down);
        }
      }
      document.addEventListener("keydown", handleKey, false);
      document.addEventListener("keyup", handleKey, false);
    })();
  </script>
</html>
