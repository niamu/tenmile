<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>quote player</title>
    
    <!-- 

    TODO: 
    - There are extra options I can pass to pigz to compress the raw data below, find them
      e.g.: Don't include anything in the gzip header, account for some files only having three chars
    - Resolve the issues with audio, we need to capture a click before starting up the audio server
    - Treeshake the code below, surely we don't need it all!

    -->

    <!-- Raw data -->
    <script>
     const romSrcRaw = "data:;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwP/buK7FVXQsA6JQQzTD/ib2PF+TDFghwSZzc9bUM7hSVrQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+Fxuq600rPZ2ab177L72Ly9vx68nlhe2/f8fDPPOjnZol2e6vT3Hn1LsGL8+o93ZTu0t/PT56yfPw96ONhyFeDSWn3vbOpKfS1pttaudX0e129pqu3b1R9s+LU9MXw/a5ci0Xy8d88FdvryLV8r4dQmlad7bET9k7MMpW35Zm6+gcflp+fwvP7oLf2JaH45h2N5O7RQui7Zf/lPfhRfnp+57huI1Q/kVw87Fevv6F8uPHcKPXp/S1NSe7dvV5jTUnq1/8rB1JZ14Ln1EGtesU4qcpIW7ZQwX3XKtpfnrQdeFHWN5yczrz+zS1rHKH3xbbef7LnVDuPNu+cZbrvevHePyzdNyqywnNi13QuqXD+vXyVvbxR35U5druGnD7dWGY9vmr8s7hvihY7jYUz+HG2L5kLxj+TftsPyt5Y/m+2tqwu21fZ2n2595+kLK305v3T6Rz+ykSdW/1LW1Z/MNGu7T3d8c7sUx/rLur14oB0+H4zZO1aNePfXfXqR50a85uHaee/pVP/na577yN/8Q09bWbZ2/dFs5fffxRfF7CWH3QRNKF7+zmpnevvWO7/u6nMatel6N7pdcf4/eg+167zCu6os5KjCMoWIzTDtxg3/qQGOx5/aSPT/7YCk65yJ0+4Idzdd/7Jf/2kyhfJzDH3MTysmn9uT6/BDDLd1WspuqxbZ0oaJZf7Y9Xc48n0Q8mpTdKplTqOYtpykHJ5ql/rdkYsvpSznE8PXSOZ7XfGaWkEDbFxd8fuo7rvP+RMCjfyAokqun97fnaM8Qoz2LS2ypTXFHfEX+BU1Iy3K1Ir907GPcJ4cGQsm6C6XK+a9UGcZ64TEUUfKRe6jguldSzfvLQEzckc/l3IZIxvLM/epqmhiNzhfAsFxFOYhYCT9ciVD0xTd14VLr+v9I5XO4VPk8ePqd9eK+eaLyNb6zujk2l45Zfyka8Fws4Vqo4cfrpKe+cQzZQhEojidkHtfJ1BTSonv+sll+Wl524vd3q4LKia0zFaM5pq738kVb5Iz31zS/tBa7LuAuFZ5QHFtyonjm1qcqZIPNHwycfXzE4fItka5GHC7/snT1Dm4ejIX8TrrNRrtQBU579ewPqfanlEJL2bREilLo0ZC7HUxTLIkuT43n0+7QypHzpM3N/JWhOT2deXNT+TXp4Qahauwg5Iyh+tW8PQLwGsquB/1+xb3/qMv6fUGCITY1pxj0SvHgDN1O6/QYG+aHUHO80rshdUXMPpZ1jvoF5Cbvk2GDodpQ+UHVtb7W9eOJ5ulc5GxjSfOfY9rvFTnv1eqNYulUvGaKtfO2qMC3xy/Zr+MfdlQowwCVlyzdKf5gpKB5KhTwVLU2fFjMhfras/1bCuRXK/lPxQBeGyJ4KgZw8MvH/jcXbW+rKybXnkPutKRIt9s6fpCWSH/uZzaGOstc63zXng4HdK8t5uSedf90+C2ipW1sQ7yXTXMX0mLPGLqStvmbln6oZz7ln2LX8q5bEfAt9vTxT03hleuWoXx/j/1O9Pqeo43xvPfhwmi3ww5xe9pstN3ZPHjzZnPw27qZp9CYO8ajv9F+fIvv6eIVdX9J8aYUe0nO4SQUMb719lQ5Sinch93xTbqdRYxr72WZtc3mZr0z3TtCL3+PGNXM9/4//b77+NRzdbnyus6d3+/VnKHoY58bUZeI5VLHWN40FH1911dn7kbRrRtQc+AldAgYY9I+xjL8uB5FMIZ/0TexNrd+W37+db3a+8+pWIWm4tfUq94TKq7Vzir1tY3aWax5lZWzMzWv9nLNK+cIU+gsE7oT1OMBO89OtWebX3I5/uY+wb+yBvZBVax6u3coVVzqwP8ZlbclB8uOYbRfrIbNO8Xxnd4uT/ZHvd5AW20OmA462RRHY2mX6NJ2i8tSCb3307rtP+jig64Y2zTN+50PuzjaKJeK5jmO88tjpJbOkeWeWxy2F4o060S6r/D5iVnZan8mhFrZky+Ye/Y/7yScw/5b3rWnnhPtFmF2u5Id1r27UOyI28UHnO4u8uKuEuv+DOse7SncAamPw/mWUvg8FCGcWyzwx/r2fcft6o4YCIiJ0O7218ma/1vV0loOMLz9UCwX8q2P3YLaJoa4mjhMOw9xjRXpkAccDdM+HsY979e1Hxm0nRso73u6/vA1uah2H9qa06hwGlMInTXjy8ZvX3r2k8r2IRp3UGQ/P65lTQys9SFAX/QA3MiXbqGZri27lw9HL8mlnDyqO4+u7kI4pl/PGzCF2TnGcI0VPen/my2O1VuoXtOpR1dfm7A+WAN9ayXxJxsYvzO08a2Rj/MVwnV5J3RE6YLzdgvP1SLtay/1fxphxhi5S5Wwer8fKS8y27ZsJSqGEE1tCJXndsJ03GDabjVytU/U0jaykthwmGsWbZzro2zIvB/AK322z1S4ch7ZxVapZnv7UmNkfPP12lVx2D4rVlnrpLweS3yxyXS/CfV8bSxOiLW4dGzL904oP6atjga1rVpP0u4NnWy+rSq2yfolY2Wkedhq12lO7vJc3MD38Fi7N4tVbU/xrntiURlb+q2jTXdHed/vixCuvc9IlDuSpjA1WBsyyPyOcbPJMUzCVX/2SlfTdwxTfv+wm3q3g1QbvdRfbebcmC5jDFlEtXjShppdLk50sf6T746+3+7nk1vW8wDiJsQ0hlsYPpqrVF0YpZ9z3i5+Rm6e352s659gQ/tAQOJU0KKbHghstGlv8rA8fUEuwKzHOUy3j60yHgzpbs9MnrH5ZP9LW0k/aXaS5kpTfHj2rVfN0dxixfNjzETapz7/r4Zo2tfkdd84+9czAZ5LLfHVfPe1//AzZke73BTWb811+8tS482+ttUZ0h7dylHrW2wYDpl526QQbrqtO0KPL2ld2CgJbgxUb44fDM3OiNK0xM2WZ6ZwYNvYd6Jtt+f/yftr5fXueCzseyf1vBaoOt9r/YVhxc0ZmNKTXcv3wiD5QlhG7OYLoo9TBndxsvFcc2xX8wZ066JIaiuzbocycF/rUv6HGrHbE3MyrLfWo5LzzFlt2fDb70U+vmGY7bg3h1t+kCMZy++9t9o1sUdTnig5xsenoegFG+ffn7rwsbf1AQu9N5aIa3chyvGyycRr5bvfmUen8dHCS2yleTD/HA+GMsTtsRjPEKJkxWRbU2xO6GKoMM3FjXcvVzRFn8HpJVGM/Jpy4vEiqJKjiCmXZvJtmq/iHKDvwnxh3XjYEPXbqlbVe3b6pdGDenP6TwYI/rlWp6NuGLWXFCM1YnvZxqf8V2IJb+my8WS3iWsz3F+8Ql/VEHp2wsaT/+LJcRXNq4IxL53a+g9NpHV96qx7HWvpv5aHLi4l+aVleQ5D25cc+RaXYBo2h86/tCi4FRxo90o/aZ7i0kO3OXTbu69rlf9v7pCXBx6HMRNpXWF8cI6ly9dkHO58PwRFf5FaD5Ir4wdiQ1uxpM1SWuyrsyf9VEeMGG8IYaSlVfh4xbQ+dn2+xRrbeAsFzDyyMReo0+kF0zZ+SOhnEEMlMZQS/vltq1aePi9RjEG5fjqaOS7lFtzlEOU7+z7D/VzMMhD3lDNbL2WvFGrx+ciOMUnp4lJ5Y+i19s80VcPOcmq5jpRrI2PoANGH66z82vY+bizO030rhojcj+zSy7joljJOu93h12HjPMZ9fdN8a/zhV6/gsJlqxrGLsep+H693zxvLzobNbiYZxwb9M0FLF/raxPXCihXFbvGKj10jcj/XpcWhi6OY7jvSzityrHeKwd9p3HvF8ntuU5ygYdqdM2YIk6+Ur/hTHfMv3ZDvuOmOlhKbnmuvv16df8Mr/jsrlr2zh/8vnWHstbMXXGuzf+lnv3Vu/Nc+/XM9GdaNZcNWM2L6zeWZzdDDic4KuaKdWxhy0+zcvjHs9+wIr7HfW3OmnFpnWQM23WK18N7DMpevp9jnMuVaXDfsRSnuc1cfd06vFZtPXG33tXPD6JbyAJwPKdRvvXmvo0I5K8C7xpD88tmcPfDAAw88+I8+aAAA+A/ySD/0MNA0L28T2uJyV8F7G0rcsbx16elc7Lg3zN/bSB7bE5uXN/YMsYmwaGDO7cnNlfbkD1xKPY64ml62eYtzjo5xUM1ykeX2oPuetDOsNk9gskzMdo90LGc4riEdG4CL2VJiA1/c7mLvhtTF67hsVE5NExqVu7h+cxevtvDFzd7sBlsrxE8vGSedJ2hLYXhPve3rmWd/uiE7Br62opNNXNQ0rtqcRzP0Yab4vBTzfcmvdq9/9tL+n5Z7smiFvXfYbnd6cN93dHt9vO9fc9v5JcVvfW1T7h9s7Ktf07915HvRKbbvrw3pvjiDmsbbrRa6H2lLfWGz4M+Onc7TAee5udelhLT99AfOE3q5bbGNTWD3cvrv7AN25WIoWsRSmADpwkLW3Tc3NO/Pk3e849ctX5FOz6UUpn0OM+r0rTo8AAAfMTwl2q2NXcW6orPS5qQieehKKpbZmXdmzEzNXHS5KuYBDusyDOOlxQuejWY8VUn8kGWodqfU6drtdT3XtbHlGExxhdr8YFnodiqnfu5fF7A5mALxBzvJfsZtXVkNt4sH43d2PY/Vqdgb81LvzM+lP7/KTjyxtUsita+ZH+Ydl2v4W+1rAj5drdWi2uIWZl8NeUxYQCcOFG7DdAnFult/MC0q7r3xynqNb1o/9mj74fXPUu3qGGqbt9pN8MHnM47fLGZ16uvjPV+81tz7p+lsg8s6S/OtiNvGXPVK9vrE6llPT+xVrkV/bzLND+4jxENPgdjcWqxZVUybeWXF4pcWvIsb/0ROFOZiyFP5h142qd8uQsdKVR4JnyqrfIYpDfp1Z5u4bEx7fjGY2ux2wx8o9HY7zUrxpAxhMHazuTbMfLpcndvMQ8HgPq5piD2d8jCxaQwP7uPc70vedOFBmHg3OPfrKQzyxAzLTA1dXBLunxkf49iksNrEi8d8908PjT2u1k4hscjfkh/Eims+8LfxUpt6PDgx6nALfzcuXRE+rp+Kzi7TXveXOH/CyYncX7xm23fOjbVuVh3XCzpszgCddrKujewuvyWnGf3aE3Miteezuf4bwjfVQ5LXIC9mWDq6gF4ZOKtWB+LdETO+uD12vzIru9TtJq8Fc2pp+N/SsvwnwnDh7k/VlL9tYukzxHdCeaOJacNHdf2IeVAT64xddSbgkIvcpk+KV9UW0UmpkuJ33xFtedE07XmNxb3I1sH2d3Op+aAWiPl7qdJBV8IyfjPVZ+nup0+MYW6EMHJP6vygXMBjtyvX2G9Pov/J7bf3KRnzg1ssNizFicUcUxi3o133Frx2OD8S4MqT/fPNmOVpfPtS19/eoptOxyLG86ndJ5XdQs41dttl+/s4nRDryYWMHJlbIixLCpZH8uTBP03OIabwYCl+DWHhlHbJGLvtAerhZz+3rmD73Qtr/kQfhGHcj0A1YRLnPOTmftLn0F9kCOXtnU4qeeHhPj643eKDImR3X6O2e2dobHhJ2+cPj1xMexlLCLnmQXO3nefHOGq1dl7jhZMzhrlYVXyO4x7Xa4qEU5z67Wzin9Vhp0vxtfoakQeZ1Gec6b54UATP+tOUwe+9DPoVQ8DihNPLIkOLsbiUe5XdH8Q5vdZhtnVUcnuhrd8yOfArhxntl+XGeL5j9H59gMPVs2L93D9B3mKCNwn3S1cZ/S1Rx71CZrMeJtxcHpP0SX8yHc/qufnKoRbaiqH3pq11RwvRy1vsIhT6XN0ercRd6wY01xvfipa02POlmS71fOraK7fbtVf/yXs1XAdtWDC3+52DuusXRTroUVjMPnHw+v6D+7P2tcUyjpLmrpbefFZGWiQUoRfAHFLaOaTfYVWPIoD7CYOa80ou7XYcdSPSOqxdKtdFJbt/tE39HSXp2uI9tbV1+1U9YF7PyHRfSmc9zH05VHkimFs4RMM6e10Sh6XBbKn0zKEuHatl9zjYEMbazLcQ/S0jZSmv7ro8WGYBWlaBuRfpp6noXFAvZaSnyuGvmrmhDDTny3oMZYliRxfrNWOMOOVbpRgUtTzIgcvhFprncrygCJeEyb+WfKAPPWDG0EVq7kKalQNrc+xD9s9pHYvRWyne/kWoPs8Vdd9TH9FV9K3qh3r07VLPpr46pmh6XU3pF5TNtla6j7Pc3+/lPNgrr9yT+92FAWNLetS329GX7Qb+S32hh+ci5rFjWOwXWMa61gGetJUhtFtZwLTOAv5ZAPAbp75ptvswx1hsjpHOBz29+/3rp+i7FvpF71wLw3dcCu+cfedTb+h7HH3JEW5rcy6e9gJz5Wmf44OyeSUXNZZfUrb/jNt9bw+y8zPdgs5cmC9qXv6s019dlzD9hTm2Q6yuS29o9v6k2nO3s77HXiDg9wQvryXG3fkOeOMH9UaNwcIYi5ziOILQHy+O9w33cDhIc3UoYjed7sP+qr97KTL6O9sWuguDQdP7e4q+aBWwo9GfMRkqtvvq88P0QUPSjoYJ/4VyYfGgi4t1xan6irEzw4lSxBMF97eUErIxCBlqNjEIeWKZseGN1dPLhYV+u/PMPZzXbh7ssM72fp/Q/vwY5os11XF6PEo3tzuzTBZ9u5ZQ+5z2bog2rkLctyEAutSKb11cFDiEdYd1OSSfgy/mzUG/273U0/sC3Q/Vdl67Fuj15rN75DFkSPfaZU6uwnJ/y+rK+dYvOvntdnMqg2JFHfneU7EPMfY2D9odyjr5dv/CYsDb/MIuUd+WNL05V46JUl+0OZR72np9+WiM7cU+fk8Ngf7D81etu3CGwOrBiP5DT3UXPZ2OPpnGljloUdAYzsdmaoWSlKcpWR4Msbnltu6q3r5ghrb2sfy5iL4X4/aPQ5DTubL5O5+unvnuSi+HdD6AAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgL/DbUUa1nbp5HZb326/HLv/O+TX9atf0y5PvPEfp3aKD+Y2PGiX33Vmz/1B//UV8xh2jPEVbZN/RBOOQPv2I7D878WxXZvaW3jQDsuF0XZhzzyHHf3XK1L6eqbrw6c1Oy+YhtXzw1vP/oPbH09qN8/1ciE2VzbXH9Wl2mYafub/hhQknL1+K7HbPm4nDu0cjm3z9WC5u5vlwdfxW33y7erXhbRje/Obb4eHv6dIYruYjIbrNzuu7cL7l+PxqPHzovH7YxYZrsYiU7hwjK5eGU++7/xnlmevnqFcuxLiGfkLxaqUS0Db20sJoVsnqQ9uPXnqw6XcpauXSbNK9kKiuLU1VpLlzedywSmF7ZwLTKEY1R9sD9XtsasVRcKXDeNO/tD+ziv6ZYn+8jn3tLSpHqAyL5i+/c/+ugLfCYbx8c0xXSgT3n70b7aVraaaW2//9WrBeqx82Vi90GJq0V4uh/a1tCqlbv2yJV/t57X3nDi8YPtrPiQxions2O9V68f+t93YY/RqmXYKjsFhbSzr3gMZW8GheF6a7QjGZaatmltz/jZI67JFe/1z2vAgHtclJjO0obSRH8RawlhJCPoVj/77Dy4+VJ7rK6XYB2qTXbi1b9vbm7lT99y/7D4o4/vWdHe3gjxN60pjChGPEP4LRYe9MnRR0D8q+LfV51PIxkOWP+0UTPu/VyhMzXGZ5b9T6o0nfLoQ67x9QnLbT5ubzfom3f576XIAoaipLbftFKrp6yShfe64xXM2xB8xhwr5sn+KD2LFfTpfD/j+GFJ+cLU8uESZcrRpCB7EOtdlk66Sb5YloicrcZdLcetS1fq3rj/zKJq5/IN+2ovp1o/T7fTVfRTb/uulwQvNHm1ISs6kxOe3GmXB6r0VylhNCJu0m/WynCMN2w08Mfxw3zGEc97tlcrqbeftEOq13Xi+naI5951/qUC4ly7upJPfd/lVW3yv93to1t0OcrxoiP0VwhMpRpoOttv123M0fJ2SvTMslY6T4lAy7KpBz/64EWpel73iPZyfvncVWo5uF+KZ//TPWf/yIVQkw9V6G6vbZ1K4cFBiXfgwIdrbLirR+zuaR+7F6TTXih6vaWK+vSR/fLSAuJllb/JMsSy+90KBZ8VyV7TD9d9w+yXlkFc1/JcF9FjxecevP+o4UlSuigaKK52cpl8TiArNAbGOnmLoYf3yua/1SPuo4lK3+T+XE9XFhLY/0WcjZkOxc2gXAiBtvLa6aokntdc7mF3NkI4DuNMvjYDXU63diNjv6au0d9X9odj3+v6Zt3uxhdpi7mkYWlfT8oJco+1D+2nZM/wbewZ1x61dU61eFa6KqXLk6h3IdoLn62hZbA3qql0c2nrTUtm76yBN+jUdtUKBZr5etblQJHo26T8dUPjznfKbV8eC04O86LcOj/b5f03lrVbdWVejrlTH0lj3as/zjYFGB1WAUA096An/qkpOTi1jsvljFbqjuORRC867qnTPjjV4pgr4+PiYV0Wu04t+Ty149w1jANLpppvuz2UytX+buuo4stBBJpQu5+MDd9ARJweGl1sjJGvhQtnZvFqy+EtDDI96yu58z26idFSjPfW7w3nqYx2rrW8/MOCx2qW7qOvOrQrs763AXuihX63cxibqGKsLDYD9uttU/0AtuF7f/anBtJ9Vc+3a8285bKLb2y7ym3KE6tnWvZPbaq+/k3fUXUM/tT4+eNX5ODo/V2s+Zd/Ex2MC7ymD3bZDg99Ybz1ulozjbcYHu2JPL2HjnP5AffXaEX2y88tn1ldrYypT/2fbZk4UApcZY5YLdAhlxFqR73bcd6kYTFJtq4ydhMLNvbf9TBXuLw4sylMh3XuhT1up28vqqf3mUL12c76C+qk+tXkiNXp8AoaP7D/6TLzgtzDV+rzsRTWW6vXUbG/fmlAxP95x9JHxJzwZd0jbzSubB6XWYtyl7T7iQ4ptHztzhjWbQ9a/50K+FJGMlcCpmAmuCI1N53q1nxzhmFJ7teSRnm04ebwX5CdV4zba7ZouPGjbtfWK74kmwhyTy7f8tDZO4/Adzba/LFWeto/2+YH3GzNCLpdyftBvTWzUbj1Xe2XtfeW1sPGgqLT9scEn67s2PTdYOY1nGifO9zl46Wxc9WJkKOT2W1dvfzzSLbTy5SGOwyqXbsMMIEWeMm5PoveCWkDzJy7n7dkox9rlFo9l6mJmMe+0G8ZptmKZL8XIdv3Sqk4T8MA0mQdTLrTTB8469PhkussY9Hney+LzjLl5dt1ppxvj9MnpdDG5WzudSWSrVYZHu5+kq1vdZuXm7ZPGfMYVG2//66X0rr02Ccve9hBHFB/P2xjbca8MX6yOZvwTA7X/+NRSteaLWim7VgOslcDPN57Upp/47hGSH1zK7/vw4HxNvRwD1y4zTOUHj14Dj3anTu0cHsy3tctwt11DMav/0aTpma7An9ZY+A2Tzbd/8B9erdg+2cqa4sidrRLZWOnXFeauSpuTwMYGorHagDTX+wz2V4ZN/fQY1bi9Oagr3WuObYhShyuguW0d3tzRMKS//XTcEDtenbT3NX27f2fZr6vXrH/vGNSd3kvL9TSuE4s4f20x5e/xjr3lH5aviD/hxIT36ZXXbnrlR39k8/8DJ+1UQ/J7ih9x9u6m1g5ajXHMO7NdldNf9aHdJq+OtbOgUuhEXJ2bvfvOdtN602g9tHC2H2+z09fuHiW92k33QuK5hDSH8Wo95OMn7kvHdeZaXerbeoh1r4ycHOUS1TX0itlG69NLPpZY7v2y2KW0Oi3msBN1a/5ydnM+YpbbpO6r9R20Utbn2HpNF954/WwsrdXUsoV1PjCEIUQPLwFRb1OaLoRlr20Of3wW61D0maq15805UuftyY/zbMmhIp0rFaG/yfrVt3l7gEBI1eqbJ5rW0x9MkU5Ms9Jux532WnDrM2S2/Yn+qW8de/6Xp9H/2Lrqa7ZO9Gvoj9dvO1EH6T6v/vuGuur3B8dz08QQf2qxY8kwptoYl1u7M9Lq3iVtDg3LXV4jOEzIfrAK38GqfN+6ztROie9ozb/PCsH9nnpq7ZfFNrNhxaO10Uf7bNa+YblgX3vh5nD79Tlmw0rfSwowfOsENfuLAXft2VdcnZrnpb/uYDDt66YneltN7h0Zaq2Vrlsv2LWUA4fNtWvqVclLm9ODnc3e2vkhV13Dcjiboxfj7KxhuFpe2m/dJDGHUxPmXGw3Z6BP8Zpp5+0Z7i9cwOnbMvCPnNcibI79Y4WNo1Lk9y2d/V8Yobq91G2au/Bg3CnGnppz4Je1yb1xoH3MmtZBrFv49KarDgg8OhfjX1+rJ2QqQ3vuvq1OrjMdrLmY8+/cva/pz42oP5pX6kLC9hd6u6bjjlbpZGyoukTZ1VamWG+MQ+ffszrBUky5Pdsr6D7XUx+mGIhzDZyoC9aot/+ksQkPqksl/JY13dKD76uFDVOlg83Yn0i5+uKSjouIdWlnBqN6m0UstaeuvlZQ+uP5zd567DvL+MVOFnGxprCO6K06dCyN587BeyYh+sMrwhWT4pVLX4ZWwhBRTOsY2XB+Ftq+Ot3Rg3P3puP+I2NYqjZ2rZyO55Y8XtEwX+5pJ7EYrix7UA6OOp9Rjv1LK5DPznmbvmEVvGXR32ltNQe/HVi5vM6PTopDSF8TM388QR/Cg64LHsRen6l41nqdvaPf12+aEeFV0xReX5jge8b9jFvnPj06RcP1BUEf/v3nr8HYgb8eAu5CdWxJ/7v2zND5WODdmeRuODWZWcyXY1Z00Hn2aITwf6HH4d8YF1f8qdu5+Fsx4cdBoO4zDtZut46x3rZTn/TgelA0zh5ePScXluqq9+E8Hpp1MBQjzvxRbbVou1j2bzf/dGjqujo/Wm3V1Vi+uzpNcuhFXl2KKM7GFeZ+etO8Tu+YISD2KmgfHh57fmT+Ucyx275T/uxI3RNjc68nPmEWqHZzfqn5atwvrJuaDmYv/OsLIxS976qzRLXddkTs3jqZbufWSryXU4awo7+2fsxTg1CPJvP9E134p+3WlHvFLh6qcW9Ixxx7G0/V6W9+6G6pd4JoY7+p4ngctQoedZeYzk9v9pZ53k60Woz1ZYq6SrSxWn3rvy2O9t2LTi5F4HfOjp2XPv7nwXGs5Hzc7fwsoem+HM12X93+/MV9NKtL7VddWWRk2hzC8s5JUnJZ/1Q8ofslzaTv/75YB9ku2XWbDTTDZtUzrVOjbnNzSZyKptiQjN/OBZFCGlp0LdleKiN/67DXRJx3xN/RnmsBvJpdPR4YOh1r+q2xp3ho41j+KU6VfOvDlDbdbd1RNlft+3VWG0dWdu+7M5+oFMSwU5idte3mX3Pa2+vR8rEWIquNG+02gyBFetK8o9z4dEvrpdlPPmT9t3d0xjtfqKy98tEpFnNH+1wDG+KDGOAr1iA7aip73Urc333Ez0+uWAbu+p1OFPOpJRXKIuC1td++ZxLDT5scsT7z/fTNU6XVarv1Bc+qafSj06/GaZfWpdbuk0Yot2EFtGVahlzSbvYmlypahZtrUzpvH/nzE/A9m7veOzo3lyaIeqKw/ZPrWxVz/YdpBZYRXucHqG/0+h7ClAX92vwb5u+qVhfVmNjRsy/+TNoZph0XEgwz+bU/24/o1QHEcIq2B1S2bV8tD7+nk8Zr5ts+XzSp9RN7z4pIYaRGiOkfzuB1FK37sELio9HDWm/Jtmvig+q8Zjt5107b8DPjVeKI7FQbgx1O0HBh9uhq7+Nh/OYi2eVlam+r09mFZVu7neau748ubRcul2jL6yOE6fQEOO1xf/NG1PBamak/WWZqjkpIuTixfGRe02favKK/7zge/4f666cwLdkUqmE5t6r2ywib56d9emmJqTkfeKsXn4ppt8ftRWhS219cujOGb8f6omh/frnv1xQOP3/yv3R5KqE01q0NNwmTwDabgYz0M4XCaxP3xE4AaXuVurj8QX5QncgpGpZq6cNki8ViruuAyp+cXDcWROfqZAzDL10uJb0yvtFd6EsZBlilzekX5vFn2iR/XdPxyfb/7cGWu0X9/DknG/vfW6auDjv4L87r/efqNP+1BUbLv1Ou5HB+OYkL3XO3p33aSRbOVHRuv6z60tZDyge9nIrKym18R7Zl8c2f7sZ+n+1pc8KudK5cHz+tRkwC3xO2/8QaTJzqtewWXJ9yKNZZ4pRK5YKcR4tuWsbxN9C9pKh/rpvw7UwGGSrJL5qwsvuP1WHSkifHFoqfrcO8eBLQPzw5wH+1EnMfzryUCnMOtGRteUq+OawmmrO8WP4Ytge9fcTFczRfQDF1x/YaLYfL3Z3ttpXiDIjbLRaPjyabThyF+rjA6cqka+2PdYq+MvIqvYTvXidvDpnMM00PIcTeNYcPlnRgnM7MAhqD7k+sX35htbYrR6+oNr3oe45mi7oQ8vjEBPRFh2WI44Ne1Gz97AC89KpIbUwYYwi4314fMjcxxKhNitG2PDq7C+2HqaiWt/ESf76ceLLks9c9dgxdPbaGYjyyJ35u0cVkvbt+1T15v7X19d0OChpH09ee6zZSljv66mxPP9Xrox4oDf+xmizWByLslt/6nQHnl8ff1OKL66w+tms/PuQ+TgP+rkH349Z8gOnc6J9Hp4X8nm61r+ksG+Ofw9Ysu1dSjnJ63+3o4sYcCPULuewF8Tcjip82vuudYzx35kVP7eeMlnl24YEHn6sNe8o920O5K817hY33r4d71P+5Hc6sP3Z5eoSj7b26/vnO07WlyD6jE/Q3f2vRVncLOXwbFizsH9uOnxe/L/YmvlAbe3YWqqLkW4wduxVL9J5e/vWgdtI3B/2C6+uefmb5uK10ROqPI3tlUbg/3zklxMkulHBf1Xb8LdNRFa2z8Z+eL+2+rnz7rpLyh5WN+2LsTtFPeK+nUs4/qxP7X5u8SrlYufiXl4vTqjg2r9cQG9a3zpKszuNmct29s33nZwrF07ntVB1R+Oj4wk8cGfiu7yzzLw9WD6r9YY8m/D9eAOA+uW233bO5uTCGMr2nEa2dthPzbjzVbP+uyzp31d3ZHtvT44S788X3c60O4b8PFxYUrfcLeLp3UXt6wrmXZpPfttbf8UpB9S6p9Y68/6wCPm/PExNX1HqmZfrRGSNe1aperhUau9B+T+G3DM2fHzb91qjKO/tMVVL2ubJS1JnFc8McfX0YhhfmzdzpR3kvdA3bpbArJ3qsFiP/RO/VZqcqdB+O2/XVZuNu85Y/6lbwGb0p63dhfXmfsOhZKHGFgvxL5wZ5vGdnPunj+WU5Q4nvaBWxz1qo46gm3/3OqE46fTmFoH5X/ftT7FwRio9NSMzbOC1WU59bY6p11tjZ7E+89U9EqMJKWv0cgyvt9pysO6tTDNVn5/9I730AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM7QpbVj97Xd/t/U3v7/YB7+bzt8PUhzCg/yU/fXTLfiNeW7vr6ybbv4neP6R+UfF370k8cgtVN8MH/9/bFfftvXgzQ24UF+6sxryj3Lf8xfeX9Q/Kw/fh0k18GPXwf5UIzhwf1cLmcl75njjpSWf9en3T3NdGLPvOz5OuPzfPhrUj4PeU8zP7RnKva0xZ6u2LP8nn55MK9/er4oltd9ehaR1iw3W1r+WJpzSpBT8uW/56Oa96TbA3vSNMTv6m7h0kipiwlJX5zTobha+iLR6m6He1JXpHRxRz/EX9PFy7srUo6hDXfhB14O+Uf+86CPWfmyJ18t+cX/ZBfLni4fsyk+yF/Rj+GptJz3to/J9z+ne97LrO57bsXJnU5cNl3xOX15TfTFnnh8uuJQDuEKuP2S5CEkFkvi0O1sv2SrCxfQPW1aEtu0FBXue25z3DMtZ6HJyU0b9yz51/2SWm7nfCUsqcT9tl7KUm1Ia5ZX5IPzf9enuvv0nOCeXufUL98DXRdT56ko+L1tT5sOM4KNPTEFn+aQZBQ7cj61XGTljjYUp3MWma+aZgzZ67BdJm2+vQxYzQT68sF+4r2RURRJY1Pkuilnv3NRi9jfU97er9pTJgrlnls+8W2RdfTxqsyHJV8MfUxT2njAPrlkMIxrU76npnBbhO3Uh8T1NoUdueidYk0g3zDljlvIFR7YkZO2WLK9hfLo3nbOmoa9HX045eunh9XeT8wTivpqWRG+JxJdW+wZj/e0ZRW72JPGl+xJUx//V7nnNh7vSUXtvdiTq/y54Boqg3E7f/re9g9nDilc27k4Nh4ElW4p7pjjjlvcUXxGE75kXpe+uvij4ifmNPWfMn25pz2/p/hpeccSTsq/tQsFw7R5XJutcuJnpAK5nNfHaO4Uj2FfVNPmWGvsy2p6sWfc+9g2lj3v2evejns+s9Qz7+X8HLnKYcnUF3uG83vun9w38eeE851LPk0oizQhm9KQAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwf+zFIQEAAAAAkP+vHaHYtm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3btm3auZME100gAKD7nEaAxsPk/tfIooV/jFKtwUP7/7zVU1oWUIhSKTEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4aUr+MvXT10G/nljG1fX8SllPp7yeKPX6Yb1+rn/ovw6mekF7oqw9pOU2hvUvUw4GVy+pg0upGU395y7qtC+bTpvA59WxaaI0M1BOt1xHHc7Ibe5+NRHN6m2u5nauuqN3aujCNtN9m1PU5KH5rd3lqLtpObcWczicFA4rRTdns6TK/bo/cZPGJYww70SY0npmCGNrxjO9Y1h1UsbjC2CT1Tm/dSbb59am99vQS3c4gzeLJO8+Z8LYpjDtpn4ntujRtI1pesdw2udZ6cJxPXV1PGHIy32yH1odu4+QtFkW6a1LP1wem7R9ayZO3rIAAAAAAAAAAACAP43bF4djZ3dP8yVr+IX2Zq4O7+4Zw+02Y37B7p6xD7s7+Z388d09Ofe7U7yU+1YPL8Kx2b42NwHPbd9nthJsd3PVVufL0zg3K/fX3ou17SVFI24HGsVa71TYRR3+7gfrWKIP7u4KmbudaRiCGG5z33QUhdLPB0NpGv5146b7G9f2OERPnnahHZ38NIaTl6Mdl+N4MB32V1c0zKcmUL6QQOXhBOo+KIG6qwmUPy6Buu8TaFg+J4HmMIG6hxOoe2cCqUAq0GdVoOXPr0CjCqQC/cYV6JYFD2SSCqQC/WgCDZd/dfaCCpQeqEBDmEDhf4uZ0qMJtEnO4wmUjibQszIt762B8wmUTiZQfzCB2kxLO2vzdAKlownU7yXQ7WeDL3iFa9N3P4GW6wn0H79/rHlcNmdOF5pxJ0+iSPbLRjn6wfFiegxdmx71/g0HHx9DEFy7vOs9yXvB7leg8fsPhgvn6HR/U1FKmBCPV5TxjQnRlzAh0uMJMbwsIY4WlmW4Wi/K1XqxnKsX7XvUbijhC1d6sF4cTo/0QL14PD2GT60XZ5+Y1wtJ/ML1yRXlVQl0tV6knXeZ1yXQA/UlfJ3/A+pL8G+OLyg8T0ggFUgFUoFUIBVIBVKBVCAVSAVSgd5TgfIfX4Ee/9ZGBfqRCjR1H1OB4n0DT3iFO12B5lfsXPvQV7j5cxJojr7X6a9+rzO/KbNK8EuQ0vyc4/AXiScyp7xwx83pzOmPrsNvAjmy4+bpG2s+eT/N5cLy7v0026FP7f9Pc/MbnuhHM3kYHDhw4ODTDvxaFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/O6kvv866Of1D0teD9JqrmdKvSYv7cVLe3E/fB2M9eJprGfWg6l8WdZLSt/2d2u9b1r/5qPL7kc3UeTctt/Ozbia+3pmKc0nh/tZXGq0S217Pd/OYB1W33Y5tV3eZnTaBF9nNN8Ptw/vW9hrF/U6DHVV5CaSOYgsnrxNJGP3/EiGMJIuGvluJNOPRJLDSKbL92TYjWSbr49HEs9fF0Wy2+YSzs467rk72eR0IQl220xhm7s3LWwz705nvXSJ2mwXxhwm660+7Lb5r2vX1srYLqrmsZi6zTNtuF/9/6os4/1qqvVjiNbj0NaI0o4m7r0Le18u9r6di98v9v5i7963AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4P/HX3/8AyIbGIYMy4QA=";
     const maskSrcRaw = "data:;base64,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VVVVVVXV+CmsqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqJ4AA7MGxAAAAAMAgf+tds6iuqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqmgDswbEAAAAAwCB/612zqK6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqaAOzBsQAAAADAIH/rXbOorqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpoA7MGxAAAAAMAgf+tds6iuqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqmgDswbEAAAAAwCB/612zqK6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqaAOzBsQAAAADAIH/rXbOorqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpoA7MGxAAAAAMAgf+tds6iuqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqmgDswbEAAAAAwCB/612zqK6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqaAOzBsQAAAADAIH/rXbOorqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpoA7MGxAAAAAMAgf+tds6iuqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqmgDswbEAAAAAwCB/612zqK6qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqaAOzBMQEAIAACsErQv5wBvH1km/9VVVVVVdVON6rq3OpEVVU1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq6rXTjaqqqqqqqqqqqqqqqqqqqqqqqqqq+uwBAAD//+zBsQAAAADAIH/rXbOorqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpoA7cGxAAAAAMAgf+s9w6iuqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqGkNNSRn//z8A";
     const actionsRaw = "data:;base64,H4sIAAAAAAACA+3cR7JdMQgE0AX9nFaDcxp54rR+x6lDO53Hr9dVPVTdi0C0EELMPDw9JIq5PX3/9sPLh8nAV09fvwtGJiiKoiiKopjLMAzBQh025Jmr39LKXAXyBqoHGpFqypHrdL/gfsaLJu29RHpPJovHXH+T63QVTcx1KEw+wZ1zmjsj3dwFCl2dy7CxC0itKBryFA42Ib4PegQ0AVhAGRXECGwv9gyWj8qJRPmpXzeBXMBWYK8A4mMx84UBTB/LEvxQaB5Yp6dOD5+ZWrDtgVUNzjHJsQLYOjB9Honm0adfF54UA9PkjhZbFXwbxHGajjxxee4Cs5Fz8uhK3qTpKrso2Tu5dpB3qU/nrfyC6F5SNCpEOc/g28ApAHkBCgtyJC5Z4gU/jjKGWqP28SSw/1a754XWlHoC004cjAoG5t7tfd+7sHaHuVqYTmcm8SLnkhYtDW5dxepNob7cuw1QIQF29RasFeA5ZbH9Nqpo4xxQmIkOCCDOb+Y70DFYmft9Kx/4Tz+Xu6y3hzfJj95FK24Db9jjgeBzi39alcy1W/Bzc3+ZZG6cnoTKvSAtywMGNrYJ0j4gOQNewIECM/AaCdTmGYux21yfvVQp2GAIGPibfRHaq2Lj54JGWfv9KOe4/b0r2OHRA3ZKA4H03PhDVyv7Mm+fm6PsnRTTjpdr5e36/lvmTT1zQJ+gliaDqQMBa1egY00inkf8jD18ozsvkd/HrQZtElIoqCiKoiiKoigefgInUbb1KnUAAA==";
     const initialStateRaw = "data:;base64,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";
    </script>
    
    <!-- Emitter -->
    <script>
/** https://github.com/component/emitter/blob/master/index.js
 * Expose `Emitter`.
 */

// export {Emitter};

if (typeof module !== 'undefined') {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

window.Emitter = Emitter;

    </script>

    <!-- GameBoyCore -->
    <script type="module">
"use strict";
/* [amsmith] */
// import { Emitter } from "./emitter-1.3.0.js";
// export {GameBoyCore};

      
/*
 * JavaScript GameBoy Color Emulator
 * Copyright (C) 2010 - 2012 Grant Galitz
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * The full license is available at http://www.gnu.org/licenses/gpl.html
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 */

function GameBoyCore(canvas, ROMImage, opts) {
  if (!(this instanceof GameBoyCore)) return new GameBoyCore(canvas, ROMImage, opts);
  
  debug("GameBoyCore Called");

  opts = opts || {};
  this.opts = {};
  this.opts.bootRom = false !== opts.bootRom;
  this.opts.gbBootRom = !!opts.gbBootRom;
  this.opts.mbc1 = !!opts.mbc1;
  this.opts.prioritizeGb = !!opts.prioritizeGb;
  this.opts.interval = opts.interval || 8;
  this.opts.imageSmoothing = false !== opts.imageSmoothing;
  this.opts.sound = opts.sound;
  this.opts.volume = opts.volume || 1;
  this.opts.audioBufferMin = opts.audioBufferMin || 10;
  this.opts.audioBufferMax = opts.audioBufferMax || 20;
  this.opts.colorizeGb = false !== opts.colorizeGb;
  this.opts.typedArrays = false !== opts.typedArrays;
  this.opts.overrideMbc = !!opts.overrideMbc;
  this.opts.canvas = opts.canvas;
  this.opts.channels = opts.channels || [true, true, true, true];
  this.opts.drawEvents = !!opts.drawEvents;

  //Params, etc...
  this.canvas = canvas;           //Canvas DOM object for drawing out the graphics to.
  this.drawContext = null;          // LCD Context
  this.ROMImage = ROMImage;         //The game's ROM.
  this.ROMImageIsString = 'string' == typeof ROMImage;
  //CPU Registers and Flags:
  this.registerA = 0x01;            //Register A (Accumulator)
  this.FZero = true;              //Register F  - Result was zero
  this.FSubtract = false;           //Register F  - Subtraction was executed
  this.FHalfCarry = true;           //Register F  - Half carry or half borrow
  this.FCarry = true;             //Register F  - Carry or borrow
  this.registerB = 0x00;            //Register B
  this.registerC = 0x13;            //Register C
  this.registerD = 0x00;            //Register D
  this.registerE = 0xD8;            //Register E
  this.registersHL = 0x014D;          //Registers H and L combined
  this.stackPointer = 0xFFFE;         //Stack Pointer
  this.programCounter = 0x0100;       //Program Counter
  //Some CPU Emulation State Variables:
  this.CPUCyclesTotal = 0;          //Relative CPU clocking to speed set, rounded appropriately.
  this.CPUCyclesTotalBase = 0;        //Relative CPU clocking to speed set base.
  this.CPUCyclesTotalCurrent = 0;       //Relative CPU clocking to speed set, the directly used value.
  this.CPUCyclesTotalRoundoff = 0;      //Clocking per iteration rounding catch.
  this.baseCPUCyclesPerIteration  = 0;    //CPU clocks per iteration at 1x speed.
  this.remainingClocks = 0;         //HALT clocking overrun carry over.
  this.inBootstrap = true;          //Whether we're in the GBC boot ROM.
  this.usedBootROM = false;         //Updated upon ROM loading...
  this.usedGBCBootROM = false;        //Did we boot to the GBC boot ROM?
  this.halt = false;              //Has the CPU been suspended until the next interrupt?
  this.skipPCIncrement = false;       //Did we trip the DMG Halt bug?
  this.stopEmulator = 3;            //Has the emulation been paused or a frame has ended?
  this.IME = true;              //Are interrupts enabled?
  this.IRQLineMatched = 0;          //CPU IRQ assertion.
  this.interruptsRequested = 0;       //IF Register
  this.interruptsEnabled = 0;         //IE Register
  this.hdmaRunning = false;         //HDMA Transfer Flag - GBC only
  this.CPUTicks = 0;              //The number of clock cycles emulated.
  this.doubleSpeedShifter = 0;        //GBC double speed clocking shifter.
  this.JoyPad = 0xFF;             //Joypad State (two four-bit states actually)
  this.CPUStopped = false;          //CPU STOP status.
  //Main RAM, MBC RAM, GBC Main RAM, VRAM, etc.
  this.memoryReader = [];           //Array of functions mapped to read back memory
  this.memoryWriter = [];           //Array of functions mapped to write to memory
  this.memoryHighReader = [];         //Array of functions mapped to read back 0xFFXX memory
  this.memoryHighWriter = [];         //Array of functions mapped to write to 0xFFXX memory
  this.ROM = [];                //The full ROM file dumped to an array.
  this.memory = [];             //Main Core Memory
  this.MBCRam = [];             //Switchable RAM (Used by games for more RAM) for the main memory range 0xA000 - 0xC000.
  this.VRAM = [];               //Extra VRAM bank for GBC.
  this.GBCMemory = [];            //GBC main RAM Banks
  this.MBC1Mode = false;            //MBC1 Type (4/32, 16/8)
  this.MBCRAMBanksEnabled = false;      //MBC RAM Access Control.
  this.currMBCRAMBank = 0;          //MBC Currently Indexed RAM Bank
  this.currMBCRAMBankPosition = -0xA000;    //MBC Position Adder;
  this.cGBC = false;              //GameBoy Color detection.
  this.gbcRamBank = 1;            //Currently Switched GameBoy Color ram bank
  this.gbcRamBankPosition = -0xD000;      //GBC RAM offset from address start.
  this.gbcRamBankPositionECHO = -0xF000;    //GBC RAM (ECHO mirroring) offset from address start.
  this.RAMBanks = [0, 1, 2, 4, 16];     //Used to map the RAM banks to maximum size the MBC used can do.
  this.ROMBank1offs = 0;            //Offset of the ROM bank switching.
  this.currentROMBank = 0;          //The parsed current ROM bank selection.
  this.cartridgeType = 0;           //Cartridge Type
  this.name = "";               //Name of the game
  this.gameCode = "";             //Game code (Suffix for older games)
  this.fromSaveState = false;         //A boolean to see if this was loaded in as a save state.
  this.savedStateFileName = "";       //When loaded in as a save state, this will not be empty.
  this.STATTracker = 0;           //Tracker for STAT triggering.
  this.modeSTAT = 0;              //The scan line mode (for lines 1-144 it's 2-3-0, for 145-154 it's 1)
  this.spriteCount = 252;           //Mode 3 extra clocking counter (Depends on how many sprites are on the current line.).
  this.LYCMatchTriggerSTAT = false;     //Should we trigger an interrupt if LY==LYC?
  this.mode2TriggerSTAT = false;        //Should we trigger an interrupt if in mode 2?
  this.mode1TriggerSTAT = false;        //Should we trigger an interrupt if in mode 1?
  this.mode0TriggerSTAT = false;        //Should we trigger an interrupt if in mode 0?
  this.LCDisOn = false;           //Is the emulated LCD controller on?
  this.LINECONTROL = [];            //Array of functions to handle each scan line we do (onscreen + offscreen)
  this.DISPLAYOFFCONTROL = [function (parentObj) {
    //Array of line 0 function to handle the LCD controller when it's off (Do nothing!).
  }];
  this.LCDCONTROL = null;           //Pointer to either LINECONTROL or DISPLAYOFFCONTROL.
  this.initializeLCDController();       //Compile the LCD controller functions.
  //RTC (Real Time Clock for MBC3):
  this.RTCisLatched = false;
  this.latchedSeconds = 0;          //RTC latched seconds.
  this.latchedMinutes = 0;          //RTC latched minutes.
  this.latchedHours = 0;            //RTC latched hours.
  this.latchedLDays = 0;            //RTC latched lower 8-bits of the day counter.
  this.latchedHDays = 0;            //RTC latched high-bit of the day counter.
  this.RTCSeconds = 0;            //RTC seconds counter.
  this.RTCMinutes = 0;            //RTC minutes counter.
  this.RTCHours = 0;              //RTC hours counter.
  this.RTCDays = 0;             //RTC days counter.
  this.RTCDayOverFlow = false;        //Did the RTC overflow and wrap the day counter?
  this.RTCHALT = false;           //Is the RTC allowed to clock up?
  //Gyro:
  this.highX = 127;
  this.lowX = 127;
  this.highY = 127;
  this.lowY = 127;
  //Sound variables:
  this.audioHandle = null;            //XAudioJS handle
  this.numSamplesTotal = 0;           //Length of the sound buffers.
  this.dutyLookup = [               //Map the duty values given to ones we can work with.
    [false, false, false, false, false, false, false, true],
    [true, false, false, false, false, false, false, true],
    [true, false, false, false, false, true, true, true],
    [false, true, true, true, true, true, true, false]
  ];
  this.bufferContainAmount = 0;         //Buffer maintenance metric.
  this.LSFR15Table = null;
  this.LSFR7Table = null;
  this.noiseSampleTable = null;
  this.initializeAudioStartState();
  this.soundMasterEnabled = false;      //As its name implies
  this.channel3PCM = null;          //Channel 3 adjusted sample buffer.
  //Vin Shit:
  this.VinLeftChannelMasterVolume = 8;    //Computed post-mixing volume.
  this.VinRightChannelMasterVolume = 8;   //Computed post-mixing volume.
  //Channel paths enabled:
  this.leftChannel1 = false;
  this.leftChannel2 = false;
  this.leftChannel3 = false;
  this.leftChannel4 = false;
  this.rightChannel1 = false;
  this.rightChannel2 = false;
  this.rightChannel3 = false;
  this.rightChannel4 = false;
  this.audioClocksUntilNextEvent = 1;
  this.audioClocksUntilNextEventCounter = 1;
  //Channel output level caches:
  this.channel1currentSampleLeft = 0;
  this.channel1currentSampleRight = 0;
  this.channel2currentSampleLeft = 0;
  this.channel2currentSampleRight = 0;
  this.channel3currentSampleLeft = 0;
  this.channel3currentSampleRight = 0;
  this.channel4currentSampleLeft = 0;
  this.channel4currentSampleRight = 0;
  this.channel1currentSampleLeftSecondary = 0;
  this.channel1currentSampleRightSecondary = 0;
  this.channel2currentSampleLeftSecondary = 0;
  this.channel2currentSampleRightSecondary = 0;
  this.channel3currentSampleLeftSecondary = 0;
  this.channel3currentSampleRightSecondary = 0;
  this.channel4currentSampleLeftSecondary = 0;
  this.channel4currentSampleRightSecondary = 0;
  this.channel1currentSampleLeftTrimary = 0;
  this.channel1currentSampleRightTrimary = 0;
  this.channel2currentSampleLeftTrimary = 0;
  this.channel2currentSampleRightTrimary = 0;
  this.mixerOutputCache = 0;
  //Pre-multipliers to cache some calculations:
  this.emulatorSpeed = 1;
  this.initializeTiming();
  //Audio generation counters:
  this.audioTicks = 0;        //Used to sample the audio system every x CPU instructions.
  this.audioIndex = 0;        //Used to keep alignment on audio generation.
  this.downsampleInput = 0;
  this.audioDestinationPosition = 0;  //Used to keep alignment on audio generation.
  this.rollover = 0;          //Used to keep alignment on the number of samples to output (Realign from counter alias).
  //Timing Variables
  this.emulatorTicks = 0;       //Times for how many instructions to execute before ending the loop.
  this.DIVTicks = 56;         //DIV Ticks Counter (Invisible lower 8-bit)
  this.LCDTicks = 60;         //Counter for how many instructions have been executed on a scanline so far.
  this.timerTicks = 0;        //Counter for the TIMA timer.
  this.TIMAEnabled = false;     //Is TIMA enabled?
  this.TACClocker = 1024;       //Timer Max Ticks
  this.serialTimer = 0;       //Serial IRQ Timer
  this.serialShiftTimer = 0;      //Serial Transfer Shift Timer
  this.serialShiftTimerAllocated = 0; //Serial Transfer Shift Timer Refill
  this.IRQEnableDelay = 0;      //Are the interrupts on queue to be enabled?
  var dateVar = new Date();
  this.lastIteration = dateVar.getTime();//The last time we iterated the main loop.
  dateVar = new Date();
  this.firstIteration = dateVar.getTime();
  this.iterations = 0;
  this.actualScanLine = 0;      //Actual scan line...
  this.lastUnrenderedLine = 0;    //Last rendered scan line...
  this.queuedScanLines = 0;
  this.totalLinesPassed = 0;
  this.haltPostClocks = 0;      //Post-Halt clocking.
  //ROM Cartridge Components:
  this.cMBC1 = false;         //Does the cartridge use MBC1?
  this.cMBC2 = false;         //Does the cartridge use MBC2?
  this.cMBC3 = false;         //Does the cartridge use MBC3?
  this.cMBC5 = false;         //Does the cartridge use MBC5?
  this.cMBC7 = false;         //Does the cartridge use MBC7?
  this.cSRAM = false;         //Does the cartridge use save RAM?
  this.cMMMO1 = false;        //...
  this.cRUMBLE = false;       //Does the cartridge use the RUMBLE addressing (modified MBC5)?
  this.cCamera = false;       //Is the cartridge actually a GameBoy Camera?
  this.cTAMA5 = false;        //Does the cartridge use TAMA5? (Tamagotchi Cartridge)
  this.cHuC3 = false;         //Does the cartridge use HuC3 (Hudson Soft / modified MBC3)?
  this.cHuC1 = false;         //Does the cartridge use HuC1 (Hudson Soft / modified MBC1)?
  this.cTIMER = false;        //Does the cartridge have an RTC?
  this.ROMBanks = [         // 1 Bank = 16 KBytes = 256 Kbits
    2, 4, 8, 16, 32, 64, 128, 256, 512
  ];
  this.ROMBanks[0x52] = 72;
  this.ROMBanks[0x53] = 80;
  this.ROMBanks[0x54] = 96;
  this.numRAMBanks = 0;         //How many RAM banks were actually allocated?
  ////Graphics Variables
  this.currVRAMBank = 0;          //Current VRAM bank for GBC.
  this.backgroundX = 0;         //Register SCX (X-Scroll)
  this.backgroundY = 0;         //Register SCY (Y-Scroll)
  this.gfxWindowDisplay = false;      //Is the windows enabled?
  this.gfxSpriteShow = false;       //Are sprites enabled?
  this.gfxSpriteNormalHeight = true;    //Are we doing 8x8 or 8x16 sprites?
  this.bgEnabled = true;          //Is the BG enabled?
  this.BGPriorityEnabled = true;      //Can we flag the BG for priority over sprites?
  this.gfxWindowCHRBankPosition = 0;    //The current bank of the character map the window uses.
  this.gfxBackgroundCHRBankPosition = 0;  //The current bank of the character map the BG uses.
  this.gfxBackgroundBankOffset = 0x80;  //Fast mapping of the tile numbering/
  this.windowY = 0;           //Current Y offset of the window.
  this.windowX = 0;           //Current X offset of the window.
  this.drewBlank = 0;           //To prevent the repeating of drawing a blank screen.
  this.drewFrame = false;         //Throttle how many draws we can do to once per iteration.
  this.midScanlineOffset = -1;      //mid-scanline rendering offset.
  this.pixelEnd = 0;            //track the x-coord limit for line rendering (mid-scanline usage).
  this.currentX = 0;            //The x-coord we left off at for mid-scanline rendering.
  //BG Tile Pointer Caches:
  this.BGCHRBank1 = null;
  this.BGCHRBank2 = null;
  this.BGCHRCurrentBank = null;
  //Tile Data Cache:
  this.tileCache = null;
  //Palettes:
  this.colors = [0xEFFFDE, 0xADD794, 0x529273, 0x183442];     //"Classic" GameBoy palette colors.
  this.OBJPalette = null;
  this.BGPalette = null;
  this.gbcOBJRawPalette = null;
  this.gbcBGRawPalette = null;
  this.gbOBJPalette = null;
  this.gbBGPalette = null;
  this.gbcOBJPalette = null;
  this.gbcBGPalette = null;
  this.gbBGColorizedPalette = null;
  this.gbOBJColorizedPalette = null;
  this.cachedBGPaletteConversion = null;
  this.cachedOBJPaletteConversion = null;
  this.updateGBBGPalette = this.updateGBRegularBGPalette;
  this.updateGBOBJPalette = this.updateGBRegularOBJPalette;
  this.colorizedGBPalettes = false;
  this.BGLayerRender = null;      //Reference to the BG rendering function.
  this.WindowLayerRender = null;    //Reference to the window rendering function.
  this.SpriteLayerRender = null;    //Reference to the OAM rendering function.
  this.frameBuffer = [];        //The internal frame-buffer.
  this.swizzledFrame = null;      //The secondary gfx buffer that holds the converted RGBA values.
  this.canvasBuffer = null;     //imageData handle
  this.pixelStart = 0;        //Temp variable for holding the current working framebuffer offset.
  //Variables used for scaling in JS:
  this.onscreenWidth = this.offscreenWidth = 160;
  this.onscreenHeight = this.offscreenHeight = 144;
  this.offscreenRGBCount = this.onscreenWidth * this.onscreenHeight * 4;
  this.resizePathClear = true;
  //Initialize the white noise cache tables ahead of time:
  this.intializeWhiteNoise();
}

Emitter(GameBoyCore.prototype);

GameBoyCore.prototype.GBBOOTROM = [   //GB BOOT ROM
  //Add 256 byte boot rom here if you are going to use it.
];
GameBoyCore.prototype.GBCBOOTROM = [  //GBC BOOT ROM
  //Add 2048 byte boot rom here if you are going to use it.
];
GameBoyCore.prototype.ffxxDump = [  //Dump of the post-BOOT I/O register state (From gambatte):
  0x0F, 0x00, 0x7C, 0xFF, 0x00, 0x00, 0x00, 0xF8,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
  0x80, 0xBF, 0xF3, 0xFF, 0xBF, 0xFF, 0x3F, 0x00,   0xFF, 0xBF, 0x7F, 0xFF, 0x9F, 0xFF, 0xBF, 0xFF,
  0xFF, 0x00, 0x00, 0xBF, 0x77, 0xF3, 0xF1, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,   0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
  0x91, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,   0x00, 0x00, 0x00, 0x00, 0xFF, 0x7E, 0xFF, 0xFE,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0xFF,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   0xC0, 0xFF, 0xC1, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
  0xF8, 0xFF, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,   0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
  0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,   0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
  0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,   0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
  0x45, 0xEC, 0x52, 0xFA, 0x08, 0xB7, 0x07, 0x5D,   0x01, 0xFD, 0xC0, 0xFF, 0x08, 0xFC, 0x00, 0xE5,
  0x0B, 0xF8, 0xC2, 0xCE, 0xF4, 0xF9, 0x0F, 0x7F,   0x45, 0x6D, 0x3D, 0xFE, 0x46, 0x97, 0x33, 0x5E,
  0x08, 0xEF, 0xF1, 0xFF, 0x86, 0x83, 0x24, 0x74,   0x12, 0xFC, 0x00, 0x9F, 0xB4, 0xB7, 0x06, 0xD5,
  0xD0, 0x7A, 0x00, 0x9E, 0x04, 0x5F, 0x41, 0x2F,   0x1D, 0x77, 0x36, 0x75, 0x81, 0xAA, 0x70, 0x3A,
  0x98, 0xD1, 0x71, 0x02, 0x4D, 0x01, 0xC1, 0xFF,   0x0D, 0x00, 0xD3, 0x05, 0xF9, 0x00, 0x0B, 0x00
];
GameBoyCore.prototype.OPCODE = [
  //NOP
  //#0x00:
  function (parentObj) {
    //Do Nothing...
  },
  //LD BC, nn
  //#0x01:
  function (parentObj) {
    parentObj.registerC = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.registerB = parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
  },
  //LD (BC), A
  //#0x02:
  function (parentObj) {
    parentObj.memoryWrite((parentObj.registerB << 8) | parentObj.registerC, parentObj.registerA);
  },
  //INC BC
  //#0x03:
  function (parentObj) {
    var temp_var = ((parentObj.registerB << 8) | parentObj.registerC) + 1;
    parentObj.registerB = (temp_var >> 8) & 0xFF;
    parentObj.registerC = temp_var & 0xFF;
  },
  //INC B
  //#0x04:
  function (parentObj) {
    parentObj.registerB = (parentObj.registerB + 1) & 0xFF;
    parentObj.FZero = (parentObj.registerB == 0);
    parentObj.FHalfCarry = ((parentObj.registerB & 0xF) == 0);
    parentObj.FSubtract = false;
  },
  //DEC B
  //#0x05:
  function (parentObj) {
    parentObj.registerB = (parentObj.registerB - 1) & 0xFF;
    parentObj.FZero = (parentObj.registerB == 0);
    parentObj.FHalfCarry = ((parentObj.registerB & 0xF) == 0xF);
    parentObj.FSubtract = true;
  },
  //LD B, n
  //#0x06:
  function (parentObj) {
    parentObj.registerB = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //RLCA
  //#0x07:
  function (parentObj) {
    parentObj.FCarry = (parentObj.registerA > 0x7F);
    parentObj.registerA = ((parentObj.registerA << 1) & 0xFF) | (parentObj.registerA >> 7);
    parentObj.FZero = parentObj.FSubtract = parentObj.FHalfCarry = false;
  },
  //LD (nn), SP
  //#0x08:
  function (parentObj) {
    var temp_var = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    parentObj.memoryWrite(temp_var, parentObj.stackPointer & 0xFF);
    parentObj.memoryWrite((temp_var + 1) & 0xFFFF, parentObj.stackPointer >> 8);
  },
  //ADD HL, BC
  //#0x09:
  function (parentObj) {
    var dirtySum = parentObj.registersHL + ((parentObj.registerB << 8) | parentObj.registerC);
    parentObj.FHalfCarry = ((parentObj.registersHL & 0xFFF) > (dirtySum & 0xFFF));
    parentObj.FCarry = (dirtySum > 0xFFFF);
    parentObj.registersHL = dirtySum & 0xFFFF;
    parentObj.FSubtract = false;
  },
  //LD A, (BC)
  //#0x0A:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryRead((parentObj.registerB << 8) | parentObj.registerC);
  },
  //DEC BC
  //#0x0B:
  function (parentObj) {
    var temp_var = (((parentObj.registerB << 8) | parentObj.registerC) - 1) & 0xFFFF;
    parentObj.registerB = temp_var >> 8;
    parentObj.registerC = temp_var & 0xFF;
  },
  //INC C
  //#0x0C:
  function (parentObj) {
    parentObj.registerC = (parentObj.registerC + 1) & 0xFF;
    parentObj.FZero = (parentObj.registerC == 0);
    parentObj.FHalfCarry = ((parentObj.registerC & 0xF) == 0);
    parentObj.FSubtract = false;
  },
  //DEC C
  //#0x0D:
  function (parentObj) {
    parentObj.registerC = (parentObj.registerC - 1) & 0xFF;
    parentObj.FZero = (parentObj.registerC == 0);
    parentObj.FHalfCarry = ((parentObj.registerC & 0xF) == 0xF);
    parentObj.FSubtract = true;
  },
  //LD C, n
  //#0x0E:
  function (parentObj) {
    parentObj.registerC = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //RRCA
  //#0x0F:
  function (parentObj) {
    parentObj.registerA = (parentObj.registerA >> 1) | ((parentObj.registerA & 1) << 7);
    parentObj.FCarry = (parentObj.registerA > 0x7F);
    parentObj.FZero = parentObj.FSubtract = parentObj.FHalfCarry = false;
  },
  //STOP
  //#0x10:
  function (parentObj) {
    if (parentObj.cGBC) {
      if ((parentObj.memory[0xFF4D] & 0x01) == 0x01) {    //Speed change requested.
        if (parentObj.memory[0xFF4D] > 0x7F) {        //Go back to single speed mode.
          debug("Going into single clock speed mode.", 0);
          parentObj.doubleSpeedShifter = 0;
          parentObj.memory[0xFF4D] &= 0x7F;       //Clear the double speed mode flag.
        }
        else {                        //Go to double speed mode.
          debug("Going into double clock speed mode.", 0);
          parentObj.doubleSpeedShifter = 1;
          parentObj.memory[0xFF4D] |= 0x80;       //Set the double speed mode flag.
        }
        parentObj.memory[0xFF4D] &= 0xFE;         //Reset the request bit.
      }
      else {
        parentObj.handleSTOP();
      }
    }
    else {
      parentObj.handleSTOP();
    }
  },
  //LD DE, nn
  //#0x11:
  function (parentObj) {
    parentObj.registerE = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.registerD = parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
  },
  //LD (DE), A
  //#0x12:
  function (parentObj) {
    parentObj.memoryWrite((parentObj.registerD << 8) | parentObj.registerE, parentObj.registerA);
  },
  //INC DE
  //#0x13:
  function (parentObj) {
    var temp_var = ((parentObj.registerD << 8) | parentObj.registerE) + 1;
    parentObj.registerD = (temp_var >> 8) & 0xFF;
    parentObj.registerE = temp_var & 0xFF;
  },
  //INC D
  //#0x14:
  function (parentObj) {
    parentObj.registerD = (parentObj.registerD + 1) & 0xFF;
    parentObj.FZero = (parentObj.registerD == 0);
    parentObj.FHalfCarry = ((parentObj.registerD & 0xF) == 0);
    parentObj.FSubtract = false;
  },
  //DEC D
  //#0x15:
  function (parentObj) {
    parentObj.registerD = (parentObj.registerD - 1) & 0xFF;
    parentObj.FZero = (parentObj.registerD == 0);
    parentObj.FHalfCarry = ((parentObj.registerD & 0xF) == 0xF);
    parentObj.FSubtract = true;
  },
  //LD D, n
  //#0x16:
  function (parentObj) {
    parentObj.registerD = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //RLA
  //#0x17:
  function (parentObj) {
    var carry_flag = (parentObj.FCarry) ? 1 : 0;
    parentObj.FCarry = (parentObj.registerA > 0x7F);
    parentObj.registerA = ((parentObj.registerA << 1) & 0xFF) | carry_flag;
    parentObj.FZero = parentObj.FSubtract = parentObj.FHalfCarry = false;
  },
  //JR n
  //#0x18:
  function (parentObj) {
    parentObj.programCounter = (parentObj.programCounter + ((parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24) + 1) & 0xFFFF;
  },
  //ADD HL, DE
  //#0x19:
  function (parentObj) {
    var dirtySum = parentObj.registersHL + ((parentObj.registerD << 8) | parentObj.registerE);
    parentObj.FHalfCarry = ((parentObj.registersHL & 0xFFF) > (dirtySum & 0xFFF));
    parentObj.FCarry = (dirtySum > 0xFFFF);
    parentObj.registersHL = dirtySum & 0xFFFF;
    parentObj.FSubtract = false;
  },
  //LD A, (DE)
  //#0x1A:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryRead((parentObj.registerD << 8) | parentObj.registerE);
  },
  //DEC DE
  //#0x1B:
  function (parentObj) {
    var temp_var = (((parentObj.registerD << 8) | parentObj.registerE) - 1) & 0xFFFF;
    parentObj.registerD = temp_var >> 8;
    parentObj.registerE = temp_var & 0xFF;
  },
  //INC E
  //#0x1C:
  function (parentObj) {
    parentObj.registerE = (parentObj.registerE + 1) & 0xFF;
    parentObj.FZero = (parentObj.registerE == 0);
    parentObj.FHalfCarry = ((parentObj.registerE & 0xF) == 0);
    parentObj.FSubtract = false;
  },
  //DEC E
  //#0x1D:
  function (parentObj) {
    parentObj.registerE = (parentObj.registerE - 1) & 0xFF;
    parentObj.FZero = (parentObj.registerE == 0);
    parentObj.FHalfCarry = ((parentObj.registerE & 0xF) == 0xF);
    parentObj.FSubtract = true;
  },
  //LD E, n
  //#0x1E:
  function (parentObj) {
    parentObj.registerE = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //RRA
  //#0x1F:
  function (parentObj) {
    var carry_flag = (parentObj.FCarry) ? 0x80 : 0;
    parentObj.FCarry = ((parentObj.registerA & 1) == 1);
    parentObj.registerA = (parentObj.registerA >> 1) | carry_flag;
    parentObj.FZero = parentObj.FSubtract = parentObj.FHalfCarry = false;
  },
  //JR NZ, n
  //#0x20:
  function (parentObj) {
    if (!parentObj.FZero) {
      parentObj.programCounter = (parentObj.programCounter + ((parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24) + 1) & 0xFFFF;
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    }
  },
  //LD HL, nn
  //#0x21:
  function (parentObj) {
    parentObj.registersHL = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
  },
  //LDI (HL), A
  //#0x22:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerA);
    parentObj.registersHL = (parentObj.registersHL + 1) & 0xFFFF;
  },
  //INC HL
  //#0x23:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL + 1) & 0xFFFF;
  },
  //INC H
  //#0x24:
  function (parentObj) {
    var H = ((parentObj.registersHL >> 8) + 1) & 0xFF;
    parentObj.FZero = (H == 0);
    parentObj.FHalfCarry = ((H & 0xF) == 0);
    parentObj.FSubtract = false;
    parentObj.registersHL = (H << 8) | (parentObj.registersHL & 0xFF);
  },
  //DEC H
  //#0x25:
  function (parentObj) {
    var H = ((parentObj.registersHL >> 8) - 1) & 0xFF;
    parentObj.FZero = (H == 0);
    parentObj.FHalfCarry = ((H & 0xF) == 0xF);
    parentObj.FSubtract = true;
    parentObj.registersHL = (H << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD H, n
  //#0x26:
  function (parentObj) {
    parentObj.registersHL = (parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 8) | (parentObj.registersHL & 0xFF);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //DAA
  //#0x27:
  function (parentObj) {
    if (!parentObj.FSubtract) {
      if (parentObj.FCarry || parentObj.registerA > 0x99) {
        parentObj.registerA = (parentObj.registerA + 0x60) & 0xFF;
        parentObj.FCarry = true;
      }
      if (parentObj.FHalfCarry || (parentObj.registerA & 0xF) > 0x9) {
        parentObj.registerA = (parentObj.registerA + 0x06) & 0xFF;
        parentObj.FHalfCarry = false;
      }
    }
    else if (parentObj.FCarry && parentObj.FHalfCarry) {
      parentObj.registerA = (parentObj.registerA + 0x9A) & 0xFF;
      parentObj.FHalfCarry = false;
    }
    else if (parentObj.FCarry) {
      parentObj.registerA = (parentObj.registerA + 0xA0) & 0xFF;
    }
    else if (parentObj.FHalfCarry) {
      parentObj.registerA = (parentObj.registerA + 0xFA) & 0xFF;
      parentObj.FHalfCarry = false;
    }
    parentObj.FZero = (parentObj.registerA == 0);
  },
  //JR Z, n
  //#0x28:
  function (parentObj) {
    if (parentObj.FZero) {
      parentObj.programCounter = (parentObj.programCounter + ((parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24) + 1) & 0xFFFF;
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    }
  },
  //ADD HL, HL
  //#0x29:
  function (parentObj) {
    parentObj.FHalfCarry = ((parentObj.registersHL & 0xFFF) > 0x7FF);
    parentObj.FCarry = (parentObj.registersHL > 0x7FFF);
    parentObj.registersHL = (parentObj.registersHL << 1) & 0xFFFF;
    parentObj.FSubtract = false;
  },
  //LDI A, (HL)
  //#0x2A:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.registersHL = (parentObj.registersHL + 1) & 0xFFFF;
  },
  //DEC HL
  //#0x2B:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL - 1) & 0xFFFF;
  },
  //INC L
  //#0x2C:
  function (parentObj) {
    var L = (parentObj.registersHL + 1) & 0xFF;
    parentObj.FZero = (L == 0);
    parentObj.FHalfCarry = ((L & 0xF) == 0);
    parentObj.FSubtract = false;
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | L;
  },
  //DEC L
  //#0x2D:
  function (parentObj) {
    var L = (parentObj.registersHL - 1) & 0xFF;
    parentObj.FZero = (L == 0);
    parentObj.FHalfCarry = ((L & 0xF) == 0xF);
    parentObj.FSubtract = true;
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | L;
  },
  //LD L, n
  //#0x2E:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //CPL
  //#0x2F:
  function (parentObj) {
    parentObj.registerA ^= 0xFF;
    parentObj.FSubtract = parentObj.FHalfCarry = true;
  },
  //JR NC, n
  //#0x30:
  function (parentObj) {
    if (!parentObj.FCarry) {
      parentObj.programCounter = (parentObj.programCounter + ((parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24) + 1) & 0xFFFF;
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    }
  },
  //LD SP, nn
  //#0x31:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
  },
  //LDD (HL), A
  //#0x32:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerA);
    parentObj.registersHL = (parentObj.registersHL - 1) & 0xFFFF;
  },
  //INC SP
  //#0x33:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer + 1) & 0xFFFF;
  },
  //INC (HL)
  //#0x34:
  function (parentObj) {
    var temp_var = (parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) + 1) & 0xFF;
    parentObj.FZero = (temp_var == 0);
    parentObj.FHalfCarry = ((temp_var & 0xF) == 0);
    parentObj.FSubtract = false;
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
  },
  //DEC (HL)
  //#0x35:
  function (parentObj) {
    var temp_var = (parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) - 1) & 0xFF;
    parentObj.FZero = (temp_var == 0);
    parentObj.FHalfCarry = ((temp_var & 0xF) == 0xF);
    parentObj.FSubtract = true;
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
  },
  //LD (HL), n
  //#0x36:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter));
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //SCF
  //#0x37:
  function (parentObj) {
    parentObj.FCarry = true;
    parentObj.FSubtract = parentObj.FHalfCarry = false;
  },
  //JR C, n
  //#0x38:
  function (parentObj) {
    if (parentObj.FCarry) {
      parentObj.programCounter = (parentObj.programCounter + ((parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24) + 1) & 0xFFFF;
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    }
  },
  //ADD HL, SP
  //#0x39:
  function (parentObj) {
    var dirtySum = parentObj.registersHL + parentObj.stackPointer;
    parentObj.FHalfCarry = ((parentObj.registersHL & 0xFFF) > (dirtySum & 0xFFF));
    parentObj.FCarry = (dirtySum > 0xFFFF);
    parentObj.registersHL = dirtySum & 0xFFFF;
    parentObj.FSubtract = false;
  },
  //LDD A, (HL)
  //#0x3A:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.registersHL = (parentObj.registersHL - 1) & 0xFFFF;
  },
  //DEC SP
  //#0x3B:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
  },
  //INC A
  //#0x3C:
  function (parentObj) {
    parentObj.registerA = (parentObj.registerA + 1) & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) == 0);
    parentObj.FSubtract = false;
  },
  //DEC A
  //#0x3D:
  function (parentObj) {
    parentObj.registerA = (parentObj.registerA - 1) & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) == 0xF);
    parentObj.FSubtract = true;
  },
  //LD A, n
  //#0x3E:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //CCF
  //#0x3F:
  function (parentObj) {
    parentObj.FCarry = !parentObj.FCarry;
    parentObj.FSubtract = parentObj.FHalfCarry = false;
  },
  //LD B, B
  //#0x40:
  function (parentObj) {
    //Do nothing...
  },
  //LD B, C
  //#0x41:
  function (parentObj) {
    parentObj.registerB = parentObj.registerC;
  },
  //LD B, D
  //#0x42:
  function (parentObj) {
    parentObj.registerB = parentObj.registerD;
  },
  //LD B, E
  //#0x43:
  function (parentObj) {
    parentObj.registerB = parentObj.registerE;
  },
  //LD B, H
  //#0x44:
  function (parentObj) {
    parentObj.registerB = parentObj.registersHL >> 8;
  },
  //LD B, L
  //#0x45:
  function (parentObj) {
    parentObj.registerB = parentObj.registersHL & 0xFF;
  },
  //LD B, (HL)
  //#0x46:
  function (parentObj) {
    parentObj.registerB = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
  },
  //LD B, A
  //#0x47:
  function (parentObj) {
    parentObj.registerB = parentObj.registerA;
  },
  //LD C, B
  //#0x48:
  function (parentObj) {
    parentObj.registerC = parentObj.registerB;
  },
  //LD C, C
  //#0x49:
  function (parentObj) {
    //Do nothing...
  },
  //LD C, D
  //#0x4A:
  function (parentObj) {
    parentObj.registerC = parentObj.registerD;
  },
  //LD C, E
  //#0x4B:
  function (parentObj) {
    parentObj.registerC = parentObj.registerE;
  },
  //LD C, H
  //#0x4C:
  function (parentObj) {
    parentObj.registerC = parentObj.registersHL >> 8;
  },
  //LD C, L
  //#0x4D:
  function (parentObj) {
    parentObj.registerC = parentObj.registersHL & 0xFF;
  },
  //LD C, (HL)
  //#0x4E:
  function (parentObj) {
    parentObj.registerC = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
  },
  //LD C, A
  //#0x4F:
  function (parentObj) {
    parentObj.registerC = parentObj.registerA;
  },
  //LD D, B
  //#0x50:
  function (parentObj) {
    parentObj.registerD = parentObj.registerB;
  },
  //LD D, C
  //#0x51:
  function (parentObj) {
    parentObj.registerD = parentObj.registerC;
  },
  //LD D, D
  //#0x52:
  function (parentObj) {
    //Do nothing...
  },
  //LD D, E
  //#0x53:
  function (parentObj) {
    parentObj.registerD = parentObj.registerE;
  },
  //LD D, H
  //#0x54:
  function (parentObj) {
    parentObj.registerD = parentObj.registersHL >> 8;
  },
  //LD D, L
  //#0x55:
  function (parentObj) {
    parentObj.registerD = parentObj.registersHL & 0xFF;
  },
  //LD D, (HL)
  //#0x56:
  function (parentObj) {
    parentObj.registerD = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
  },
  //LD D, A
  //#0x57:
  function (parentObj) {
    parentObj.registerD = parentObj.registerA;
  },
  //LD E, B
  //#0x58:
  function (parentObj) {
    parentObj.registerE = parentObj.registerB;
  },
  //LD E, C
  //#0x59:
  function (parentObj) {
    parentObj.registerE = parentObj.registerC;
  },
  //LD E, D
  //#0x5A:
  function (parentObj) {
    parentObj.registerE = parentObj.registerD;
  },
  //LD E, E
  //#0x5B:
  function (parentObj) {
    //Do nothing...
  },
  //LD E, H
  //#0x5C:
  function (parentObj) {
    parentObj.registerE = parentObj.registersHL >> 8;
  },
  //LD E, L
  //#0x5D:
  function (parentObj) {
    parentObj.registerE = parentObj.registersHL & 0xFF;
  },
  //LD E, (HL)
  //#0x5E:
  function (parentObj) {
    parentObj.registerE = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
  },
  //LD E, A
  //#0x5F:
  function (parentObj) {
    parentObj.registerE = parentObj.registerA;
  },
  //LD H, B
  //#0x60:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registerB << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD H, C
  //#0x61:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registerC << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD H, D
  //#0x62:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registerD << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD H, E
  //#0x63:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registerE << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD H, H
  //#0x64:
  function (parentObj) {
    //Do nothing...
  },
  //LD H, L
  //#0x65:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF) * 0x101;
  },
  //LD H, (HL)
  //#0x66:
  function (parentObj) {
    parentObj.registersHL = (parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD H, A
  //#0x67:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registerA << 8) | (parentObj.registersHL & 0xFF);
  },
  //LD L, B
  //#0x68:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.registerB;
  },
  //LD L, C
  //#0x69:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.registerC;
  },
  //LD L, D
  //#0x6A:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.registerD;
  },
  //LD L, E
  //#0x6B:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.registerE;
  },
  //LD L, H
  //#0x6C:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | (parentObj.registersHL >> 8);
  },
  //LD L, L
  //#0x6D:
  function (parentObj) {
    //Do nothing...
  },
  //LD L, (HL)
  //#0x6E:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
  },
  //LD L, A
  //#0x6F:
  function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | parentObj.registerA;
  },
  //LD (HL), B
  //#0x70:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerB);
  },
  //LD (HL), C
  //#0x71:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerC);
  },
  //LD (HL), D
  //#0x72:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerD);
  },
  //LD (HL), E
  //#0x73:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerE);
  },
  //LD (HL), H
  //#0x74:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registersHL >> 8);
  },
  //LD (HL), L
  //#0x75:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registersHL & 0xFF);
  },
  //HALT
  //#0x76:
  function (parentObj) {
    //See if there's already an IRQ match:
    if ((parentObj.interruptsEnabled & parentObj.interruptsRequested & 0x1F) > 0) {
      if (!parentObj.cGBC && !parentObj.usedBootROM) {
        //HALT bug in the DMG CPU model (Program Counter fails to increment for one instruction after HALT):
        parentObj.skipPCIncrement = true;
      }
      else {
        //CGB gets around the HALT PC bug by doubling the hidden NOP.
        parentObj.CPUTicks += 4;
      }
    }
    else {
      //CPU is stalled until the next IRQ match:
      parentObj.calculateHALTPeriod();
    }
  },
  //LD (HL), A
  //#0x77:
  function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.registerA);
  },
  //LD A, B
  //#0x78:
  function (parentObj) {
    parentObj.registerA = parentObj.registerB;
  },
  //LD A, C
  //#0x79:
  function (parentObj) {
    parentObj.registerA = parentObj.registerC;
  },
  //LD A, D
  //#0x7A:
  function (parentObj) {
    parentObj.registerA = parentObj.registerD;
  },
  //LD A, E
  //#0x7B:
  function (parentObj) {
    parentObj.registerA = parentObj.registerE;
  },
  //LD A, H
  //#0x7C:
  function (parentObj) {
    parentObj.registerA = parentObj.registersHL >> 8;
  },
  //LD A, L
  //#0x7D:
  function (parentObj) {
    parentObj.registerA = parentObj.registersHL & 0xFF;
  },
  //LD, A, (HL)
  //#0x7E:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
  },
  //LD A, A
  //#0x7F:
  function (parentObj) {
    //Do Nothing...
  },
  //ADD A, B
  //#0x80:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerB;
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, C
  //#0x81:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerC;
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, D
  //#0x82:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerD;
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, E
  //#0x83:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerE;
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, H
  //#0x84:
  function (parentObj) {
    var dirtySum = parentObj.registerA + (parentObj.registersHL >> 8);
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, L
  //#0x85:
  function (parentObj) {
    var dirtySum = parentObj.registerA + (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, (HL)
  //#0x86:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADD A, A
  //#0x87:
  function (parentObj) {
    parentObj.FHalfCarry = ((parentObj.registerA & 0x8) == 0x8);
    parentObj.FCarry = (parentObj.registerA > 0x7F);
    parentObj.registerA = (parentObj.registerA << 1) & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, B
  //#0x88:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerB + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (parentObj.registerB & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, C
  //#0x89:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerC + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (parentObj.registerC & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, D
  //#0x8A:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerD + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (parentObj.registerD & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, E
  //#0x8B:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.registerE + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (parentObj.registerE & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, H
  //#0x8C:
  function (parentObj) {
    var tempValue = (parentObj.registersHL >> 8);
    var dirtySum = parentObj.registerA + tempValue + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (tempValue & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, L
  //#0x8D:
  function (parentObj) {
    var tempValue = (parentObj.registersHL & 0xFF);
    var dirtySum = parentObj.registerA + tempValue + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (tempValue & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, (HL)
  //#0x8E:
  function (parentObj) {
    var tempValue = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    var dirtySum = parentObj.registerA + tempValue + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (tempValue & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //ADC A, A
  //#0x8F:
  function (parentObj) {
    //shift left register A one bit for some ops here as an optimization:
    var dirtySum = (parentObj.registerA << 1) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((((parentObj.registerA << 1) & 0x1E) | ((parentObj.FCarry) ? 1 : 0)) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //SUB A, B
  //#0x90:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerB;
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, C
  //#0x91:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerC;
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, D
  //#0x92:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerD;
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, E
  //#0x93:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerE;
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, H
  //#0x94:
  function (parentObj) {
    var dirtySum = parentObj.registerA - (parentObj.registersHL >> 8);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, L
  //#0x95:
  function (parentObj) {
    var dirtySum = parentObj.registerA - (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, (HL)
  //#0x96:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //SUB A, A
  //#0x97:
  function (parentObj) {
    //number - same number == 0
    parentObj.registerA = 0;
    parentObj.FHalfCarry = parentObj.FCarry = false;
    parentObj.FZero = parentObj.FSubtract = true;
  },
  //SBC A, B
  //#0x98:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerB - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (parentObj.registerB & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, C
  //#0x99:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerC - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (parentObj.registerC & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, D
  //#0x9A:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerD - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (parentObj.registerD & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, E
  //#0x9B:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerE - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (parentObj.registerE & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, H
  //#0x9C:
  function (parentObj) {
    var temp_var = parentObj.registersHL >> 8;
    var dirtySum = parentObj.registerA - temp_var - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (temp_var & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, L
  //#0x9D:
  function (parentObj) {
    var dirtySum = parentObj.registerA - (parentObj.registersHL & 0xFF) - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (parentObj.registersHL & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, (HL)
  //#0x9E:
  function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    var dirtySum = parentObj.registerA - temp_var - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (temp_var & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //SBC A, A
  //#0x9F:
  function (parentObj) {
    //Optimized SBC A:
    if (parentObj.FCarry) {
      parentObj.FZero = false;
      parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = true;
      parentObj.registerA = 0xFF;
    }
    else {
      parentObj.FHalfCarry = parentObj.FCarry = false;
      parentObj.FSubtract = parentObj.FZero = true;
      parentObj.registerA = 0;
    }
  },
  //AND B
  //#0xA0:
  function (parentObj) {
    parentObj.registerA &= parentObj.registerB;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND C
  //#0xA1:
  function (parentObj) {
    parentObj.registerA &= parentObj.registerC;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND D
  //#0xA2:
  function (parentObj) {
    parentObj.registerA &= parentObj.registerD;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND E
  //#0xA3:
  function (parentObj) {
    parentObj.registerA &= parentObj.registerE;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND H
  //#0xA4:
  function (parentObj) {
    parentObj.registerA &= (parentObj.registersHL >> 8);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND L
  //#0xA5:
  function (parentObj) {
    parentObj.registerA &= parentObj.registersHL;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND (HL)
  //#0xA6:
  function (parentObj) {
    parentObj.registerA &= parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //AND A
  //#0xA7:
  function (parentObj) {
    //number & same number = same number
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //XOR B
  //#0xA8:
  function (parentObj) {
    parentObj.registerA ^= parentObj.registerB;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR C
  //#0xA9:
  function (parentObj) {
    parentObj.registerA ^= parentObj.registerC;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR D
  //#0xAA:
  function (parentObj) {
    parentObj.registerA ^= parentObj.registerD;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR E
  //#0xAB:
  function (parentObj) {
    parentObj.registerA ^= parentObj.registerE;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR H
  //#0xAC:
  function (parentObj) {
    parentObj.registerA ^= (parentObj.registersHL >> 8);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR L
  //#0xAD:
  function (parentObj) {
    parentObj.registerA ^= (parentObj.registersHL & 0xFF);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR (HL)
  //#0xAE:
  function (parentObj) {
    parentObj.registerA ^= parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //XOR A
  //#0xAF:
  function (parentObj) {
    //number ^ same number == 0
    parentObj.registerA = 0;
    parentObj.FZero = true;
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //OR B
  //#0xB0:
  function (parentObj) {
    parentObj.registerA |= parentObj.registerB;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR C
  //#0xB1:
  function (parentObj) {
    parentObj.registerA |= parentObj.registerC;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR D
  //#0xB2:
  function (parentObj) {
    parentObj.registerA |= parentObj.registerD;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR E
  //#0xB3:
  function (parentObj) {
    parentObj.registerA |= parentObj.registerE;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR H
  //#0xB4:
  function (parentObj) {
    parentObj.registerA |= (parentObj.registersHL >> 8);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR L
  //#0xB5:
  function (parentObj) {
    parentObj.registerA |= (parentObj.registersHL & 0xFF);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR (HL)
  //#0xB6:
  function (parentObj) {
    parentObj.registerA |= parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //OR A
  //#0xB7:
  function (parentObj) {
    //number | same number == same number
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //CP B
  //#0xB8:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerB;
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP C
  //#0xB9:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerC;
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP D
  //#0xBA:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerD;
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP E
  //#0xBB:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.registerE;
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP H
  //#0xBC:
  function (parentObj) {
    var dirtySum = parentObj.registerA - (parentObj.registersHL >> 8);
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP L
  //#0xBD:
  function (parentObj) {
    var dirtySum = parentObj.registerA - (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP (HL)
  //#0xBE:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //CP A
  //#0xBF:
  function (parentObj) {
    parentObj.FHalfCarry = parentObj.FCarry = false;
    parentObj.FZero = parentObj.FSubtract = true;
  },
  //RET !FZ
  //#0xC0:
  function (parentObj) {
    if (!parentObj.FZero) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
      parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
      parentObj.CPUTicks += 12;
    }
  },
  //POP BC
  //#0xC1:
  function (parentObj) {
    parentObj.registerC = parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
    parentObj.registerB = parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF);
    parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
  },
  //JP !FZ, nn
  //#0xC2:
  function (parentObj) {
    if (!parentObj.FZero) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //JP nn
  //#0xC3:
  function (parentObj) {
    parentObj.programCounter = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
  },
  //CALL !FZ, nn
  //#0xC4:
  function (parentObj) {
    if (!parentObj.FZero) {
      var temp_pc = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
      parentObj.programCounter = temp_pc;
      parentObj.CPUTicks += 12;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //PUSH BC
  //#0xC5:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registerB);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registerC);
  },
  //ADD, n
  //#0xC6:
  function (parentObj) {
    var dirtySum = parentObj.registerA + parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.FHalfCarry = ((dirtySum & 0xF) < (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //RST 0
  //#0xC7:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0;
  },
  //RET FZ
  //#0xC8:
  function (parentObj) {
    if (parentObj.FZero) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
      parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
      parentObj.CPUTicks += 12;
    }
  },
  //RET
  //#0xC9:
  function (parentObj) {
    parentObj.programCounter =  (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
    parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
  },
  //JP FZ, nn
  //#0xCA:
  function (parentObj) {
    if (parentObj.FZero) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //Secondary OP Code Set:
  //#0xCB:
  function (parentObj) {
    var opcode = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    //Increment the program counter to the next instruction:
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    //Get how many CPU cycles the current 0xCBXX op code counts for:
    parentObj.CPUTicks += parentObj.SecondaryTICKTable[opcode];
    //Execute secondary OP codes for the 0xCB OP code call.
    parentObj.CBOPCODE[opcode](parentObj);
  },
  //CALL FZ, nn
  //#0xCC:
  function (parentObj) {
    if (parentObj.FZero) {
      var temp_pc = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
      parentObj.programCounter = temp_pc;
      parentObj.CPUTicks += 12;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //CALL nn
  //#0xCD:
  function (parentObj) {
    var temp_pc = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = temp_pc;
  },
  //ADC A, n
  //#0xCE:
  function (parentObj) {
    var tempValue = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    var dirtySum = parentObj.registerA + tempValue + ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) + (tempValue & 0xF) + ((parentObj.FCarry) ? 1 : 0) > 0xF);
    parentObj.FCarry = (dirtySum > 0xFF);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = false;
  },
  //RST 0x8
  //#0xCF:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x8;
  },
  //RET !FC
  //#0xD0:
  function (parentObj) {
    if (!parentObj.FCarry) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
      parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
      parentObj.CPUTicks += 12;
    }
  },
  //POP DE
  //#0xD1:
  function (parentObj) {
    parentObj.registerE = parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
    parentObj.registerD = parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF);
    parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
  },
  //JP !FC, nn
  //#0xD2:
  function (parentObj) {
    if (!parentObj.FCarry) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //0xD3 - Illegal
  //#0xD3:
  function (parentObj) {
    this.emit('error', new Error('Illegal op code 0xD3 called'));
  },
  //CALL !FC, nn
  //#0xD4:
  function (parentObj) {
    if (!parentObj.FCarry) {
      var temp_pc = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
      parentObj.programCounter = temp_pc;
      parentObj.CPUTicks += 12;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //PUSH DE
  //#0xD5:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registerD);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registerE);
  },
  //SUB A, n
  //#0xD6:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) < (dirtySum & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //RST 0x10
  //#0xD7:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x10;
  },
  //RET FC
  //#0xD8:
  function (parentObj) {
    if (parentObj.FCarry) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
      parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
      parentObj.CPUTicks += 12;
    }
  },
  //RETI
  //#0xD9:
  function (parentObj) {
    parentObj.programCounter = (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
    parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
    //Immediate for HALT:
    parentObj.IRQEnableDelay = (parentObj.IRQEnableDelay == 2 || parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) == 0x76) ? 1 : 2;
  },
  //JP FC, nn
  //#0xDA:
  function (parentObj) {
    if (parentObj.FCarry) {
      parentObj.programCounter = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.CPUTicks += 4;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //0xDB - Illegal
  //#0xDB:
  function (parentObj) {
    this.emit('error', new Error('Illegal op code 0xDB called'));
  },
  //CALL FC, nn
  //#0xDC:
  function (parentObj) {
    if (parentObj.FCarry) {
      var temp_pc = (parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
      parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
      parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
      parentObj.programCounter = temp_pc;
      parentObj.CPUTicks += 12;
    }
    else {
      parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
    }
  },
  //0xDD - Illegal
  //#0xDD:
  function (parentObj) {
    this.emit('error', new Error('Illegal op code 0xDD called, pausing emulation.'));
  },
  //SBC A, n
  //#0xDE:
  function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    var dirtySum = parentObj.registerA - temp_var - ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = ((parentObj.registerA & 0xF) - (temp_var & 0xF) - ((parentObj.FCarry) ? 1 : 0) < 0);
    parentObj.FCarry = (dirtySum < 0);
    parentObj.registerA = dirtySum & 0xFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = true;
  },
  //RST 0x18
  //#0xDF:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x18;
  },
  //LDH (n), A
  //#0xE0:
  function (parentObj) {
    parentObj.memoryHighWrite(parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter), parentObj.registerA);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //POP HL
  //#0xE1:
  function (parentObj) {
    parentObj.registersHL = (parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
    parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
  },
  //LD (0xFF00 + C), A
  //#0xE2:
  function (parentObj) {
    parentObj.memoryHighWriter[parentObj.registerC](parentObj, parentObj.registerC, parentObj.registerA);
  },
  //0xE3 - Illegal
  //#0xE3:
  function (parentObj) {
    this.emit('error', new Error('Illegal op code 0xE3 called'));
  },
  //0xE4 - Illegal
  //#0xE4:
  function (parentObj) {
    this.emit('error', new Error('Illegal op code 0xE4 called'));
  },
  //PUSH HL
  //#0xE5:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registersHL >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registersHL & 0xFF);
  },
  //AND n
  //#0xE6:
  function (parentObj) {
    parentObj.registerA &= parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = parentObj.FCarry = false;
  },
  //RST 0x20
  //#0xE7:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x20;
  },
  //ADD SP, n
  //#0xE8:
  function (parentObj) {
    var temp_value2 = (parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24;
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    var temp_value = (parentObj.stackPointer + temp_value2) & 0xFFFF;
    temp_value2 = parentObj.stackPointer ^ temp_value2 ^ temp_value;
    parentObj.stackPointer = temp_value;
    parentObj.FCarry = ((temp_value2 & 0x100) == 0x100);
    parentObj.FHalfCarry = ((temp_value2 & 0x10) == 0x10);
    parentObj.FZero = parentObj.FSubtract = false;
  },
  //JP, (HL)
  //#0xE9:
  function (parentObj) {
    parentObj.programCounter = parentObj.registersHL;
  },
  //LD n, A
  //#0xEA:
  function (parentObj) {
    parentObj.memoryWrite((parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter), parentObj.registerA);
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
  },
  //0xEB - Illegal
  //#0xEB:
  function (parentObj) {
    this.emit('error', new Error("Illegal op code 0xEB called"));
  },
  //0xEC - Illegal
  //#0xEC:
  function (parentObj) {
    this.emit('error', new Error("Illegal op code 0xEC called"));
  },
  //0xED - Illegal
  //#0xED:
  function (parentObj) {
    this.emit('error', new Error("Illegal op code 0xED called"));
  },
  //XOR n
  //#0xEE:
  function (parentObj) {
    parentObj.registerA ^= parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FSubtract = parentObj.FHalfCarry = parentObj.FCarry = false;
  },
  //RST 0x28
  //#0xEF:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x28;
  },
  //LDH A, (n)
  //#0xF0:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryHighRead(parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter));
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
  },
  //POP AF
  //#0xF1:
  function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.stackPointer](parentObj, parentObj.stackPointer);
    parentObj.FZero = (temp_var > 0x7F);
    parentObj.FSubtract = ((temp_var & 0x40) == 0x40);
    parentObj.FHalfCarry = ((temp_var & 0x20) == 0x20);
    parentObj.FCarry = ((temp_var & 0x10) == 0x10);
    parentObj.registerA = parentObj.memoryRead((parentObj.stackPointer + 1) & 0xFFFF);
    parentObj.stackPointer = (parentObj.stackPointer + 2) & 0xFFFF;
  },
  //LD A, (0xFF00 + C)
  //#0xF2:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryHighReader[parentObj.registerC](parentObj, parentObj.registerC);
  },
  //DI
  //#0xF3:
  function (parentObj) {
    parentObj.IME = false;
    parentObj.IRQEnableDelay = 0;
  },
  //0xF4 - Illegal
  //#0xF4:
  function (parentObj) {
    this.emit('error', new Error("Illegal op code 0xF4 called"));
  },
  //PUSH AF
  //#0xF5:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.registerA);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, ((parentObj.FZero) ? 0x80 : 0) | ((parentObj.FSubtract) ? 0x40 : 0) | ((parentObj.FHalfCarry) ? 0x20 : 0) | ((parentObj.FCarry) ? 0x10 : 0));
  },
  //OR n
  //#0xF6:
  function (parentObj) {
    parentObj.registerA |= parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.FSubtract = parentObj.FCarry = parentObj.FHalfCarry = false;
  },
  //RST 0x30
  //#0xF7:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x30;
  },
  //LDHL SP, n
  //#0xF8:
  function (parentObj) {
    var temp_var = (parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) << 24) >> 24;
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.registersHL = (parentObj.stackPointer + temp_var) & 0xFFFF;
    temp_var = parentObj.stackPointer ^ temp_var ^ parentObj.registersHL;
    parentObj.FCarry = ((temp_var & 0x100) == 0x100);
    parentObj.FHalfCarry = ((temp_var & 0x10) == 0x10);
    parentObj.FZero = parentObj.FSubtract = false;
  },
  //LD SP, HL
  //#0xF9:
  function (parentObj) {
    parentObj.stackPointer = parentObj.registersHL;
  },
  //LD A, (nn)
  //#0xFA:
  function (parentObj) {
    parentObj.registerA = parentObj.memoryRead((parentObj.memoryRead((parentObj.programCounter + 1) & 0xFFFF) << 8) | parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter));
    parentObj.programCounter = (parentObj.programCounter + 2) & 0xFFFF;
  },
  //EI
  //#0xFB:
  function (parentObj) {
    //Immediate for HALT:
    parentObj.IRQEnableDelay = (parentObj.IRQEnableDelay == 2 || parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter) == 0x76) ? 1 : 2;
  },
  //0xFC - Illegal
  //#0xFC:
  function (parentObj) {
    this.emit('error', new Error("Illegal op code 0xFC called"));
  },
  //0xFD - Illegal
  //#0xFD:
  function (parentObj) {
    this.emit('error', new Error("Illegal op code 0xFD called"));
  },
  //CP n
  //#0xFE:
  function (parentObj) {
    var dirtySum = parentObj.registerA - parentObj.memoryReader[parentObj.programCounter](parentObj, parentObj.programCounter);
    parentObj.programCounter = (parentObj.programCounter + 1) & 0xFFFF;
    parentObj.FHalfCarry = ((dirtySum & 0xF) > (parentObj.registerA & 0xF));
    parentObj.FCarry = (dirtySum < 0);
    parentObj.FZero = (dirtySum == 0);
    parentObj.FSubtract = true;
  },
  //RST 0x38
  //#0xFF:
  function (parentObj) {
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter >> 8);
    parentObj.stackPointer = (parentObj.stackPointer - 1) & 0xFFFF;
    parentObj.memoryWriter[parentObj.stackPointer](parentObj, parentObj.stackPointer, parentObj.programCounter & 0xFF);
    parentObj.programCounter = 0x38;
  }
];
GameBoyCore.prototype.CBOPCODE = [
  //RLC B
  //#0x00:
  function (parentObj) {
    parentObj.FCarry = (parentObj.registerB > 0x7F);
    parentObj.registerB = ((parentObj.registerB << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //RLC C
  //#0x01:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerC > 0x7F);
    parentObj.registerC = ((parentObj.registerC << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //RLC D
  //#0x02:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerD > 0x7F);
    parentObj.registerD = ((parentObj.registerD << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //RLC E
  //#0x03:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerE > 0x7F);
    parentObj.registerE = ((parentObj.registerE << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //RLC H
  //#0x04:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registersHL > 0x7FFF);
    parentObj.registersHL = ((parentObj.registersHL << 1) & 0xFE00) | ((parentObj.FCarry) ? 0x100 : 0) | (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //RLC L
  //#0x05:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x80) == 0x80);
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.registersHL << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //RLC (HL)
  //#0x06:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FCarry = (temp_var > 0x7F);
    temp_var = ((temp_var << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var == 0);
  }
  //RLC A
  //#0x07:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerA > 0x7F);
    parentObj.registerA = ((parentObj.registerA << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //RRC B
  //#0x08:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerB & 0x01) == 0x01);
    parentObj.registerB = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerB >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //RRC C
  //#0x09:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerC & 0x01) == 0x01);
    parentObj.registerC = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerC >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //RRC D
  //#0x0A:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerD & 0x01) == 0x01);
    parentObj.registerD = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerD >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //RRC E
  //#0x0B:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerE & 0x01) == 0x01);
    parentObj.registerE = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerE >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //RRC H
  //#0x0C:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x0100) == 0x0100);
    parentObj.registersHL = ((parentObj.FCarry) ? 0x8000 : 0) | ((parentObj.registersHL >> 1) & 0xFF00) | (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //RRC L
  //#0x0D:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x01) == 0x01);
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.FCarry) ? 0x80 : 0) | ((parentObj.registersHL & 0xFF) >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //RRC (HL)
  //#0x0E:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FCarry = ((temp_var & 0x01) == 0x01);
    temp_var = ((parentObj.FCarry) ? 0x80 : 0) | (temp_var >> 1);
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var == 0);
  }
  //RRC A
  //#0x0F:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerA & 0x01) == 0x01);
    parentObj.registerA = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerA >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //RL B
  //#0x10:
  ,function (parentObj) {
    var newFCarry = (parentObj.registerB > 0x7F);
    parentObj.registerB = ((parentObj.registerB << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //RL C
  //#0x11:
  ,function (parentObj) {
    var newFCarry = (parentObj.registerC > 0x7F);
    parentObj.registerC = ((parentObj.registerC << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //RL D
  //#0x12:
  ,function (parentObj) {
    var newFCarry = (parentObj.registerD > 0x7F);
    parentObj.registerD = ((parentObj.registerD << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //RL E
  //#0x13:
  ,function (parentObj) {
    var newFCarry = (parentObj.registerE > 0x7F);
    parentObj.registerE = ((parentObj.registerE << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //RL H
  //#0x14:
  ,function (parentObj) {
    var newFCarry = (parentObj.registersHL > 0x7FFF);
    parentObj.registersHL = ((parentObj.registersHL << 1) & 0xFE00) | ((parentObj.FCarry) ? 0x100 : 0) | (parentObj.registersHL & 0xFF);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //RL L
  //#0x15:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registersHL & 0x80) == 0x80);
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.registersHL << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //RL (HL)
  //#0x16:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    var newFCarry = (temp_var > 0x7F);
    temp_var = ((temp_var << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var == 0);
  }
  //RL A
  //#0x17:
  ,function (parentObj) {
    var newFCarry = (parentObj.registerA > 0x7F);
    parentObj.registerA = ((parentObj.registerA << 1) & 0xFF) | ((parentObj.FCarry) ? 1 : 0);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //RR B
  //#0x18:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registerB & 0x01) == 0x01);
    parentObj.registerB = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerB >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //RR C
  //#0x19:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registerC & 0x01) == 0x01);
    parentObj.registerC = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerC >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //RR D
  //#0x1A:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registerD & 0x01) == 0x01);
    parentObj.registerD = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerD >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //RR E
  //#0x1B:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registerE & 0x01) == 0x01);
    parentObj.registerE = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerE >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //RR H
  //#0x1C:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registersHL & 0x0100) == 0x0100);
    parentObj.registersHL = ((parentObj.FCarry) ? 0x8000 : 0) | ((parentObj.registersHL >> 1) & 0xFF00) | (parentObj.registersHL & 0xFF);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //RR L
  //#0x1D:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registersHL & 0x01) == 0x01);
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.FCarry) ? 0x80 : 0) | ((parentObj.registersHL & 0xFF) >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //RR (HL)
  //#0x1E:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    var newFCarry = ((temp_var & 0x01) == 0x01);
    temp_var = ((parentObj.FCarry) ? 0x80 : 0) | (temp_var >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var == 0);
  }
  //RR A
  //#0x1F:
  ,function (parentObj) {
    var newFCarry = ((parentObj.registerA & 0x01) == 0x01);
    parentObj.registerA = ((parentObj.FCarry) ? 0x80 : 0) | (parentObj.registerA >> 1);
    parentObj.FCarry = newFCarry;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //SLA B
  //#0x20:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerB > 0x7F);
    parentObj.registerB = (parentObj.registerB << 1) & 0xFF;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //SLA C
  //#0x21:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerC > 0x7F);
    parentObj.registerC = (parentObj.registerC << 1) & 0xFF;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //SLA D
  //#0x22:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerD > 0x7F);
    parentObj.registerD = (parentObj.registerD << 1) & 0xFF;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //SLA E
  //#0x23:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerE > 0x7F);
    parentObj.registerE = (parentObj.registerE << 1) & 0xFF;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //SLA H
  //#0x24:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registersHL > 0x7FFF);
    parentObj.registersHL = ((parentObj.registersHL << 1) & 0xFE00) | (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //SLA L
  //#0x25:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x0080) == 0x0080);
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.registersHL << 1) & 0xFF);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //SLA (HL)
  //#0x26:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FCarry = (temp_var > 0x7F);
    temp_var = (temp_var << 1) & 0xFF;
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var == 0);
  }
  //SLA A
  //#0x27:
  ,function (parentObj) {
    parentObj.FCarry = (parentObj.registerA > 0x7F);
    parentObj.registerA = (parentObj.registerA << 1) & 0xFF;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //SRA B
  //#0x28:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerB & 0x01) == 0x01);
    parentObj.registerB = (parentObj.registerB & 0x80) | (parentObj.registerB >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //SRA C
  //#0x29:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerC & 0x01) == 0x01);
    parentObj.registerC = (parentObj.registerC & 0x80) | (parentObj.registerC >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //SRA D
  //#0x2A:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerD & 0x01) == 0x01);
    parentObj.registerD = (parentObj.registerD & 0x80) | (parentObj.registerD >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //SRA E
  //#0x2B:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerE & 0x01) == 0x01);
    parentObj.registerE = (parentObj.registerE & 0x80) | (parentObj.registerE >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //SRA H
  //#0x2C:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x0100) == 0x0100);
    parentObj.registersHL = ((parentObj.registersHL >> 1) & 0xFF00) | (parentObj.registersHL & 0x80FF);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //SRA L
  //#0x2D:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x0001) == 0x0001);
    parentObj.registersHL = (parentObj.registersHL & 0xFF80) | ((parentObj.registersHL & 0xFF) >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //SRA (HL)
  //#0x2E:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FCarry = ((temp_var & 0x01) == 0x01);
    temp_var = (temp_var & 0x80) | (temp_var >> 1);
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var == 0);
  }
  //SRA A
  //#0x2F:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerA & 0x01) == 0x01);
    parentObj.registerA = (parentObj.registerA & 0x80) | (parentObj.registerA >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //SWAP B
  //#0x30:
  ,function (parentObj) {
    parentObj.registerB = ((parentObj.registerB & 0xF) << 4) | (parentObj.registerB >> 4);
    parentObj.FZero = (parentObj.registerB == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP C
  //#0x31:
  ,function (parentObj) {
    parentObj.registerC = ((parentObj.registerC & 0xF) << 4) | (parentObj.registerC >> 4);
    parentObj.FZero = (parentObj.registerC == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP D
  //#0x32:
  ,function (parentObj) {
    parentObj.registerD = ((parentObj.registerD & 0xF) << 4) | (parentObj.registerD >> 4);
    parentObj.FZero = (parentObj.registerD == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP E
  //#0x33:
  ,function (parentObj) {
    parentObj.registerE = ((parentObj.registerE & 0xF) << 4) | (parentObj.registerE >> 4);
    parentObj.FZero = (parentObj.registerE == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP H
  //#0x34:
  ,function (parentObj) {
    parentObj.registersHL = ((parentObj.registersHL & 0xF00) << 4) | ((parentObj.registersHL & 0xF000) >> 4) | (parentObj.registersHL & 0xFF);
    parentObj.FZero = (parentObj.registersHL < 0x100);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP L
  //#0x35:
  ,function (parentObj) {
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.registersHL & 0xF) << 4) | ((parentObj.registersHL & 0xF0) >> 4);
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP (HL)
  //#0x36:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    temp_var = ((temp_var & 0xF) << 4) | (temp_var >> 4);
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var);
    parentObj.FZero = (temp_var == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SWAP A
  //#0x37:
  ,function (parentObj) {
    parentObj.registerA = ((parentObj.registerA & 0xF) << 4) | (parentObj.registerA >> 4);
    parentObj.FZero = (parentObj.registerA == 0);
    parentObj.FCarry = parentObj.FHalfCarry = parentObj.FSubtract = false;
  }
  //SRL B
  //#0x38:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerB & 0x01) == 0x01);
    parentObj.registerB >>= 1;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerB == 0);
  }
  //SRL C
  //#0x39:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerC & 0x01) == 0x01);
    parentObj.registerC >>= 1;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerC == 0);
  }
  //SRL D
  //#0x3A:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerD & 0x01) == 0x01);
    parentObj.registerD >>= 1;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerD == 0);
  }
  //SRL E
  //#0x3B:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerE & 0x01) == 0x01);
    parentObj.registerE >>= 1;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerE == 0);
  }
  //SRL H
  //#0x3C:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x0100) == 0x0100);
    parentObj.registersHL = ((parentObj.registersHL >> 1) & 0xFF00) | (parentObj.registersHL & 0xFF);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registersHL < 0x100);
  }
  //SRL L
  //#0x3D:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registersHL & 0x0001) == 0x0001);
    parentObj.registersHL = (parentObj.registersHL & 0xFF00) | ((parentObj.registersHL & 0xFF) >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0xFF) == 0);
  }
  //SRL (HL)
  //#0x3E:
  ,function (parentObj) {
    var temp_var = parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL);
    parentObj.FCarry = ((temp_var & 0x01) == 0x01);
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, temp_var >> 1);
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (temp_var < 2);
  }
  //SRL A
  //#0x3F:
  ,function (parentObj) {
    parentObj.FCarry = ((parentObj.registerA & 0x01) == 0x01);
    parentObj.registerA >>= 1;
    parentObj.FHalfCarry = parentObj.FSubtract = false;
    parentObj.FZero = (parentObj.registerA == 0);
  }
  //BIT 0, B
  //#0x40:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x01) == 0);
  }
  //BIT 0, C
  //#0x41:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x01) == 0);
  }
  //BIT 0, D
  //#0x42:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x01) == 0);
  }
  //BIT 0, E
  //#0x43:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x01) == 0);
  }
  //BIT 0, H
  //#0x44:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0100) == 0);
  }
  //BIT 0, L
  //#0x45:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0001) == 0);
  }
  //BIT 0, (HL)
  //#0x46:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x01) == 0);
  }
  //BIT 0, A
  //#0x47:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x01) == 0);
  }
  //BIT 1, B
  //#0x48:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x02) == 0);
  }
  //BIT 1, C
  //#0x49:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x02) == 0);
  }
  //BIT 1, D
  //#0x4A:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x02) == 0);
  }
  //BIT 1, E
  //#0x4B:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x02) == 0);
  }
  //BIT 1, H
  //#0x4C:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0200) == 0);
  }
  //BIT 1, L
  //#0x4D:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0002) == 0);
  }
  //BIT 1, (HL)
  //#0x4E:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x02) == 0);
  }
  //BIT 1, A
  //#0x4F:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x02) == 0);
  }
  //BIT 2, B
  //#0x50:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x04) == 0);
  }
  //BIT 2, C
  //#0x51:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x04) == 0);
  }
  //BIT 2, D
  //#0x52:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x04) == 0);
  }
  //BIT 2, E
  //#0x53:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x04) == 0);
  }
  //BIT 2, H
  //#0x54:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0400) == 0);
  }
  //BIT 2, L
  //#0x55:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0004) == 0);
  }
  //BIT 2, (HL)
  //#0x56:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x04) == 0);
  }
  //BIT 2, A
  //#0x57:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x04) == 0);
  }
  //BIT 3, B
  //#0x58:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x08) == 0);
  }
  //BIT 3, C
  //#0x59:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x08) == 0);
  }
  //BIT 3, D
  //#0x5A:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x08) == 0);
  }
  //BIT 3, E
  //#0x5B:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x08) == 0);
  }
  //BIT 3, H
  //#0x5C:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0800) == 0);
  }
  //BIT 3, L
  //#0x5D:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0008) == 0);
  }
  //BIT 3, (HL)
  //#0x5E:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x08) == 0);
  }
  //BIT 3, A
  //#0x5F:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x08) == 0);
  }
  //BIT 4, B
  //#0x60:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x10) == 0);
  }
  //BIT 4, C
  //#0x61:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x10) == 0);
  }
  //BIT 4, D
  //#0x62:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x10) == 0);
  }
  //BIT 4, E
  //#0x63:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x10) == 0);
  }
  //BIT 4, H
  //#0x64:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x1000) == 0);
  }
  //BIT 4, L
  //#0x65:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0010) == 0);
  }
  //BIT 4, (HL)
  //#0x66:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x10) == 0);
  }
  //BIT 4, A
  //#0x67:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x10) == 0);
  }
  //BIT 5, B
  //#0x68:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x20) == 0);
  }
  //BIT 5, C
  //#0x69:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x20) == 0);
  }
  //BIT 5, D
  //#0x6A:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x20) == 0);
  }
  //BIT 5, E
  //#0x6B:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x20) == 0);
  }
  //BIT 5, H
  //#0x6C:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x2000) == 0);
  }
  //BIT 5, L
  //#0x6D:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0020) == 0);
  }
  //BIT 5, (HL)
  //#0x6E:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x20) == 0);
  }
  //BIT 5, A
  //#0x6F:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x20) == 0);
  }
  //BIT 6, B
  //#0x70:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x40) == 0);
  }
  //BIT 6, C
  //#0x71:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x40) == 0);
  }
  //BIT 6, D
  //#0x72:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x40) == 0);
  }
  //BIT 6, E
  //#0x73:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x40) == 0);
  }
  //BIT 6, H
  //#0x74:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x4000) == 0);
  }
  //BIT 6, L
  //#0x75:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0040) == 0);
  }
  //BIT 6, (HL)
  //#0x76:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x40) == 0);
  }
  //BIT 6, A
  //#0x77:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x40) == 0);
  }
  //BIT 7, B
  //#0x78:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerB & 0x80) == 0);
  }
  //BIT 7, C
  //#0x79:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerC & 0x80) == 0);
  }
  //BIT 7, D
  //#0x7A:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerD & 0x80) == 0);
  }
  //BIT 7, E
  //#0x7B:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerE & 0x80) == 0);
  }
  //BIT 7, H
  //#0x7C:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x8000) == 0);
  }
  //BIT 7, L
  //#0x7D:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registersHL & 0x0080) == 0);
  }
  //BIT 7, (HL)
  //#0x7E:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x80) == 0);
  }
  //BIT 7, A
  //#0x7F:
  ,function (parentObj) {
    parentObj.FHalfCarry = true;
    parentObj.FSubtract = false;
    parentObj.FZero = ((parentObj.registerA & 0x80) == 0);
  }
  //RES 0, B
  //#0x80:
  ,function (parentObj) {
    parentObj.registerB &= 0xFE;
  }
  //RES 0, C
  //#0x81:
  ,function (parentObj) {
    parentObj.registerC &= 0xFE;
  }
  //RES 0, D
  //#0x82:
  ,function (parentObj) {
    parentObj.registerD &= 0xFE;
  }
  //RES 0, E
  //#0x83:
  ,function (parentObj) {
    parentObj.registerE &= 0xFE;
  }
  //RES 0, H
  //#0x84:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFEFF;
  }
  //RES 0, L
  //#0x85:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFFE;
  }
  //RES 0, (HL)
  //#0x86:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xFE);
  }
  //RES 0, A
  //#0x87:
  ,function (parentObj) {
    parentObj.registerA &= 0xFE;
  }
  //RES 1, B
  //#0x88:
  ,function (parentObj) {
    parentObj.registerB &= 0xFD;
  }
  //RES 1, C
  //#0x89:
  ,function (parentObj) {
    parentObj.registerC &= 0xFD;
  }
  //RES 1, D
  //#0x8A:
  ,function (parentObj) {
    parentObj.registerD &= 0xFD;
  }
  //RES 1, E
  //#0x8B:
  ,function (parentObj) {
    parentObj.registerE &= 0xFD;
  }
  //RES 1, H
  //#0x8C:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFDFF;
  }
  //RES 1, L
  //#0x8D:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFFD;
  }
  //RES 1, (HL)
  //#0x8E:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xFD);
  }
  //RES 1, A
  //#0x8F:
  ,function (parentObj) {
    parentObj.registerA &= 0xFD;
  }
  //RES 2, B
  //#0x90:
  ,function (parentObj) {
    parentObj.registerB &= 0xFB;
  }
  //RES 2, C
  //#0x91:
  ,function (parentObj) {
    parentObj.registerC &= 0xFB;
  }
  //RES 2, D
  //#0x92:
  ,function (parentObj) {
    parentObj.registerD &= 0xFB;
  }
  //RES 2, E
  //#0x93:
  ,function (parentObj) {
    parentObj.registerE &= 0xFB;
  }
  //RES 2, H
  //#0x94:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFBFF;
  }
  //RES 2, L
  //#0x95:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFFB;
  }
  //RES 2, (HL)
  //#0x96:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xFB);
  }
  //RES 2, A
  //#0x97:
  ,function (parentObj) {
    parentObj.registerA &= 0xFB;
  }
  //RES 3, B
  //#0x98:
  ,function (parentObj) {
    parentObj.registerB &= 0xF7;
  }
  //RES 3, C
  //#0x99:
  ,function (parentObj) {
    parentObj.registerC &= 0xF7;
  }
  //RES 3, D
  //#0x9A:
  ,function (parentObj) {
    parentObj.registerD &= 0xF7;
  }
  //RES 3, E
  //#0x9B:
  ,function (parentObj) {
    parentObj.registerE &= 0xF7;
  }
  //RES 3, H
  //#0x9C:
  ,function (parentObj) {
    parentObj.registersHL &= 0xF7FF;
  }
  //RES 3, L
  //#0x9D:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFF7;
  }
  //RES 3, (HL)
  //#0x9E:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xF7);
  }
  //RES 3, A
  //#0x9F:
  ,function (parentObj) {
    parentObj.registerA &= 0xF7;
  }
  //RES 3, B
  //#0xA0:
  ,function (parentObj) {
    parentObj.registerB &= 0xEF;
  }
  //RES 4, C
  //#0xA1:
  ,function (parentObj) {
    parentObj.registerC &= 0xEF;
  }
  //RES 4, D
  //#0xA2:
  ,function (parentObj) {
    parentObj.registerD &= 0xEF;
  }
  //RES 4, E
  //#0xA3:
  ,function (parentObj) {
    parentObj.registerE &= 0xEF;
  }
  //RES 4, H
  //#0xA4:
  ,function (parentObj) {
    parentObj.registersHL &= 0xEFFF;
  }
  //RES 4, L
  //#0xA5:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFEF;
  }
  //RES 4, (HL)
  //#0xA6:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xEF);
  }
  //RES 4, A
  //#0xA7:
  ,function (parentObj) {
    parentObj.registerA &= 0xEF;
  }
  //RES 5, B
  //#0xA8:
  ,function (parentObj) {
    parentObj.registerB &= 0xDF;
  }
  //RES 5, C
  //#0xA9:
  ,function (parentObj) {
    parentObj.registerC &= 0xDF;
  }
  //RES 5, D
  //#0xAA:
  ,function (parentObj) {
    parentObj.registerD &= 0xDF;
  }
  //RES 5, E
  //#0xAB:
  ,function (parentObj) {
    parentObj.registerE &= 0xDF;
  }
  //RES 5, H
  //#0xAC:
  ,function (parentObj) {
    parentObj.registersHL &= 0xDFFF;
  }
  //RES 5, L
  //#0xAD:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFDF;
  }
  //RES 5, (HL)
  //#0xAE:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xDF);
  }
  //RES 5, A
  //#0xAF:
  ,function (parentObj) {
    parentObj.registerA &= 0xDF;
  }
  //RES 6, B
  //#0xB0:
  ,function (parentObj) {
    parentObj.registerB &= 0xBF;
  }
  //RES 6, C
  //#0xB1:
  ,function (parentObj) {
    parentObj.registerC &= 0xBF;
  }
  //RES 6, D
  //#0xB2:
  ,function (parentObj) {
    parentObj.registerD &= 0xBF;
  }
  //RES 6, E
  //#0xB3:
  ,function (parentObj) {
    parentObj.registerE &= 0xBF;
  }
  //RES 6, H
  //#0xB4:
  ,function (parentObj) {
    parentObj.registersHL &= 0xBFFF;
  }
  //RES 6, L
  //#0xB5:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFFBF;
  }
  //RES 6, (HL)
  //#0xB6:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0xBF);
  }
  //RES 6, A
  //#0xB7:
  ,function (parentObj) {
    parentObj.registerA &= 0xBF;
  }
  //RES 7, B
  //#0xB8:
  ,function (parentObj) {
    parentObj.registerB &= 0x7F;
  }
  //RES 7, C
  //#0xB9:
  ,function (parentObj) {
    parentObj.registerC &= 0x7F;
  }
  //RES 7, D
  //#0xBA:
  ,function (parentObj) {
    parentObj.registerD &= 0x7F;
  }
  //RES 7, E
  //#0xBB:
  ,function (parentObj) {
    parentObj.registerE &= 0x7F;
  }
  //RES 7, H
  //#0xBC:
  ,function (parentObj) {
    parentObj.registersHL &= 0x7FFF;
  }
  //RES 7, L
  //#0xBD:
  ,function (parentObj) {
    parentObj.registersHL &= 0xFF7F;
  }
  //RES 7, (HL)
  //#0xBE:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) & 0x7F);
  }
  //RES 7, A
  //#0xBF:
  ,function (parentObj) {
    parentObj.registerA &= 0x7F;
  }
  //SET 0, B
  //#0xC0:
  ,function (parentObj) {
    parentObj.registerB |= 0x01;
  }
  //SET 0, C
  //#0xC1:
  ,function (parentObj) {
    parentObj.registerC |= 0x01;
  }
  //SET 0, D
  //#0xC2:
  ,function (parentObj) {
    parentObj.registerD |= 0x01;
  }
  //SET 0, E
  //#0xC3:
  ,function (parentObj) {
    parentObj.registerE |= 0x01;
  }
  //SET 0, H
  //#0xC4:
  ,function (parentObj) {
    parentObj.registersHL |= 0x0100;
  }
  //SET 0, L
  //#0xC5:
  ,function (parentObj) {
    parentObj.registersHL |= 0x01;
  }
  //SET 0, (HL)
  //#0xC6:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x01);
  }
  //SET 0, A
  //#0xC7:
  ,function (parentObj) {
    parentObj.registerA |= 0x01;
  }
  //SET 1, B
  //#0xC8:
  ,function (parentObj) {
    parentObj.registerB |= 0x02;
  }
  //SET 1, C
  //#0xC9:
  ,function (parentObj) {
    parentObj.registerC |= 0x02;
  }
  //SET 1, D
  //#0xCA:
  ,function (parentObj) {
    parentObj.registerD |= 0x02;
  }
  //SET 1, E
  //#0xCB:
  ,function (parentObj) {
    parentObj.registerE |= 0x02;
  }
  //SET 1, H
  //#0xCC:
  ,function (parentObj) {
    parentObj.registersHL |= 0x0200;
  }
  //SET 1, L
  //#0xCD:
  ,function (parentObj) {
    parentObj.registersHL |= 0x02;
  }
  //SET 1, (HL)
  //#0xCE:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x02);
  }
  //SET 1, A
  //#0xCF:
  ,function (parentObj) {
    parentObj.registerA |= 0x02;
  }
  //SET 2, B
  //#0xD0:
  ,function (parentObj) {
    parentObj.registerB |= 0x04;
  }
  //SET 2, C
  //#0xD1:
  ,function (parentObj) {
    parentObj.registerC |= 0x04;
  }
  //SET 2, D
  //#0xD2:
  ,function (parentObj) {
    parentObj.registerD |= 0x04;
  }
  //SET 2, E
  //#0xD3:
  ,function (parentObj) {
    parentObj.registerE |= 0x04;
  }
  //SET 2, H
  //#0xD4:
  ,function (parentObj) {
    parentObj.registersHL |= 0x0400;
  }
  //SET 2, L
  //#0xD5:
  ,function (parentObj) {
    parentObj.registersHL |= 0x04;
  }
  //SET 2, (HL)
  //#0xD6:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x04);
  }
  //SET 2, A
  //#0xD7:
  ,function (parentObj) {
    parentObj.registerA |= 0x04;
  }
  //SET 3, B
  //#0xD8:
  ,function (parentObj) {
    parentObj.registerB |= 0x08;
  }
  //SET 3, C
  //#0xD9:
  ,function (parentObj) {
    parentObj.registerC |= 0x08;
  }
  //SET 3, D
  //#0xDA:
  ,function (parentObj) {
    parentObj.registerD |= 0x08;
  }
  //SET 3, E
  //#0xDB:
  ,function (parentObj) {
    parentObj.registerE |= 0x08;
  }
  //SET 3, H
  //#0xDC:
  ,function (parentObj) {
    parentObj.registersHL |= 0x0800;
  }
  //SET 3, L
  //#0xDD:
  ,function (parentObj) {
    parentObj.registersHL |= 0x08;
  }
  //SET 3, (HL)
  //#0xDE:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x08);
  }
  //SET 3, A
  //#0xDF:
  ,function (parentObj) {
    parentObj.registerA |= 0x08;
  }
  //SET 4, B
  //#0xE0:
  ,function (parentObj) {
    parentObj.registerB |= 0x10;
  }
  //SET 4, C
  //#0xE1:
  ,function (parentObj) {
    parentObj.registerC |= 0x10;
  }
  //SET 4, D
  //#0xE2:
  ,function (parentObj) {
    parentObj.registerD |= 0x10;
  }
  //SET 4, E
  //#0xE3:
  ,function (parentObj) {
    parentObj.registerE |= 0x10;
  }
  //SET 4, H
  //#0xE4:
  ,function (parentObj) {
    parentObj.registersHL |= 0x1000;
  }
  //SET 4, L
  //#0xE5:
  ,function (parentObj) {
    parentObj.registersHL |= 0x10;
  }
  //SET 4, (HL)
  //#0xE6:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x10);
  }
  //SET 4, A
  //#0xE7:
  ,function (parentObj) {
    parentObj.registerA |= 0x10;
  }
  //SET 5, B
  //#0xE8:
  ,function (parentObj) {
    parentObj.registerB |= 0x20;
  }
  //SET 5, C
  //#0xE9:
  ,function (parentObj) {
    parentObj.registerC |= 0x20;
  }
  //SET 5, D
  //#0xEA:
  ,function (parentObj) {
    parentObj.registerD |= 0x20;
  }
  //SET 5, E
  //#0xEB:
  ,function (parentObj) {
    parentObj.registerE |= 0x20;
  }
  //SET 5, H
  //#0xEC:
  ,function (parentObj) {
    parentObj.registersHL |= 0x2000;
  }
  //SET 5, L
  //#0xED:
  ,function (parentObj) {
    parentObj.registersHL |= 0x20;
  }
  //SET 5, (HL)
  //#0xEE:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x20);
  }
  //SET 5, A
  //#0xEF:
  ,function (parentObj) {
    parentObj.registerA |= 0x20;
  }
  //SET 6, B
  //#0xF0:
  ,function (parentObj) {
    parentObj.registerB |= 0x40;
  }
  //SET 6, C
  //#0xF1:
  ,function (parentObj) {
    parentObj.registerC |= 0x40;
  }
  //SET 6, D
  //#0xF2:
  ,function (parentObj) {
    parentObj.registerD |= 0x40;
  }
  //SET 6, E
  //#0xF3:
  ,function (parentObj) {
    parentObj.registerE |= 0x40;
  }
  //SET 6, H
  //#0xF4:
  ,function (parentObj) {
    parentObj.registersHL |= 0x4000;
  }
  //SET 6, L
  //#0xF5:
  ,function (parentObj) {
    parentObj.registersHL |= 0x40;
  }
  //SET 6, (HL)
  //#0xF6:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x40);
  }
  //SET 6, A
  //#0xF7:
  ,function (parentObj) {
    parentObj.registerA |= 0x40;
  }
  //SET 7, B
  //#0xF8:
  ,function (parentObj) {
    parentObj.registerB |= 0x80;
  }
  //SET 7, C
  //#0xF9:
  ,function (parentObj) {
    parentObj.registerC |= 0x80;
  }
  //SET 7, D
  //#0xFA:
  ,function (parentObj) {
    parentObj.registerD |= 0x80;
  }
  //SET 7, E
  //#0xFB:
  ,function (parentObj) {
    parentObj.registerE |= 0x80;
  }
  //SET 7, H
  //#0xFC:
  ,function (parentObj) {
    parentObj.registersHL |= 0x8000;
  }
  //SET 7, L
  //#0xFD:
  ,function (parentObj) {
    parentObj.registersHL |= 0x80;
  }
  //SET 7, (HL)
  //#0xFE:
  ,function (parentObj) {
    parentObj.memoryWriter[parentObj.registersHL](parentObj, parentObj.registersHL, parentObj.memoryReader[parentObj.registersHL](parentObj, parentObj.registersHL) | 0x80);
  }
  //SET 7, A
  //#0xFF:
  ,function (parentObj) {
    parentObj.registerA |= 0x80;
  }
];
GameBoyCore.prototype.TICKTable = [   //Number of machine cycles for each instruction:
/*   0,  1,  2,  3,  4,  5,  6,  7,      8,  9,  A, B,  C,  D, E,  F*/
     4, 12,  8,  8,  4,  4,  8,  4,     20,  8,  8, 8,  4,  4, 8,  4,  //0
     4, 12,  8,  8,  4,  4,  8,  4,     12,  8,  8, 8,  4,  4, 8,  4,  //1
     8, 12,  8,  8,  4,  4,  8,  4,      8,  8,  8, 8,  4,  4, 8,  4,  //2
     8, 12,  8,  8, 12, 12, 12,  4,      8,  8,  8, 8,  4,  4, 8,  4,  //3

     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //4
     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //5
     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //6
     8,  8,  8,  8,  8,  8,  4,  8,      4,  4,  4, 4,  4,  4, 8,  4,  //7

     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //8
     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //9
     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //A
     4,  4,  4,  4,  4,  4,  8,  4,      4,  4,  4, 4,  4,  4, 8,  4,  //B

     8, 12, 12, 16, 12, 16,  8, 16,      8, 16, 12, 0, 12, 24, 8, 16,  //C
     8, 12, 12,  4, 12, 16,  8, 16,      8, 16, 12, 4, 12,  4, 8, 16,  //D
    12, 12,  8,  4,  4, 16,  8, 16,     16,  4, 16, 4,  4,  4, 8, 16,  //E
    12, 12,  8,  4,  4, 16,  8, 16,     12,  8, 16, 4,  0,  4, 8, 16   //F
];
GameBoyCore.prototype.SecondaryTICKTable = [  //Number of machine cycles for each 0xCBXX instruction:
/*  0, 1, 2, 3, 4, 5,  6, 7,        8, 9, A, B, C, D,  E, F*/
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //0
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //1
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //2
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //3

    8, 8, 8, 8, 8, 8, 12, 8,        8, 8, 8, 8, 8, 8, 12, 8,  //4
    8, 8, 8, 8, 8, 8, 12, 8,        8, 8, 8, 8, 8, 8, 12, 8,  //5
    8, 8, 8, 8, 8, 8, 12, 8,        8, 8, 8, 8, 8, 8, 12, 8,  //6
    8, 8, 8, 8, 8, 8, 12, 8,        8, 8, 8, 8, 8, 8, 12, 8,  //7

    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //8
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //9
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //A
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //B

    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //C
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //D
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8,  //E
    8, 8, 8, 8, 8, 8, 16, 8,        8, 8, 8, 8, 8, 8, 16, 8   //F
];
GameBoyCore.prototype.saveSRAMState = function () {
  if (!this.cBATT || this.MBCRam.length == 0) {
    //No battery backup...
    return [];
  }
  else {
    //Return the MBC RAM for backup...
    return this.fromTypedArray(this.MBCRam);
  }
};
GameBoyCore.prototype.saveRTCState = function () {
  if (!this.cTIMER) {
    //No battery backup...
    return [];
  }
  else {
    //Return the MBC RAM for backup...
    return [
      this.lastIteration,
      this.RTCisLatched,
      this.latchedSeconds,
      this.latchedMinutes,
      this.latchedHours,
      this.latchedLDays,
      this.latchedHDays,
      this.RTCSeconds,
      this.RTCMinutes,
      this.RTCHours,
      this.RTCDays,
      this.RTCDayOverFlow,
      this.RTCHALT
    ];
  }
};
GameBoyCore.prototype.saveState = function () {
  return [
    this.fromTypedArray(this.ROM),
    this.inBootstrap,
    this.registerA,
    this.FZero,
    this.FSubtract,
    this.FHalfCarry,
    this.FCarry,
    this.registerB,
    this.registerC,
    this.registerD,
    this.registerE,
    this.registersHL,
    this.stackPointer,
    this.programCounter,
    this.halt,
    this.IME,
    this.hdmaRunning,
    this.CPUTicks,
    this.doubleSpeedShifter,
    this.fromTypedArray(this.memory),
    this.fromTypedArray(this.MBCRam),
    this.fromTypedArray(this.VRAM),
    this.currVRAMBank,
    this.fromTypedArray(this.GBCMemory),
    this.MBC1Mode,
    this.MBCRAMBanksEnabled,
    this.currMBCRAMBank,
    this.currMBCRAMBankPosition,
    this.cGBC,
    this.gbcRamBank,
    this.gbcRamBankPosition,
    this.ROMBank1offs,
    this.currentROMBank,
    this.cartridgeType,
    this.name,
    this.gameCode,
    this.modeSTAT,
    this.LYCMatchTriggerSTAT,
    this.mode2TriggerSTAT,
    this.mode1TriggerSTAT,
    this.mode0TriggerSTAT,
    this.LCDisOn,
    this.gfxWindowCHRBankPosition,
    this.gfxWindowDisplay,
    this.gfxSpriteShow,
    this.gfxSpriteNormalHeight,
    this.gfxBackgroundCHRBankPosition,
    this.gfxBackgroundBankOffset,
    this.TIMAEnabled,
    this.DIVTicks,
    this.LCDTicks,
    this.timerTicks,
    this.TACClocker,
    this.serialTimer,
    this.serialShiftTimer,
    this.serialShiftTimerAllocated,
    this.IRQEnableDelay,
    this.lastIteration,
    this.cMBC1,
    this.cMBC2,
    this.cMBC3,
    this.cMBC5,
    this.cMBC7,
    this.cSRAM,
    this.cMMMO1,
    this.cRUMBLE,
    this.cCamera,
    this.cTAMA5,
    this.cHuC3,
    this.cHuC1,
    this.drewBlank,
    this.fromTypedArray(this.frameBuffer),
    this.bgEnabled,
    this.BGPriorityEnabled,
    this.channel1FrequencyTracker,
    this.channel1FrequencyCounter,
    this.channel1totalLength,
    this.channel1envelopeVolume,
    this.channel1envelopeType,
    this.channel1envelopeSweeps,
    this.channel1envelopeSweepsLast,
    this.channel1consecutive,
    this.channel1frequency,
    this.channel1SweepFault,
    this.channel1ShadowFrequency,
    this.channel1timeSweep,
    this.channel1lastTimeSweep,
    this.channel1Swept,
    this.channel1frequencySweepDivider,
    this.channel1decreaseSweep,
    this.channel2FrequencyTracker,
    this.channel2FrequencyCounter,
    this.channel2totalLength,
    this.channel2envelopeVolume,
    this.channel2envelopeType,
    this.channel2envelopeSweeps,
    this.channel2envelopeSweepsLast,
    this.channel2consecutive,
    this.channel2frequency,
    this.channel3canPlay,
    this.channel3totalLength,
    this.channel3patternType,
    this.channel3frequency,
    this.channel3consecutive,
    this.fromTypedArray(this.channel3PCM),
    this.channel4FrequencyPeriod,
    this.channel4lastSampleLookup,
    this.channel4totalLength,
    this.channel4envelopeVolume,
    this.channel4currentVolume,
    this.channel4envelopeType,
    this.channel4envelopeSweeps,
    this.channel4envelopeSweepsLast,
    this.channel4consecutive,
    this.channel4BitRange,
    this.soundMasterEnabled,
    this.VinLeftChannelMasterVolume,
    this.VinRightChannelMasterVolume,
    this.leftChannel1,
    this.leftChannel2,
    this.leftChannel3,
    this.leftChannel4,
    this.rightChannel1,
    this.rightChannel2,
    this.rightChannel3,
    this.rightChannel4,
    this.channel1currentSampleLeft,
    this.channel1currentSampleRight,
    this.channel2currentSampleLeft,
    this.channel2currentSampleRight,
    this.channel3currentSampleLeft,
    this.channel3currentSampleRight,
    this.channel4currentSampleLeft,
    this.channel4currentSampleRight,
    this.channel1currentSampleLeftSecondary,
    this.channel1currentSampleRightSecondary,
    this.channel2currentSampleLeftSecondary,
    this.channel2currentSampleRightSecondary,
    this.channel3currentSampleLeftSecondary,
    this.channel3currentSampleRightSecondary,
    this.channel4currentSampleLeftSecondary,
    this.channel4currentSampleRightSecondary,
    this.channel1currentSampleLeftTrimary,
    this.channel1currentSampleRightTrimary,
    this.channel2currentSampleLeftTrimary,
    this.channel2currentSampleRightTrimary,
    this.mixerOutputCache,
    this.channel1DutyTracker,
    this.channel1CachedDuty,
    this.channel2DutyTracker,
    this.channel2CachedDuty,
    this.channel1Enabled,
    this.channel2Enabled,
    this.channel3Enabled,
    this.channel4Enabled,
    this.sequencerClocks,
    this.sequencePosition,
    this.channel3Counter,
    this.channel4Counter,
    this.cachedChannel3Sample,
    this.cachedChannel4Sample,
    this.channel3FrequencyPeriod,
    this.channel3lastSampleLookup,
    this.actualScanLine,
    this.lastUnrenderedLine,
    this.queuedScanLines,
    this.RTCisLatched,
    this.latchedSeconds,
    this.latchedMinutes,
    this.latchedHours,
    this.latchedLDays,
    this.latchedHDays,
    this.RTCSeconds,
    this.RTCMinutes,
    this.RTCHours,
    this.RTCDays,
    this.RTCDayOverFlow,
    this.RTCHALT,
    this.usedBootROM,
    this.skipPCIncrement,
    this.STATTracker,
    this.gbcRamBankPositionECHO,
    this.numRAMBanks,
    this.windowY,
    this.windowX,
    this.fromTypedArray(this.gbcOBJRawPalette),
    this.fromTypedArray(this.gbcBGRawPalette),
    this.fromTypedArray(this.gbOBJPalette),
    this.fromTypedArray(this.gbBGPalette),
    this.fromTypedArray(this.gbcOBJPalette),
    this.fromTypedArray(this.gbcBGPalette),
    this.fromTypedArray(this.gbBGColorizedPalette),
    this.fromTypedArray(this.gbOBJColorizedPalette),
    this.fromTypedArray(this.cachedBGPaletteConversion),
    this.fromTypedArray(this.cachedOBJPaletteConversion),
    this.fromTypedArray(this.BGCHRBank1),
    this.fromTypedArray(this.BGCHRBank2),
    this.haltPostClocks,
    this.interruptsRequested,
    this.interruptsEnabled,
    this.remainingClocks,
    this.colorizedGBPalettes,
    this.backgroundY,
    this.backgroundX,
    this.CPUStopped,
    this.audioClocksUntilNextEvent,
    this.audioClocksUntilNextEventCounter
  ];
};
GameBoyCore.prototype.returnFromState = function (returnedFrom) {
  var index = 0;
  var state = returnedFrom.slice(0);
  this.ROM = this.toTypedArray(state[index++], "uint8");
  this.ROMBankEdge = Math.floor(this.ROM.length / 0x4000);
  this.inBootstrap = state[index++];
  this.registerA = state[index++];
  this.FZero = state[index++];
  this.FSubtract = state[index++];
  this.FHalfCarry = state[index++];
  this.FCarry = state[index++];
  this.registerB = state[index++];
  this.registerC = state[index++];
  this.registerD = state[index++];
  this.registerE = state[index++];
  this.registersHL = state[index++];
  this.stackPointer = state[index++];
  this.programCounter = state[index++];
  this.halt = state[index++];
  this.IME = state[index++];
  this.hdmaRunning = state[index++];
  this.CPUTicks = state[index++];
  this.doubleSpeedShifter = state[index++];
  this.memory = this.toTypedArray(state[index++], "uint8");
  this.MBCRam = this.toTypedArray(state[index++], "uint8");
  this.VRAM = this.toTypedArray(state[index++], "uint8");
  this.currVRAMBank = state[index++];
  this.GBCMemory = this.toTypedArray(state[index++], "uint8");
  this.MBC1Mode = state[index++];
  this.MBCRAMBanksEnabled = state[index++];
  this.currMBCRAMBank = state[index++];
  this.currMBCRAMBankPosition = state[index++];
  this.cGBC = state[index++];
  this.gbcRamBank = state[index++];
  this.gbcRamBankPosition = state[index++];
  this.ROMBank1offs = state[index++];
  this.currentROMBank = state[index++];
  this.cartridgeType = state[index++];
  this.name = state[index++];
  this.gameCode = state[index++];
  this.modeSTAT = state[index++];
  this.LYCMatchTriggerSTAT = state[index++];
  this.mode2TriggerSTAT = state[index++];
  this.mode1TriggerSTAT = state[index++];
  this.mode0TriggerSTAT = state[index++];
  this.LCDisOn = state[index++];
  this.gfxWindowCHRBankPosition = state[index++];
  this.gfxWindowDisplay = state[index++];
  this.gfxSpriteShow = state[index++];
  this.gfxSpriteNormalHeight = state[index++];
  this.gfxBackgroundCHRBankPosition = state[index++];
  this.gfxBackgroundBankOffset = state[index++];
  this.TIMAEnabled = state[index++];
  this.DIVTicks = state[index++];
  this.LCDTicks = state[index++];
  this.timerTicks = state[index++];
  this.TACClocker = state[index++];
  this.serialTimer = state[index++];
  this.serialShiftTimer = state[index++];
  this.serialShiftTimerAllocated = state[index++];
  this.IRQEnableDelay = state[index++];
  this.lastIteration = state[index++];
  this.cMBC1 = state[index++];
  this.cMBC2 = state[index++];
  this.cMBC3 = state[index++];
  this.cMBC5 = state[index++];
  this.cMBC7 = state[index++];
  this.cSRAM = state[index++];
  this.cMMMO1 = state[index++];
  this.cRUMBLE = state[index++];
  this.cCamera = state[index++];
  this.cTAMA5 = state[index++];
  this.cHuC3 = state[index++];
  this.cHuC1 = state[index++];
  this.drewBlank = state[index++];
  this.frameBuffer = this.toTypedArray(state[index++], "int32");
  this.bgEnabled = state[index++];
  this.BGPriorityEnabled = state[index++];
  this.channel1FrequencyTracker = state[index++];
  this.channel1FrequencyCounter = state[index++];
  this.channel1totalLength = state[index++];
  this.channel1envelopeVolume = state[index++];
  this.channel1envelopeType = state[index++];
  this.channel1envelopeSweeps = state[index++];
  this.channel1envelopeSweepsLast = state[index++];
  this.channel1consecutive = state[index++];
  this.channel1frequency = state[index++];
  this.channel1SweepFault = state[index++];
  this.channel1ShadowFrequency = state[index++];
  this.channel1timeSweep = state[index++];
  this.channel1lastTimeSweep = state[index++];
  this.channel1Swept = state[index++];
  this.channel1frequencySweepDivider = state[index++];
  this.channel1decreaseSweep = state[index++];
  this.channel2FrequencyTracker = state[index++];
  this.channel2FrequencyCounter = state[index++];
  this.channel2totalLength = state[index++];
  this.channel2envelopeVolume = state[index++];
  this.channel2envelopeType = state[index++];
  this.channel2envelopeSweeps = state[index++];
  this.channel2envelopeSweepsLast = state[index++];
  this.channel2consecutive = state[index++];
  this.channel2frequency = state[index++];
  this.channel3canPlay = state[index++];
  this.channel3totalLength = state[index++];
  this.channel3patternType = state[index++];
  this.channel3frequency = state[index++];
  this.channel3consecutive = state[index++];
  this.channel3PCM = this.toTypedArray(state[index++], "int8");
  this.channel4FrequencyPeriod = state[index++];
  this.channel4lastSampleLookup = state[index++];
  this.channel4totalLength = state[index++];
  this.channel4envelopeVolume = state[index++];
  this.channel4currentVolume = state[index++];
  this.channel4envelopeType = state[index++];
  this.channel4envelopeSweeps = state[index++];
  this.channel4envelopeSweepsLast = state[index++];
  this.channel4consecutive = state[index++];
  this.channel4BitRange = state[index++];
  this.soundMasterEnabled = state[index++];
  this.VinLeftChannelMasterVolume = state[index++];
  this.VinRightChannelMasterVolume = state[index++];
  this.leftChannel1 = state[index++];
  this.leftChannel2 = state[index++];
  this.leftChannel3 = state[index++];
  this.leftChannel4 = state[index++];
  this.rightChannel1 = state[index++];
  this.rightChannel2 = state[index++];
  this.rightChannel3 = state[index++];
  this.rightChannel4 = state[index++];
  this.channel1currentSampleLeft = state[index++];
  this.channel1currentSampleRight = state[index++];
  this.channel2currentSampleLeft = state[index++];
  this.channel2currentSampleRight = state[index++];
  this.channel3currentSampleLeft = state[index++];
  this.channel3currentSampleRight = state[index++];
  this.channel4currentSampleLeft = state[index++];
  this.channel4currentSampleRight = state[index++];
  this.channel1currentSampleLeftSecondary = state[index++];
  this.channel1currentSampleRightSecondary = state[index++];
  this.channel2currentSampleLeftSecondary = state[index++];
  this.channel2currentSampleRightSecondary = state[index++];
  this.channel3currentSampleLeftSecondary = state[index++];
  this.channel3currentSampleRightSecondary = state[index++];
  this.channel4currentSampleLeftSecondary = state[index++];
  this.channel4currentSampleRightSecondary = state[index++];
  this.channel1currentSampleLeftTrimary = state[index++];
  this.channel1currentSampleRightTrimary = state[index++];
  this.channel2currentSampleLeftTrimary = state[index++];
  this.channel2currentSampleRightTrimary = state[index++];
  this.mixerOutputCache = state[index++];
  this.channel1DutyTracker = state[index++];
  this.channel1CachedDuty = state[index++];
  this.channel2DutyTracker = state[index++];
  this.channel2CachedDuty = state[index++];
  this.channel1Enabled = state[index++];
  this.channel2Enabled = state[index++];
  this.channel3Enabled = state[index++];
  this.channel4Enabled = state[index++];
  this.sequencerClocks = state[index++];
  this.sequencePosition = state[index++];
  this.channel3Counter = state[index++];
  this.channel4Counter = state[index++];
  this.cachedChannel3Sample = state[index++];
  this.cachedChannel4Sample = state[index++];
  this.channel3FrequencyPeriod = state[index++];
  this.channel3lastSampleLookup = state[index++];
  this.actualScanLine = state[index++];
  this.lastUnrenderedLine = state[index++];
  this.queuedScanLines = state[index++];
  this.RTCisLatched = state[index++];
  this.latchedSeconds = state[index++];
  this.latchedMinutes = state[index++];
  this.latchedHours = state[index++];
  this.latchedLDays = state[index++];
  this.latchedHDays = state[index++];
  this.RTCSeconds = state[index++];
  this.RTCMinutes = state[index++];
  this.RTCHours = state[index++];
  this.RTCDays = state[index++];
  this.RTCDayOverFlow = state[index++];
  this.RTCHALT = state[index++];
  this.usedBootROM = state[index++];
  this.skipPCIncrement = state[index++];
  this.STATTracker = state[index++];
  this.gbcRamBankPositionECHO = state[index++];
  this.numRAMBanks = state[index++];
  this.windowY = state[index++];
  this.windowX = state[index++];
  this.gbcOBJRawPalette = this.toTypedArray(state[index++], "uint8");
  this.gbcBGRawPalette = this.toTypedArray(state[index++], "uint8");
  this.gbOBJPalette = this.toTypedArray(state[index++], "int32");
  this.gbBGPalette = this.toTypedArray(state[index++], "int32");
  this.gbcOBJPalette = this.toTypedArray(state[index++], "int32");
  this.gbcBGPalette = this.toTypedArray(state[index++], "int32");
  this.gbBGColorizedPalette = this.toTypedArray(state[index++], "int32");
  this.gbOBJColorizedPalette = this.toTypedArray(state[index++], "int32");
  this.cachedBGPaletteConversion = this.toTypedArray(state[index++], "int32");
  this.cachedOBJPaletteConversion = this.toTypedArray(state[index++], "int32");
  this.BGCHRBank1 = this.toTypedArray(state[index++], "uint8");
  this.BGCHRBank2 = this.toTypedArray(state[index++], "uint8");
  this.haltPostClocks = state[index++];
  this.interruptsRequested = state[index++];
  this.interruptsEnabled = state[index++];
  this.checkIRQMatching();
  this.remainingClocks = state[index++];
  this.colorizedGBPalettes = state[index++];
  this.backgroundY = state[index++];
  this.backgroundX = state[index++];
  this.CPUStopped = state[index++];
  this.audioClocksUntilNextEvent = state[index++];
  this.audioClocksUntilNextEventCounter = state[index];
  this.fromSaveState = true;
  this.TICKTable = this.toTypedArray(this.TICKTable, "uint8");
  this.SecondaryTICKTable = this.toTypedArray(this.SecondaryTICKTable, "uint8");
  this.initializeReferencesFromSaveState();
  this.memoryReadJumpCompile();
  this.memoryWriteJumpCompile();
  this.initLCD();
  this.initSound();
  this.noiseSampleTable = (this.channel4BitRange == 0x7FFF) ? this.LSFR15Table : this.LSFR7Table;
  this.channel4VolumeShifter = (this.channel4BitRange == 0x7FFF) ? 15 : 7;
};
GameBoyCore.prototype.returnFromRTCState = function () {
  if (typeof this.openRTC == "function" && this.cTIMER) {
    var rtcData = this.openRTC(this.name);
    var index = 0;
    this.lastIteration = rtcData[index++];
    this.RTCisLatched = rtcData[index++];
    this.latchedSeconds = rtcData[index++];
    this.latchedMinutes = rtcData[index++];
    this.latchedHours = rtcData[index++];
    this.latchedLDays = rtcData[index++];
    this.latchedHDays = rtcData[index++];
    this.RTCSeconds = rtcData[index++];
    this.RTCMinutes = rtcData[index++];
    this.RTCHours = rtcData[index++];
    this.RTCDays = rtcData[index++];
    this.RTCDayOverFlow = rtcData[index++];
    this.RTCHALT = rtcData[index];
  }
};
GameBoyCore.prototype.start = function () {
  this.initMemory();  //Write the startup memory.
  this.ROMLoad();   //Load the ROM into memory and get cartridge information from it.
  this.initLCD();   //Initialize the graphics.
  this.initSound(); //Sound object initialization.
  this.run();     //Start the emulation.
};
GameBoyCore.prototype.initMemory = function () {
  //Initialize the RAM:
  this.memory = this.getTypedArray(0x10000, 0, "uint8");
  this.frameBuffer = this.getTypedArray(23040, 0xF8F8F8, "int32");
  this.BGCHRBank1 = this.getTypedArray(0x800, 0, "uint8");
  this.TICKTable = this.toTypedArray(this.TICKTable, "uint8");
  this.SecondaryTICKTable = this.toTypedArray(this.SecondaryTICKTable, "uint8");
  this.channel3PCM = this.getTypedArray(0x20, 0, "int8");
};
GameBoyCore.prototype.generateCacheArray = function (tileAmount) {
  var tileArray = [];
  var tileNumber = 0;
  while (tileNumber < tileAmount) {
    tileArray[tileNumber++] = this.getTypedArray(64, 0, "uint8");
  }
  return tileArray;
};
GameBoyCore.prototype.initSkipBootstrap = function () {
  //Fill in the boot ROM set register values
  //Default values to the GB boot ROM values, then fill in the GBC boot ROM values after ROM loading
  var index = 0xFF;
  while (index >= 0) {
    if (index >= 0x30 && index < 0x40) {
      this.memoryWrite(0xFF00 | index, this.ffxxDump[index]);
    }
    else {
      switch (index) {
        case 0x00:
        case 0x01:
        case 0x02:
        case 0x05:
        case 0x07:
        case 0x0F:
        case 0xFF:
          this.memoryWrite(0xFF00 | index, this.ffxxDump[index]);
          break;
        default:
          this.memory[0xFF00 | index] = this.ffxxDump[index];
      }
    }
    --index;
  }
  if (this.cGBC) {
    this.memory[0xFF6C] = 0xFE;
    this.memory[0xFF74] = 0xFE;
  }
  else {
    this.memory[0xFF48] = 0xFF;
    this.memory[0xFF49] = 0xFF;
    this.memory[0xFF6C] = 0xFF;
    this.memory[0xFF74] = 0xFF;
  }
  //Start as an unset device:
  debug("Starting without the GBC boot ROM.", 0);
  this.registerA = (this.cGBC) ? 0x11 : 0x1;
  this.registerB = 0;
  this.registerC = 0x13;
  this.registerD = 0;
  this.registerE = 0xD8;
  this.FZero = true;
  this.FSubtract = false;
  this.FHalfCarry = true;
  this.FCarry = true;
  this.registersHL = 0x014D;
  this.LCDCONTROL = this.LINECONTROL;
  this.IME = false;
  this.IRQLineMatched = 0;
  this.interruptsRequested = 225;
  this.interruptsEnabled = 0;
  this.hdmaRunning = false;
  this.CPUTicks = 12;
  this.STATTracker = 0;
  this.modeSTAT = 1;
  this.spriteCount = 252;
  this.LYCMatchTriggerSTAT = false;
  this.mode2TriggerSTAT = false;
  this.mode1TriggerSTAT = false;
  this.mode0TriggerSTAT = false;
  this.LCDisOn = true;
  this.channel1FrequencyTracker = 0x2000;
  this.channel1DutyTracker = 0;
  this.channel1CachedDuty = this.dutyLookup[2];
  this.channel1totalLength = 0;
  this.channel1envelopeVolume = 0;
  this.channel1envelopeType = false;
  this.channel1envelopeSweeps = 0;
  this.channel1envelopeSweepsLast = 0;
  this.channel1consecutive = true;
  this.channel1frequency = 1985;
  this.channel1SweepFault = true;
  this.channel1ShadowFrequency = 1985;
  this.channel1timeSweep = 1;
  this.channel1lastTimeSweep = 0;
  this.channel1Swept = false;
  this.channel1frequencySweepDivider = 0;
  this.channel1decreaseSweep = false;
  this.channel2FrequencyTracker = 0x2000;
  this.channel2DutyTracker = 0;
  this.channel2CachedDuty = this.dutyLookup[2];
  this.channel2totalLength = 0;
  this.channel2envelopeVolume = 0;
  this.channel2envelopeType = false;
  this.channel2envelopeSweeps = 0;
  this.channel2envelopeSweepsLast = 0;
  this.channel2consecutive = true;
  this.channel2frequency = 0;
  this.channel3canPlay = false;
  this.channel3totalLength = 0;
  this.channel3patternType = 4;
  this.channel3frequency = 0;
  this.channel3consecutive = true;
  this.channel3Counter = 0x418;
  this.channel4FrequencyPeriod = 8;
  this.channel4totalLength = 0;
  this.channel4envelopeVolume = 0;
  this.channel4currentVolume = 0;
  this.channel4envelopeType = false;
  this.channel4envelopeSweeps = 0;
  this.channel4envelopeSweepsLast = 0;
  this.channel4consecutive = true;
  this.channel4BitRange = 0x7FFF;
  this.channel4VolumeShifter = 15;
  this.channel1FrequencyCounter = 0x200;
  this.channel2FrequencyCounter = 0x200;
  this.channel3Counter = 0x800;
  this.channel3FrequencyPeriod = 0x800;
  this.channel3lastSampleLookup = 0;
  this.channel4lastSampleLookup = 0;
  this.VinLeftChannelMasterVolume = 8;
  this.VinRightChannelMasterVolume = 8;
  this.soundMasterEnabled = true;
  this.leftChannel1 = true;
  this.leftChannel2 = true;
  this.leftChannel3 = true;
  this.leftChannel4 = true;
  this.rightChannel1 = true;
  this.rightChannel2 = true;
  this.rightChannel3 = false;
  this.rightChannel4 = false;
  this.DIVTicks = 27044;
  this.LCDTicks = 160;
  this.timerTicks = 0;
  this.TIMAEnabled = false;
  this.TACClocker = 1024;
  this.serialTimer = 0;
  this.serialShiftTimer = 0;
  this.serialShiftTimerAllocated = 0;
  this.IRQEnableDelay = 0;
  this.actualScanLine = 144;
  this.lastUnrenderedLine = 0;
  this.gfxWindowDisplay = false;
  this.gfxSpriteShow = false;
  this.gfxSpriteNormalHeight = true;
  this.bgEnabled = true;
  this.BGPriorityEnabled = true;
  this.gfxWindowCHRBankPosition = 0;
  this.gfxBackgroundCHRBankPosition = 0;
  this.gfxBackgroundBankOffset = 0;
  this.windowY = 0;
  this.windowX = 0;
  this.drewBlank = 0;
  this.midScanlineOffset = -1;
  this.currentX = 0;
};
GameBoyCore.prototype.initBootstrap = function () {
  //Start as an unset device:
  debug("Starting the selected boot ROM.", 0);
  this.programCounter = 0;
  this.stackPointer = 0;
  this.IME = false;
  this.LCDTicks = 0;
  this.DIVTicks = 0;
  this.registerA = 0;
  this.registerB = 0;
  this.registerC = 0;
  this.registerD = 0;
  this.registerE = 0;
  this.FZero = this.FSubtract = this.FHalfCarry = this.FCarry = false;
  this.registersHL = 0;
  this.leftChannel1 = false;
  this.leftChannel2 = false;
  this.leftChannel3 = false;
  this.leftChannel4 = false;
  this.rightChannel1 = false;
  this.rightChannel2 = false;
  this.rightChannel3 = false;
  this.rightChannel4 = false;
  this.channel2frequency = this.channel1frequency = 0;
  this.channel4consecutive = this.channel2consecutive = this.channel1consecutive = false;
  this.VinLeftChannelMasterVolume = 8;
  this.VinRightChannelMasterVolume = 8;
  this.memory[0xFF00] = 0xF;  //Set the joypad state.
};
GameBoyCore.prototype.ROMLoad = function () {
  //Load the first two ROM banks (0x0000 - 0x7FFF) into regular gameboy memory:
  this.ROM = [];
  this.usedBootROM = this.opts.bootRom && ((!this.opts.gbBootRom && this.GBCBOOTROM.length == 0x800) || (this.opts.gbBootRom && this.GBBOOTROM.length == 0x100));
  var maxLength = this.ROMImage.length;
  if (maxLength < 0x4000) {
    throw(new Error("ROM image size too small."));
  }
  this.ROM = this.getTypedArray(maxLength, 0, "uint8");
  var romIndex = 0;
  if (this.usedBootROM) {
    if (!this.opts.gbBootRom) {
      //Patch in the GBC boot ROM into the memory map:
      if (this.ROMImageIsString) {
        for (; romIndex < 0x100; ++romIndex) {
          this.memory[romIndex] = this.GBCBOOTROM[romIndex];                      //Load in the GameBoy Color BOOT ROM.
          this.ROM[romIndex] = (this.ROMImage.charCodeAt(romIndex) & 0xFF);             //Decode the ROM binary for the switch out.
        }
        for (; romIndex < 0x200; ++romIndex) {
          this.memory[romIndex] = this.ROM[romIndex] = (this.ROMImage.charCodeAt(romIndex) & 0xFF); //Load in the game ROM.
        }
        for (; romIndex < 0x900; ++romIndex) {
          this.memory[romIndex] = this.GBCBOOTROM[romIndex - 0x100];                  //Load in the GameBoy Color BOOT ROM.
          this.ROM[romIndex] = (this.ROMImage.charCodeAt(romIndex) & 0xFF);             //Decode the ROM binary for the switch out.
        }
      } else {
        for (; romIndex < 0x100; ++romIndex) {
          this.memory[romIndex] = this.GBCBOOTROM[romIndex];                      //Load in the GameBoy Color BOOT ROM.
          this.ROM[romIndex] = this.ROMImage[romIndex];             //Decode the ROM binary for the switch out.
        }
        for (; romIndex < 0x200; ++romIndex) {
          this.memory[romIndex] = this.ROM[romIndex] = this.ROMImage[romIndex]; //Load in the game ROM.
        }
        for (; romIndex < 0x900; ++romIndex) {
          this.memory[romIndex] = this.GBCBOOTROM[romIndex - 0x100];                  //Load in the GameBoy Color BOOT ROM.
          this.ROM[romIndex] = this.ROMImage[romIndex];             //Decode the ROM binary for the switch out.
        }
      }

      this.usedGBCBootROM = true;
    }
    else {
      if (this.ROMImageIsString) {
        //Patch in the GBC boot ROM into the memory map:
        for (; romIndex < 0x100; ++romIndex) {
          this.memory[romIndex] = this.GBBOOTROM[romIndex];                     //Load in the GameBoy Color BOOT ROM.
          this.ROM[romIndex] = (this.ROMImage.charCodeAt(romIndex) & 0xFF);             //Decode the ROM binary for the switch out.
        }
      } else {
        //Patch in the GBC boot ROM into the memory map:
        for (; romIndex < 0x100; ++romIndex) {
          this.memory[romIndex] = this.GBBOOTROM[romIndex];                     //Load in the GameBoy Color BOOT ROM.
          this.ROM[romIndex] = this.ROMImage.romIndex;             //Decode the ROM binary for the switch out.
        }
      }
    }
    if (this.ROMImageIsString) {
      for (; romIndex < 0x4000; ++romIndex) {
        this.memory[romIndex] = this.ROM[romIndex] = (this.ROMImage.charCodeAt(romIndex) & 0xFF); //Load in the game ROM.
      }
    } else {
      for (; romIndex < 0x4000; ++romIndex) {
        this.memory[romIndex] = this.ROM[romIndex] = this.ROMImage[romIndex]; //Load in the game ROM.
      }
    }
  }
  else {
    if (this.ROMImageIsString) {
      //Don't load in the boot ROM:
      for (; romIndex < 0x4000; ++romIndex) {
        this.memory[romIndex] = this.ROM[romIndex] = (this.ROMImage.charCodeAt(romIndex) & 0xFF); //Load in the game ROM.
      }
    } else {
      //Don't load in the boot ROM:
      for (; romIndex < 0x4000; ++romIndex) {
        this.memory[romIndex] = this.ROM[romIndex] = this.ROMImage[romIndex]; //Load in the game ROM.
      }
    }
  }
  //Finish the decoding of the ROM binary:
  if (this.ROMImageIsString) {
    for (; romIndex < maxLength; ++romIndex) {
      this.ROM[romIndex] = this.ROMImage.charCodeAt(romIndex) & 0xFF;
    }
  } else {
    for (; romIndex < maxLength; ++romIndex) {
      this.ROM[romIndex] = this.ROMImage[romIndex];
    }
  }
  this.ROMBankEdge = Math.floor(this.ROM.length / 0x4000);
  //Set up the emulator for the cartidge specifics:
  this.interpretCartridge();
  //Check for IRQ matching upon initialization:
  this.checkIRQMatching();
};
GameBoyCore.prototype.getROMImage = function () {
  //Return the binary version of the ROM image currently running:
  if (this.ROMImage.length > 0) {
    return this.ROMImage.length;
  }
  var length = this.ROM.length;
  for (var index = 0; index < length; index++) {
    this.ROMImage += String.fromCharCode(this.ROM[index]);
  }
  return this.ROMImage;
};
GameBoyCore.prototype.interpretCartridge = function () {
  var extra;

  if (this.ROMImageIsString) {
    // ROM name
    for (var index = 0x134; index < 0x13F; index++) {
      if (this.ROMImage[index] > 0) {
        this.name += this.ROMImage[index];
      }
    }
    // ROM game code (for newer games)
    for (var index = 0x13F; index < 0x143; index++) {
      if (this.ROMImage[index] > 0) {
        this.gameCode += this.ROMImage[index];
      }
    }

    extra = this.ROMImage[0x143];
  } else {
    // ROM name
    for (var index = 0x134; index < 0x13F; index++) {
      if (this.ROMImage[index] > 0) {
        this.name += String.fromCharCode(this.ROMImage[index]);
      }
    }
    // ROM game code (for newer games)
    for (var index = 0x13F; index < 0x143; index++) {
      if (this.ROMImage[index] > 0) {
        this.gameCode += String.fromCharCode(this.ROMImage[index]);
      }
    }
    
    extra = String.fromCharCode(this.ROMImage[0x143]);
  }

  debug("Game Title: " + this.name + "[" + this.gameCode + "][" + extra + "]", 0);
  debug("Game Code: " + this.gameCode, 0);
  // Cartridge type
  this.cartridgeType = this.ROM[0x147];
  debug("Cartridge type #" + this.cartridgeType, 0);
  //Map out ROM cartridge sub-types.
  var MBCType = "";
  switch (this.cartridgeType) {
    case 0x00:
      //ROM w/o bank switching
      if (!this.opts.mbc1) {
        MBCType = "ROM";
        break;
      }
    case 0x01:
      this.cMBC1 = true;
      MBCType = "MBC1";
      break;
    case 0x02:
      this.cMBC1 = true;
      this.cSRAM = true;
      MBCType = "MBC1 + SRAM";
      break;
    case 0x03:
      this.cMBC1 = true;
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "MBC1 + SRAM + BATT";
      break;
    case 0x05:
      this.cMBC2 = true;
      MBCType = "MBC2";
      break;
    case 0x06:
      this.cMBC2 = true;
      this.cBATT = true;
      MBCType = "MBC2 + BATT";
      break;
    case 0x08:
      this.cSRAM = true;
      MBCType = "ROM + SRAM";
      break;
    case 0x09:
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "ROM + SRAM + BATT";
      break;
    case 0x0B:
      this.cMMMO1 = true;
      MBCType = "MMMO1";
      break;
    case 0x0C:
      this.cMMMO1 = true;
      this.cSRAM = true;
      MBCType = "MMMO1 + SRAM";
      break;
    case 0x0D:
      this.cMMMO1 = true;
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "MMMO1 + SRAM + BATT";
      break;
    case 0x0F:
      this.cMBC3 = true;
      this.cTIMER = true;
      this.cBATT = true;
      MBCType = "MBC3 + TIMER + BATT";
      break;
    case 0x10:
      this.cMBC3 = true;
      this.cTIMER = true;
      this.cBATT = true;
      this.cSRAM = true;
      MBCType = "MBC3 + TIMER + BATT + SRAM";
      break;
    case 0x11:
      this.cMBC3 = true;
      MBCType = "MBC3";
      break;
    case 0x12:
      this.cMBC3 = true;
      this.cSRAM = true;
      MBCType = "MBC3 + SRAM";
      break;
    case 0x13:
      this.cMBC3 = true;
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "MBC3 + SRAM + BATT";
      break;
    case 0x19:
      this.cMBC5 = true;
      MBCType = "MBC5";
      break;
    case 0x1A:
      this.cMBC5 = true;
      this.cSRAM = true;
      MBCType = "MBC5 + SRAM";
      break;
    case 0x1B:
      this.cMBC5 = true;
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "MBC5 + SRAM + BATT";
      break;
    case 0x1C:
      this.cRUMBLE = true;
      MBCType = "RUMBLE";
      break;
    case 0x1D:
      this.cRUMBLE = true;
      this.cSRAM = true;
      MBCType = "RUMBLE + SRAM";
      break;
    case 0x1E:
      this.cRUMBLE = true;
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "RUMBLE + SRAM + BATT";
      break;
    case 0x1F:
      this.cCamera = true;
      MBCType = "GameBoy Camera";
      break;
    case 0x22:
      this.cMBC7 = true;
      this.cSRAM = true;
      this.cBATT = true;
      MBCType = "MBC7 + SRAM + BATT";
      break;
    case 0xFD:
      this.cTAMA5 = true;
      MBCType = "TAMA5";
      break;
    case 0xFE:
      this.cHuC3 = true;
      MBCType = "HuC3";
      break;
    case 0xFF:
      this.cHuC1 = true;
      MBCType = "HuC1";
      break;
    default:
      MBCType = "Unknown";
      this.emit('error', new Error("Cartridge type is unknown."));
  }
  debug("Cartridge Type: " + MBCType + ".", 0);
  // ROM and RAM banks
  this.numROMBanks = this.ROMBanks[this.ROM[0x148]];
  debug(this.numROMBanks + " ROM banks.", 0);
  switch (this.RAMBanks[this.ROM[0x149]]) {
    case 0:
      debug("No RAM banking requested for allocation or MBC is of type 2.", 0);
      break;
    case 2:
      debug("1 RAM bank requested for allocation.", 0);
      break;
    case 3:
      debug("4 RAM banks requested for allocation.", 0);
      break;
    case 4:
      debug("16 RAM banks requested for allocation.", 0);
      break;
    default:
      debug("RAM bank amount requested is unknown, will use maximum allowed by specified MBC type.", 0);
  }
  //Check the GB/GBC mode byte:
  if (!this.usedBootROM) {
    switch (this.ROM[0x143]) {
      case 0x00:  //Only GB mode
        this.cGBC = false;
        debug("Only GB mode detected.", 0);
        break;
      case 0x32:  //Exception to the GBC identifying code:
        if (!this.opts.prioritizeGb && this.name + this.gameCode + this.ROM[0x143] == "Game and Watch 50") {
          this.cGBC = true;
          debug("Created a boot exception for Game and Watch Gallery 2 (GBC ID byte is wrong on the cartridge).", 1);
        }
        else {
          this.cGBC = false;
        }
        break;
      case 0x80:  //Both GB + GBC modes
        this.cGBC = !this.opts.prioritizeGb;
        debug("GB and GBC mode detected.", 0);
        break;
      case 0xC0:  //Only GBC mode
        this.cGBC = true;
        debug("Only GBC mode detected.", 0);
        break;
      default:
        this.cGBC = false;
        debug("Unknown GameBoy game type code #" + this.ROM[0x143] + ", defaulting to GB mode (Old games don't have a type code).", 1);
    }
    this.inBootstrap = false;
    this.setupRAM();  //CPU/(V)RAM initialization.
    this.initSkipBootstrap();
  }
  else {
    this.cGBC = this.usedGBCBootROM;  //Allow the GBC boot ROM to run in GBC mode...
    this.setupRAM();  //CPU/(V)RAM initialization.
    this.initBootstrap();
  }
  this.initializeModeSpecificArrays();
  //License Code Lookup:
  var cOldLicense = this.ROM[0x14B];
  var cNewLicense = (this.ROM[0x144] & 0xFF00) | (this.ROM[0x145] & 0xFF);
  if (cOldLicense != 0x33) {
    //Old Style License Header
    debug("Old style license code: " + cOldLicense, 0);
  }
  else {
    //New Style License Header
    debug("New style license code: " + cNewLicense, 0);
  }
  this.ROMImage = ""; //Memory consumption reduction.
};
GameBoyCore.prototype.disableBootROM = function () {
  //Remove any traces of the boot ROM from ROM memory.
  for (var index = 0; index < 0x100; ++index) {
    this.memory[index] = this.ROM[index]; //Replace the GameBoy or GameBoy Color boot ROM with the game ROM.
  }
  if (this.usedGBCBootROM) {
    //Remove any traces of the boot ROM from ROM memory.
    for (index = 0x200; index < 0x900; ++index) {
      this.memory[index] = this.ROM[index]; //Replace the GameBoy Color boot ROM with the game ROM.
    }
    if (!this.cGBC) {
      //Clean up the post-boot (GB mode only) state:
      this.GBCtoGBModeAdjust();
    }
    else {
      this.recompileBootIOWriteHandling();
    }
  }
  else {
    this.recompileBootIOWriteHandling();
  }
};
GameBoyCore.prototype.initializeTiming = function () {
  //Emulator Timing:
  this.clocksPerSecond = this.emulatorSpeed * 0x400000;
  this.baseCPUCyclesPerIteration = this.clocksPerSecond / 1000 * this.opts.interval;
  this.CPUCyclesTotalRoundoff = this.baseCPUCyclesPerIteration % 4;
  this.CPUCyclesTotalBase = this.CPUCyclesTotal = (this.baseCPUCyclesPerIteration - this.CPUCyclesTotalRoundoff) | 0;
  this.CPUCyclesTotalCurrent = 0;
};
GameBoyCore.prototype.setSpeed = function (speed) {
  this.emulatorSpeed = speed;
  this.initializeTiming();
  if (this.audioHandle) {
    this.initSound();
  }
};
GameBoyCore.prototype.setupRAM = function () {
  //Setup the auxilliary/switchable RAM:
  if (this.cMBC2) {
    this.numRAMBanks = 1 / 16;
  }
  else if (this.cMBC1 || this.cRUMBLE || this.cMBC3 || this.cHuC3) {
    this.numRAMBanks = 4;
  }
  else if (this.cMBC5) {
    this.numRAMBanks = 16;
  }
  else if (this.cSRAM) {
    this.numRAMBanks = 1;
  }
  if (this.numRAMBanks > 0) {
    if (!this.MBCRAMUtilized()) {
      //For ROM and unknown MBC cartridges using the external RAM:
      this.MBCRAMBanksEnabled = true;
    }
    //Switched RAM Used
    var MBCRam = (typeof this.openMBC == "function") ? this.openMBC(this.name) : [];
    if (MBCRam.length > 0) {
      //Flash the SRAM into memory:
      this.MBCRam = this.toTypedArray(MBCRam, "uint8");
    }
    else {
      this.MBCRam = this.getTypedArray(this.numRAMBanks * 0x2000, 0, "uint8");
    }
  }
  debug("Actual bytes of MBC RAM allocated: " + (this.numRAMBanks * 0x2000), 0);
  this.returnFromRTCState();
  //Setup the RAM for GBC mode.
  if (this.cGBC) {
    this.VRAM = this.getTypedArray(0x2000, 0, "uint8");
    this.GBCMemory = this.getTypedArray(0x7000, 0, "uint8");
  }
  this.memoryReadJumpCompile();
  this.memoryWriteJumpCompile();
};
GameBoyCore.prototype.MBCRAMUtilized = function () {
  return this.cMBC1 || this.cMBC2 || this.cMBC3 || this.cMBC5 || this.cMBC7 || this.cRUMBLE;
};
GameBoyCore.prototype.recomputeDimension = function () {
  //Cache some dimension info:
  this.onscreenWidth = this.canvas.width;
  this.onscreenHeight = this.canvas.height;
  if ('undefined' != typeof window && window.mozRequestAnimationFrame) {
    //Firefox slowness hack:
    this.canvas.width = this.onscreenWidth = 160;
    this.canvas.height = this.onscreenHeight = 144;
  }
  else {
    this.onscreenWidth = this.canvas.width;
    this.onscreenHeight = this.canvas.height;
  }
  this.offscreenWidth = 160;
  this.offscreenHeight = 144;
  this.offscreenRGBCount = this.offscreenWidth * this.offscreenHeight * 4;
};
GameBoyCore.prototype.initLCD = function () {
  this.recomputeDimension();
  this.resizer = null;
  if ('undefined' != typeof document && document.createElement) {
    this.canvasOffscreen = document.createElement("canvas");
    this.canvasOffscreen.width = this.offscreenWidth;
    this.canvasOffscreen.height = this.offscreenHeight;
  } else {
    // ugly hack to avoid different node-canvas versions
    var ctor = this.canvas.constructor;
    this.canvasOffscreen = new ctor(this.offscreenWidth, this.offscreenHeight);
  }

  this.drawContextOffscreen = this.canvasOffscreen.getContext("2d");
  this.drawContextOnscreen = this.canvas.getContext("2d");
  if (this.canvas.setAttribute) {
    this.canvas.setAttribute("style", (this.canvas.getAttribute("style") || "") + "; image-rendering: " + ((this.opts.imageSmoothing) ? "auto" : "-webkit-optimize-contrast") + ";" +
    "image-rendering: " + ((this.opts.imageSmoothing) ? "optimizeQuality" : "-o-crisp-edges") + ";" +
    "image-rendering: " + ((this.opts.imageSmoothing) ? "optimizeQuality" : "-moz-crisp-edges") + ";" +
    "-ms-interpolation-mode: " + ((this.opts.imageSmoothing) ? "bicubic" : "nearest-neighbor") + ";");
  }
  this.drawContextOffscreen.webkitImageSmoothingEnabled  = this.opts.imageSmoothing;
  this.drawContextOffscreen.mozImageSmoothingEnabled = this.opts.imageSmoothing;
  this.drawContextOnscreen.webkitImageSmoothingEnabled  = this.opts.imageSmoothing;
  this.drawContextOnscreen.mozImageSmoothingEnabled = this.opts.imageSmoothing;
  //Get a CanvasPixelArray buffer:
  try {
    this.canvasBuffer = this.drawContextOffscreen.createImageData(this.offscreenWidth, this.offscreenHeight);
  }
  catch (error) {
    debug("Falling back to the getImageData initialization (Error \"" + error.message + "\").", 1);
    this.canvasBuffer = this.drawContextOffscreen.getImageData(0, 0, this.offscreenWidth, this.offscreenHeight);
  }
  var index = this.offscreenRGBCount;
  while (index > 0) {
    this.canvasBuffer.data[index -= 4] = 0xF8;
    this.canvasBuffer.data[index + 1] = 0xF8;
    this.canvasBuffer.data[index + 2] = 0xF8;
    this.canvasBuffer.data[index + 3] = 0xFF;
  }
  this.graphicsBlit();
  if (this.canvas.style) {
    this.canvas.style.visibility = "visible";
  }
  if (this.swizzledFrame == null) {
    this.swizzledFrame = this.getTypedArray(69120, 0xFF, "uint8");
  }
  //Test the draw system and browser vblank latching:
  this.drewFrame = true;                    //Copy the latest graphics to buffer.
  this.requestDraw();
};
GameBoyCore.prototype.graphicsBlit = function () {
  if (this.offscreenWidth == this.onscreenWidth && this.offscreenHeight == this.onscreenHeight) {
    this.drawContextOnscreen.putImageData(this.canvasBuffer, 0, 0);
  }
  else {
    this.drawContextOffscreen.putImageData(this.canvasBuffer, 0, 0);
    this.drawContextOnscreen.drawImage(this.canvasOffscreen, 0, 0, this.onscreenWidth, this.onscreenHeight);
  }
};
GameBoyCore.prototype.JoyPadEvent = function (key, down) {
  if (down) {
    this.JoyPad &= 0xFF ^ (1 << key);
    if (!this.cGBC && (!this.usedBootROM || !this.usedGBCBootROM)) {
      this.interruptsRequested |= 0x10; //A real GBC doesn't set this!
      this.remainingClocks = 0;
      this.checkIRQMatching();
    }
  }
  else {
    this.JoyPad |= (1 << key);
  }
  this.memory[0xFF00] = (this.memory[0xFF00] & 0x30) + ((((this.memory[0xFF00] & 0x20) == 0) ? (this.JoyPad >> 4) : 0xF) & (((this.memory[0xFF00] & 0x10) == 0) ? (this.JoyPad & 0xF) : 0xF));
  this.CPUStopped = false;
};
GameBoyCore.prototype.GyroEvent = function (x, y) {
  x *= -100;
  x += 2047;
  this.highX = x >> 8;
  this.lowX = x & 0xFF;
  y *= -100;
  y += 2047;
  this.highY = y >> 8;
  this.lowY = y & 0xFF;
};
GameBoyCore.prototype.initSound = function () {
  this.audioResamplerFirstPassFactor = Math.max(Math.min(Math.floor(this.clocksPerSecond / 44100), Math.floor(0xFFFF / 0x1E0)), 1);
  this.downSampleInputDivider = 1 / (this.audioResamplerFirstPassFactor * 0xF0);
  if (this.opts.sound) {
    var self = this;
    this.audioHandle = new (this.opts.sound)(2, this.clocksPerSecond / this.audioResamplerFirstPassFactor, 0, Math.max(this.baseCPUCyclesPerIteration * this.opts.audioBufferMax / this.audioResamplerFirstPassFactor, 8192) << 1, null, this.opts.volume, function () {
      self.opts.sound = false;
    });
    this.initAudioBuffer();
  }
  else if (this.audioHandle) {
    //Mute the audio output, as it has an immediate silencing effect:
    this.audioHandle.changeVolume(0);
  }
};
GameBoyCore.prototype.changeVolume = function () {
  if (this.opts.sound && this.audioHandle) {
    this.audioHandle.changeVolume(this.opts.volume);
  }
};
GameBoyCore.prototype.initAudioBuffer = function () {
  this.audioIndex = 0;
  this.audioDestinationPosition = 0;
  this.downsampleInput = 0;
  this.bufferContainAmount = Math.max(this.baseCPUCyclesPerIteration * this.opts.audioBufferMin / this.audioResamplerFirstPassFactor, 4096) << 1;
  this.numSamplesTotal = (this.baseCPUCyclesPerIteration / this.audioResamplerFirstPassFactor) << 1;
  this.audioBuffer = this.getTypedArray(this.numSamplesTotal, 0, "float32");
};
GameBoyCore.prototype.intializeWhiteNoise = function () {
  //Noise Sample Tables:
  var randomFactor = 1;
  //15-bit LSFR Cache Generation:
  this.LSFR15Table = this.getTypedArray(0x80000, 0, "int8");
  var LSFR = 0x7FFF;  //Seed value has all its bits set.
  var LSFRShifted = 0x3FFF;
  for (var index = 0; index < 0x8000; ++index) {
    //Normalize the last LSFR value for usage:
    randomFactor = 1 - (LSFR & 1);  //Docs say it's the inverse.
    //Cache the different volume level results:
    this.LSFR15Table[0x08000 | index] = randomFactor;
    this.LSFR15Table[0x10000 | index] = randomFactor * 0x2;
    this.LSFR15Table[0x18000 | index] = randomFactor * 0x3;
    this.LSFR15Table[0x20000 | index] = randomFactor * 0x4;
    this.LSFR15Table[0x28000 | index] = randomFactor * 0x5;
    this.LSFR15Table[0x30000 | index] = randomFactor * 0x6;
    this.LSFR15Table[0x38000 | index] = randomFactor * 0x7;
    this.LSFR15Table[0x40000 | index] = randomFactor * 0x8;
    this.LSFR15Table[0x48000 | index] = randomFactor * 0x9;
    this.LSFR15Table[0x50000 | index] = randomFactor * 0xA;
    this.LSFR15Table[0x58000 | index] = randomFactor * 0xB;
    this.LSFR15Table[0x60000 | index] = randomFactor * 0xC;
    this.LSFR15Table[0x68000 | index] = randomFactor * 0xD;
    this.LSFR15Table[0x70000 | index] = randomFactor * 0xE;
    this.LSFR15Table[0x78000 | index] = randomFactor * 0xF;
    //Recompute the LSFR algorithm:
    LSFRShifted = LSFR >> 1;
    LSFR = LSFRShifted | (((LSFRShifted ^ LSFR) & 0x1) << 14);
  }
  //7-bit LSFR Cache Generation:
  this.LSFR7Table = this.getTypedArray(0x800, 0, "int8");
  LSFR = 0x7F;  //Seed value has all its bits set.
  for (index = 0; index < 0x80; ++index) {
    //Normalize the last LSFR value for usage:
    randomFactor = 1 - (LSFR & 1);  //Docs say it's the inverse.
    //Cache the different volume level results:
    this.LSFR7Table[0x080 | index] = randomFactor;
    this.LSFR7Table[0x100 | index] = randomFactor * 0x2;
    this.LSFR7Table[0x180 | index] = randomFactor * 0x3;
    this.LSFR7Table[0x200 | index] = randomFactor * 0x4;
    this.LSFR7Table[0x280 | index] = randomFactor * 0x5;
    this.LSFR7Table[0x300 | index] = randomFactor * 0x6;
    this.LSFR7Table[0x380 | index] = randomFactor * 0x7;
    this.LSFR7Table[0x400 | index] = randomFactor * 0x8;
    this.LSFR7Table[0x480 | index] = randomFactor * 0x9;
    this.LSFR7Table[0x500 | index] = randomFactor * 0xA;
    this.LSFR7Table[0x580 | index] = randomFactor * 0xB;
    this.LSFR7Table[0x600 | index] = randomFactor * 0xC;
    this.LSFR7Table[0x680 | index] = randomFactor * 0xD;
    this.LSFR7Table[0x700 | index] = randomFactor * 0xE;
    this.LSFR7Table[0x780 | index] = randomFactor * 0xF;
    //Recompute the LSFR algorithm:
    LSFRShifted = LSFR >> 1;
    LSFR = LSFRShifted | (((LSFRShifted ^ LSFR) & 0x1) << 6);
  }
  //Set the default noise table:
  this.noiseSampleTable = this.LSFR15Table;
};
GameBoyCore.prototype.audioUnderrunAdjustment = function () {
  if (this.opts.sound) {
    var underrunAmount = this.audioHandle.remainingBuffer();
    if (typeof underrunAmount == "number") {
      underrunAmount = this.bufferContainAmount - Math.max(underrunAmount, 0);
      if (underrunAmount > 0) {
        this.recalculateIterationClockLimitForAudio((underrunAmount >> 1) * this.audioResamplerFirstPassFactor);
      }
    }
  }
};
GameBoyCore.prototype.initializeAudioStartState = function () {
  this.channel1FrequencyTracker = 0x2000;
  this.channel1DutyTracker = 0;
  this.channel1CachedDuty = this.dutyLookup[2];
  this.channel1totalLength = 0;
  this.channel1envelopeVolume = 0;
  this.channel1envelopeType = false;
  this.channel1envelopeSweeps = 0;
  this.channel1envelopeSweepsLast = 0;
  this.channel1consecutive = true;
  this.channel1frequency = 0;
  this.channel1SweepFault = false;
  this.channel1ShadowFrequency = 0;
  this.channel1timeSweep = 1;
  this.channel1lastTimeSweep = 0;
  this.channel1Swept = false;
  this.channel1frequencySweepDivider = 0;
  this.channel1decreaseSweep = false;
  this.channel2FrequencyTracker = 0x2000;
  this.channel2DutyTracker = 0;
  this.channel2CachedDuty = this.dutyLookup[2];
  this.channel2totalLength = 0;
  this.channel2envelopeVolume = 0;
  this.channel2envelopeType = false;
  this.channel2envelopeSweeps = 0;
  this.channel2envelopeSweepsLast = 0;
  this.channel2consecutive = true;
  this.channel2frequency = 0;
  this.channel3canPlay = false;
  this.channel3totalLength = 0;
  this.channel3patternType = 4;
  this.channel3frequency = 0;
  this.channel3consecutive = true;
  this.channel3Counter = 0x800;
  this.channel4FrequencyPeriod = 8;
  this.channel4totalLength = 0;
  this.channel4envelopeVolume = 0;
  this.channel4currentVolume = 0;
  this.channel4envelopeType = false;
  this.channel4envelopeSweeps = 0;
  this.channel4envelopeSweepsLast = 0;
  this.channel4consecutive = true;
  this.channel4BitRange = 0x7FFF;
  this.noiseSampleTable = this.LSFR15Table;
  this.channel4VolumeShifter = 15;
  this.channel1FrequencyCounter = 0x2000;
  this.channel2FrequencyCounter = 0x2000;
  this.channel3Counter = 0x800;
  this.channel3FrequencyPeriod = 0x800;
  this.channel3lastSampleLookup = 0;
  this.channel4lastSampleLookup = 0;
  this.VinLeftChannelMasterVolume = 8;
  this.VinRightChannelMasterVolume = 8;
  this.mixerOutputCache = 0;
  this.sequencerClocks = 0x2000;
  this.sequencePosition = 0;
  this.channel4FrequencyPeriod = 8;
  this.channel4Counter = 8;
  this.cachedChannel3Sample = 0;
  this.cachedChannel4Sample = 0;
  this.channel1Enabled = false;
  this.channel2Enabled = false;
  this.channel3Enabled = false;
  this.channel4Enabled = false;
  this.channel1canPlay = false;
  this.channel2canPlay = false;
  this.channel4canPlay = false;
  this.audioClocksUntilNextEvent = 1;
  this.audioClocksUntilNextEventCounter = 1;
  this.channel1OutputLevelCache();
  this.channel2OutputLevelCache();
  this.channel3OutputLevelCache();
  this.channel4OutputLevelCache();
  this.noiseSampleTable = this.LSFR15Table;
};
GameBoyCore.prototype.outputAudio = function () {
  this.audioBuffer[this.audioDestinationPosition++] = (this.downsampleInput >>> 16) * this.downSampleInputDivider - 1;
  this.audioBuffer[this.audioDestinationPosition++] = (this.downsampleInput & 0xFFFF) * this.downSampleInputDivider - 1;
  if (this.audioDestinationPosition == this.numSamplesTotal) {
    this.audioHandle.writeAudioNoCallback(this.audioBuffer);
    this.audioDestinationPosition = 0;
  }
  this.downsampleInput = 0;
};
//Below are the audio generation functions timed against the CPU:
GameBoyCore.prototype.generateAudio = function (numSamples) {
  var multiplier = 0;
  if (this.soundMasterEnabled && !this.CPUStopped) {
    for (var clockUpTo = 0; numSamples > 0;) {
      clockUpTo = Math.min(this.audioClocksUntilNextEventCounter, this.sequencerClocks, numSamples);
      this.audioClocksUntilNextEventCounter -= clockUpTo;
      this.sequencerClocks -= clockUpTo;
      numSamples -= clockUpTo;
      while (clockUpTo > 0) {
        multiplier = Math.min(clockUpTo, this.audioResamplerFirstPassFactor - this.audioIndex);
        clockUpTo -= multiplier;
        this.audioIndex += multiplier;
        this.downsampleInput += this.mixerOutputCache * multiplier;
        if (this.audioIndex == this.audioResamplerFirstPassFactor) {
          this.audioIndex = 0;
          this.outputAudio();
        }
      }
      if (this.sequencerClocks == 0) {
        this.audioComputeSequencer();
        this.sequencerClocks = 0x2000;
      }
      if (this.audioClocksUntilNextEventCounter == 0) {
        this.computeAudioChannels();
      }
    }
  }
  else {
    //SILENT OUTPUT:
    while (numSamples > 0) {
      multiplier = Math.min(numSamples, this.audioResamplerFirstPassFactor - this.audioIndex);
      numSamples -= multiplier;
      this.audioIndex += multiplier;
      if (this.audioIndex == this.audioResamplerFirstPassFactor) {
        this.audioIndex = 0;
        this.outputAudio();
      }
    }
  }
};
//Generate audio, but don't actually output it (Used for when sound is disabled by user/browser):
GameBoyCore.prototype.generateAudioFake = function (numSamples) {
  if (this.soundMasterEnabled && !this.CPUStopped) {
    for (var clockUpTo = 0; numSamples > 0;) {
      clockUpTo = Math.min(this.audioClocksUntilNextEventCounter, this.sequencerClocks, numSamples);
      this.audioClocksUntilNextEventCounter -= clockUpTo;
      this.sequencerClocks -= clockUpTo;
      numSamples -= clockUpTo;
      if (this.sequencerClocks == 0) {
        this.audioComputeSequencer();
        this.sequencerClocks = 0x2000;
      }
      if (this.audioClocksUntilNextEventCounter == 0) {
        this.computeAudioChannels();
      }
    }
  }
};
GameBoyCore.prototype.audioJIT = function () {
  //Audio Sample Generation Timing:
  if (this.opts.sound) {
    this.generateAudio(this.audioTicks);
  }
  else {
    this.generateAudioFake(this.audioTicks);
  }
  this.audioTicks = 0;
};
GameBoyCore.prototype.audioComputeSequencer = function () {
  switch (this.sequencePosition++) {
    case 0:
      this.clockAudioLength();
      break;
    case 2:
      this.clockAudioLength();
      this.clockAudioSweep();
      break;
    case 4:
      this.clockAudioLength();
      break;
    case 6:
      this.clockAudioLength();
      this.clockAudioSweep();
      break;
    case 7:
      this.clockAudioEnvelope();
      this.sequencePosition = 0;
  }
};
GameBoyCore.prototype.clockAudioLength = function () {
  //Channel 1:
  if (this.channel1totalLength > 1) {
    --this.channel1totalLength;
  }
  else if (this.channel1totalLength == 1) {
    this.channel1totalLength = 0;
    this.channel1EnableCheck();
    this.memory[0xFF26] &= 0xFE;  //Channel #1 On Flag Off
  }
  //Channel 2:
  if (this.channel2totalLength > 1) {
    --this.channel2totalLength;
  }
  else if (this.channel2totalLength == 1) {
    this.channel2totalLength = 0;
    this.channel2EnableCheck();
    this.memory[0xFF26] &= 0xFD;  //Channel #2 On Flag Off
  }
  //Channel 3:
  if (this.channel3totalLength > 1) {
    --this.channel3totalLength;
  }
  else if (this.channel3totalLength == 1) {
    this.channel3totalLength = 0;
    this.channel3EnableCheck();
    this.memory[0xFF26] &= 0xFB;  //Channel #3 On Flag Off
  }
  //Channel 4:
  if (this.channel4totalLength > 1) {
    --this.channel4totalLength;
  }
  else if (this.channel4totalLength == 1) {
    this.channel4totalLength = 0;
    this.channel4EnableCheck();
    this.memory[0xFF26] &= 0xF7;  //Channel #4 On Flag Off
  }
};
GameBoyCore.prototype.clockAudioSweep = function () {
  //Channel 1:
  if (!this.channel1SweepFault && this.channel1timeSweep > 0) {
    if (--this.channel1timeSweep == 0) {
      this.runAudioSweep();
    }
  }
};
GameBoyCore.prototype.runAudioSweep = function () {
  //Channel 1:
  if (this.channel1lastTimeSweep > 0) {
    if (this.channel1frequencySweepDivider > 0) {
      this.channel1Swept = true;
      if (this.channel1decreaseSweep) {
        this.channel1ShadowFrequency -= this.channel1ShadowFrequency >> this.channel1frequencySweepDivider;
        this.channel1frequency = this.channel1ShadowFrequency & 0x7FF;
        this.channel1FrequencyTracker = (0x800 - this.channel1frequency) << 2;
      }
      else {
        this.channel1ShadowFrequency += this.channel1ShadowFrequency >> this.channel1frequencySweepDivider;
        this.channel1frequency = this.channel1ShadowFrequency;
        if (this.channel1ShadowFrequency <= 0x7FF) {
          this.channel1FrequencyTracker = (0x800 - this.channel1frequency) << 2;
          //Run overflow check twice:
          if ((this.channel1ShadowFrequency + (this.channel1ShadowFrequency >> this.channel1frequencySweepDivider)) > 0x7FF) {
            this.channel1SweepFault = true;
            this.channel1EnableCheck();
            this.memory[0xFF26] &= 0xFE;  //Channel #1 On Flag Off
          }
        }
        else {
          this.channel1frequency &= 0x7FF;
          this.channel1SweepFault = true;
          this.channel1EnableCheck();
          this.memory[0xFF26] &= 0xFE;  //Channel #1 On Flag Off
        }
      }
      this.channel1timeSweep = this.channel1lastTimeSweep;
    }
    else {
      //Channel has sweep disabled and timer becomes a length counter:
      this.channel1SweepFault = true;
      this.channel1EnableCheck();
    }
  }
};
GameBoyCore.prototype.channel1AudioSweepPerformDummy = function () {
  //Channel 1:
  if (this.channel1frequencySweepDivider > 0) {
    if (!this.channel1decreaseSweep) {
      var channel1ShadowFrequency = this.channel1ShadowFrequency + (this.channel1ShadowFrequency >> this.channel1frequencySweepDivider);
      if (channel1ShadowFrequency <= 0x7FF) {
        //Run overflow check twice:
        if ((channel1ShadowFrequency + (channel1ShadowFrequency >> this.channel1frequencySweepDivider)) > 0x7FF) {
          this.channel1SweepFault = true;
          this.channel1EnableCheck();
          this.memory[0xFF26] &= 0xFE;  //Channel #1 On Flag Off
        }
      }
      else {
        this.channel1SweepFault = true;
        this.channel1EnableCheck();
        this.memory[0xFF26] &= 0xFE;  //Channel #1 On Flag Off
      }
    }
  }
};
GameBoyCore.prototype.clockAudioEnvelope = function () {
  //Channel 1:
  if (this.channel1envelopeSweepsLast > -1) {
    if (this.channel1envelopeSweeps > 0) {
      --this.channel1envelopeSweeps;
    }
    else {
      if (!this.channel1envelopeType) {
        if (this.channel1envelopeVolume > 0) {
          --this.channel1envelopeVolume;
          this.channel1envelopeSweeps = this.channel1envelopeSweepsLast;
          this.channel1OutputLevelCache();
        }
        else {
          this.channel1envelopeSweepsLast = -1;
        }
      }
      else if (this.channel1envelopeVolume < 0xF) {
        ++this.channel1envelopeVolume;
        this.channel1envelopeSweeps = this.channel1envelopeSweepsLast;
        this.channel1OutputLevelCache();
      }
      else {
        this.channel1envelopeSweepsLast = -1;
      }
    }
  }
  //Channel 2:
  if (this.channel2envelopeSweepsLast > -1) {
    if (this.channel2envelopeSweeps > 0) {
      --this.channel2envelopeSweeps;
    }
    else {
      if (!this.channel2envelopeType) {
        if (this.channel2envelopeVolume > 0) {
          --this.channel2envelopeVolume;
          this.channel2envelopeSweeps = this.channel2envelopeSweepsLast;
          this.channel2OutputLevelCache();
        }
        else {
          this.channel2envelopeSweepsLast = -1;
        }
      }
      else if (this.channel2envelopeVolume < 0xF) {
        ++this.channel2envelopeVolume;
        this.channel2envelopeSweeps = this.channel2envelopeSweepsLast;
        this.channel2OutputLevelCache();
      }
      else {
        this.channel2envelopeSweepsLast = -1;
      }
    }
  }
  //Channel 4:
  if (this.channel4envelopeSweepsLast > -1) {
    if (this.channel4envelopeSweeps > 0) {
      --this.channel4envelopeSweeps;
    }
    else {
      if (!this.channel4envelopeType) {
        if (this.channel4envelopeVolume > 0) {
          this.channel4currentVolume = --this.channel4envelopeVolume << this.channel4VolumeShifter;
          this.channel4envelopeSweeps = this.channel4envelopeSweepsLast;
          this.channel4UpdateCache();
        }
        else {
          this.channel4envelopeSweepsLast = -1;
        }
      }
      else if (this.channel4envelopeVolume < 0xF) {
        this.channel4currentVolume = ++this.channel4envelopeVolume << this.channel4VolumeShifter;
        this.channel4envelopeSweeps = this.channel4envelopeSweepsLast;
        this.channel4UpdateCache();
      }
      else {
        this.channel4envelopeSweepsLast = -1;
      }
    }
  }
};
GameBoyCore.prototype.computeAudioChannels = function () {
  //Clock down the four audio channels to the next closest audio event:
  this.channel1FrequencyCounter -= this.audioClocksUntilNextEvent;
  this.channel2FrequencyCounter -= this.audioClocksUntilNextEvent;
  this.channel3Counter -= this.audioClocksUntilNextEvent;
  this.channel4Counter -= this.audioClocksUntilNextEvent;
  //Channel 1 counter:
  if (this.channel1FrequencyCounter == 0) {
    this.channel1FrequencyCounter = this.channel1FrequencyTracker;
    this.channel1DutyTracker = (this.channel1DutyTracker + 1) & 0x7;
    this.channel1OutputLevelTrimaryCache();
  }
  //Channel 2 counter:
  if (this.channel2FrequencyCounter == 0) {
    this.channel2FrequencyCounter = this.channel2FrequencyTracker;
    this.channel2DutyTracker = (this.channel2DutyTracker + 1) & 0x7;
    this.channel2OutputLevelTrimaryCache();
  }
  //Channel 3 counter:
  if (this.channel3Counter == 0) {
    if (this.channel3canPlay) {
      this.channel3lastSampleLookup = (this.channel3lastSampleLookup + 1) & 0x1F;
    }
    this.channel3Counter = this.channel3FrequencyPeriod;
    this.channel3UpdateCache();
  }
  //Channel 4 counter:
  if (this.channel4Counter == 0) {
    this.channel4lastSampleLookup = (this.channel4lastSampleLookup + 1) & this.channel4BitRange;
    this.channel4Counter = this.channel4FrequencyPeriod;
    this.channel4UpdateCache();
  }
  //Find the number of clocks to next closest counter event:
  this.audioClocksUntilNextEventCounter = this.audioClocksUntilNextEvent = Math.min(this.channel1FrequencyCounter, this.channel2FrequencyCounter, this.channel3Counter, this.channel4Counter);
};
GameBoyCore.prototype.channel1EnableCheck = function () {
  this.channel1Enabled = ((this.channel1consecutive || this.channel1totalLength > 0) && !this.channel1SweepFault && this.channel1canPlay);
  this.channel1OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel1VolumeEnableCheck = function () {
  this.channel1canPlay = (this.memory[0xFF12] > 7);
  this.channel1EnableCheck();
  this.channel1OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel1OutputLevelCache = function () {
  this.channel1currentSampleLeft = (this.leftChannel1) ? this.channel1envelopeVolume : 0;
  this.channel1currentSampleRight = (this.rightChannel1) ? this.channel1envelopeVolume : 0;
  this.channel1OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel1OutputLevelSecondaryCache = function () {
  if (this.channel1Enabled) {
    this.channel1currentSampleLeftSecondary = this.channel1currentSampleLeft;
    this.channel1currentSampleRightSecondary = this.channel1currentSampleRight;
  }
  else {
    this.channel1currentSampleLeftSecondary = 0;
    this.channel1currentSampleRightSecondary = 0;
  }
  this.channel1OutputLevelTrimaryCache();
};
GameBoyCore.prototype.channel1OutputLevelTrimaryCache = function () {
  if (this.channel1CachedDuty[this.channel1DutyTracker] && this.opts.channels[0]) {
    this.channel1currentSampleLeftTrimary = this.channel1currentSampleLeftSecondary;
    this.channel1currentSampleRightTrimary = this.channel1currentSampleRightSecondary;
  }
  else {
    this.channel1currentSampleLeftTrimary = 0;
    this.channel1currentSampleRightTrimary = 0;
  }
  this.mixerOutputLevelCache();
};
GameBoyCore.prototype.channel2EnableCheck = function () {
  this.channel2Enabled = ((this.channel2consecutive || this.channel2totalLength > 0) && this.channel2canPlay);
  this.channel2OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel2VolumeEnableCheck = function () {
  this.channel2canPlay = (this.memory[0xFF17] > 7);
  this.channel2EnableCheck();
  this.channel2OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel2OutputLevelCache = function () {
  this.channel2currentSampleLeft = (this.leftChannel2) ? this.channel2envelopeVolume : 0;
  this.channel2currentSampleRight = (this.rightChannel2) ? this.channel2envelopeVolume : 0;
  this.channel2OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel2OutputLevelSecondaryCache = function () {
  if (this.channel2Enabled) {
    this.channel2currentSampleLeftSecondary = this.channel2currentSampleLeft;
    this.channel2currentSampleRightSecondary = this.channel2currentSampleRight;
  }
  else {
    this.channel2currentSampleLeftSecondary = 0;
    this.channel2currentSampleRightSecondary = 0;
  }
  this.channel2OutputLevelTrimaryCache();
};
GameBoyCore.prototype.channel2OutputLevelTrimaryCache = function () {
  if (this.channel2CachedDuty[this.channel2DutyTracker] && this.opts.channels[1]) {
    this.channel2currentSampleLeftTrimary = this.channel2currentSampleLeftSecondary;
    this.channel2currentSampleRightTrimary = this.channel2currentSampleRightSecondary;
  }
  else {
    this.channel2currentSampleLeftTrimary = 0;
    this.channel2currentSampleRightTrimary = 0;
  }
  this.mixerOutputLevelCache();
};
GameBoyCore.prototype.channel3EnableCheck = function () {
  this.channel3Enabled = (/*this.channel3canPlay && */(this.channel3consecutive || this.channel3totalLength > 0));
  this.channel3OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel3OutputLevelCache = function () {
  this.channel3currentSampleLeft = (this.leftChannel3) ? this.cachedChannel3Sample : 0;
  this.channel3currentSampleRight = (this.rightChannel3) ? this.cachedChannel3Sample : 0;
  this.channel3OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel3OutputLevelSecondaryCache = function () {
  if (this.channel3Enabled && this.opts.channels[2]) {
    this.channel3currentSampleLeftSecondary = this.channel3currentSampleLeft;
    this.channel3currentSampleRightSecondary = this.channel3currentSampleRight;
  }
  else {
    this.channel3currentSampleLeftSecondary = 0;
    this.channel3currentSampleRightSecondary = 0;
  }
  this.mixerOutputLevelCache();
};
GameBoyCore.prototype.channel4EnableCheck = function () {
  this.channel4Enabled = ((this.channel4consecutive || this.channel4totalLength > 0) && this.channel4canPlay);
  this.channel4OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel4VolumeEnableCheck = function () {
  this.channel4canPlay = (this.memory[0xFF21] > 7);
  this.channel4EnableCheck();
  this.channel4OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel4OutputLevelCache = function () {
  this.channel4currentSampleLeft = (this.leftChannel4) ? this.cachedChannel4Sample : 0;
  this.channel4currentSampleRight = (this.rightChannel4) ? this.cachedChannel4Sample : 0;
  this.channel4OutputLevelSecondaryCache();
};
GameBoyCore.prototype.channel4OutputLevelSecondaryCache = function () {
  if (this.channel4Enabled && this.opts.channels[3]) {
    this.channel4currentSampleLeftSecondary = this.channel4currentSampleLeft;
    this.channel4currentSampleRightSecondary = this.channel4currentSampleRight;
  }
  else {
    this.channel4currentSampleLeftSecondary = 0;
    this.channel4currentSampleRightSecondary = 0;
  }
  this.mixerOutputLevelCache();
};
GameBoyCore.prototype.mixerOutputLevelCache = function () {
  this.mixerOutputCache = ((((this.channel1currentSampleLeftTrimary + this.channel2currentSampleLeftTrimary + this.channel3currentSampleLeftSecondary + this.channel4currentSampleLeftSecondary) * this.VinLeftChannelMasterVolume) << 16) |
  ((this.channel1currentSampleRightTrimary + this.channel2currentSampleRightTrimary + this.channel3currentSampleRightSecondary + this.channel4currentSampleRightSecondary) * this.VinRightChannelMasterVolume));
};
GameBoyCore.prototype.channel3UpdateCache = function () {
  this.cachedChannel3Sample = this.channel3PCM[this.channel3lastSampleLookup] >> this.channel3patternType;
  this.channel3OutputLevelCache();
};
GameBoyCore.prototype.channel3WriteRAM = function (address, data) {
  if (this.channel3canPlay) {
    this.audioJIT();
    //address = this.channel3lastSampleLookup >> 1;
  }
  this.memory[0xFF30 | address] = data;
  address <<= 1;
  this.channel3PCM[address] = data >> 4;
  this.channel3PCM[address | 1] = data & 0xF;
};
GameBoyCore.prototype.channel4UpdateCache = function () {
  this.cachedChannel4Sample = this.noiseSampleTable[this.channel4currentVolume | this.channel4lastSampleLookup];
  this.channel4OutputLevelCache();
};
GameBoyCore.prototype.run = function () {
  //The preprocessing before the actual iteration loop:
  if ((this.stopEmulator & 2) == 0) {
    if ((this.stopEmulator & 1) == 1) {
      if (!this.CPUStopped) {
        this.stopEmulator = 0;
        this.audioUnderrunAdjustment();
        this.clockUpdate();     //RTC clocking.
        if (!this.halt) {
          this.executeIteration();
        }
        else {            //Finish the HALT rundown execution.
          this.CPUTicks = 0;
          this.calculateHALTPeriod();
          if (this.halt) {
            this.updateCore();
            this.iterationEndRoutine();
          }
          else {
            this.executeIteration();
          }
        }
        //Request the graphics target to be updated:
        this.requestDraw();
      }
      else {
        this.audioUnderrunAdjustment();
        this.audioTicks += this.CPUCyclesTotal;
        this.audioJIT();
        this.stopEmulator |= 1;     //End current loop.
      }
    }
    else {    //We can only get here if there was an internal error, but the loop was restarted.
      this.emit('error', new Error("Iterator restarted a faulted core."));
    }
  }
};
GameBoyCore.prototype.executeIteration = function () {
  //Iterate the interpreter loop:
  var opcodeToExecute = 0;
  var timedTicks = 0;
  while (this.stopEmulator == 0) {
    //Interrupt Arming:
    switch (this.IRQEnableDelay) {
      case 1:
        this.IME = true;
        this.checkIRQMatching();
      case 2:
        --this.IRQEnableDelay;
    }
    //Is an IRQ set to fire?:
    if (this.IRQLineMatched > 0) {
      //IME is true and and interrupt was matched:
      this.launchIRQ();
    }
    //Fetch the current opcode:
    opcodeToExecute = this.memoryReader[this.programCounter](this, this.programCounter);
    //Increment the program counter to the next instruction:
    this.programCounter = (this.programCounter + 1) & 0xFFFF;
    //Check for the program counter quirk:
    if (this.skipPCIncrement) {
      this.programCounter = (this.programCounter - 1) & 0xFFFF;
      this.skipPCIncrement = false;
    }
    //Get how many CPU cycles the current instruction counts for:
    this.CPUTicks = this.TICKTable[opcodeToExecute];
    //Execute the current instruction:
    this.OPCODE[opcodeToExecute](this);
    //Update the state (Inlined updateCoreFull manually here):
    //Update the clocking for the LCD emulation:
    this.LCDTicks += this.CPUTicks >> this.doubleSpeedShifter;  //LCD Timing
    this.LCDCONTROL[this.actualScanLine](this);         //Scan Line and STAT Mode Control
    //Single-speed relative timing for A/V emulation:
    timedTicks = this.CPUTicks >> this.doubleSpeedShifter;    //CPU clocking can be updated from the LCD handling.
    this.audioTicks += timedTicks;                //Audio Timing
    this.emulatorTicks += timedTicks;             //Emulator Timing
    //CPU Timers:
    this.DIVTicks += this.CPUTicks;               //DIV Timing
    if (this.TIMAEnabled) {                   //TIMA Timing
      this.timerTicks += this.CPUTicks;
      while (this.timerTicks >= this.TACClocker) {
        this.timerTicks -= this.TACClocker;
        if (++this.memory[0xFF05] == 0x100) {
          this.memory[0xFF05] = this.memory[0xFF06];
          this.interruptsRequested |= 0x4;
          this.checkIRQMatching();
        }
      }
    }
    if (this.serialTimer > 0) {                   //Serial Timing
      //IRQ Counter:
      this.serialTimer -= this.CPUTicks;
      if (this.serialTimer <= 0) {
        this.interruptsRequested |= 0x8;
        this.checkIRQMatching();
      }
      //Bit Shit Counter:
      this.serialShiftTimer -= this.CPUTicks;
      if (this.serialShiftTimer <= 0) {
        this.serialShiftTimer = this.serialShiftTimerAllocated;
        this.memory[0xFF01] = ((this.memory[0xFF01] << 1) & 0xFE) | 0x01; //We could shift in actual link data here if we were to implement such!!!
      }
    }
    //End of iteration routine:
    if (this.emulatorTicks >= this.CPUCyclesTotal) {
      this.iterationEndRoutine();
    }
  }
};
GameBoyCore.prototype.iterationEndRoutine = function () {
  if ((this.stopEmulator & 0x1) == 0) {
    this.audioJIT();  //Make sure we at least output once per iteration.
    //Update DIV Alignment (Integer overflow safety):
    this.memory[0xFF04] = (this.memory[0xFF04] + (this.DIVTicks >> 8)) & 0xFF;
    this.DIVTicks &= 0xFF;
    //Update emulator flags:
    this.stopEmulator |= 1;     //End current loop.
    this.emulatorTicks -= this.CPUCyclesTotal;
    this.CPUCyclesTotalCurrent += this.CPUCyclesTotalRoundoff;
    this.recalculateIterationClockLimit();
  }
};
GameBoyCore.prototype.handleSTOP = function () {
  this.CPUStopped = true;           //Stop CPU until joypad input changes.
  this.iterationEndRoutine();
  if (this.emulatorTicks < 0) {
    this.audioTicks -= this.emulatorTicks;
    this.audioJIT();
  }
};
GameBoyCore.prototype.recalculateIterationClockLimit = function () {
  var endModulus = this.CPUCyclesTotalCurrent % 4;
  this.CPUCyclesTotal = this.CPUCyclesTotalBase + this.CPUCyclesTotalCurrent - endModulus;
  this.CPUCyclesTotalCurrent = endModulus;
};
GameBoyCore.prototype.recalculateIterationClockLimitForAudio = function (audioClocking) {
  this.CPUCyclesTotal += Math.min((audioClocking >> 2) << 2, this.CPUCyclesTotalBase << 1);
};
GameBoyCore.prototype.scanLineMode2 = function () { //OAM Search Period
  if (this.STATTracker != 1) {
    if (this.mode2TriggerSTAT) {
      this.interruptsRequested |= 0x2;
      this.checkIRQMatching();
    }
    this.STATTracker = 1;
    this.modeSTAT = 2;
  }
};
GameBoyCore.prototype.scanLineMode3 = function () { //Scan Line Drawing Period
  if (this.modeSTAT != 3) {
    if (this.STATTracker == 0 && this.mode2TriggerSTAT) {
      this.interruptsRequested |= 0x2;
      this.checkIRQMatching();
    }
    this.STATTracker = 1;
    this.modeSTAT = 3;
  }
};
GameBoyCore.prototype.scanLineMode0 = function () { //Horizontal Blanking Period
  if (this.modeSTAT != 0) {
    if (this.STATTracker != 2) {
      if (this.STATTracker == 0) {
        if (this.mode2TriggerSTAT) {
          this.interruptsRequested |= 0x2;
          this.checkIRQMatching();
        }
        this.modeSTAT = 3;
      }
      this.incrementScanLineQueue();
      this.updateSpriteCount(this.actualScanLine);
      this.STATTracker = 2;
    }
    if (this.LCDTicks >= this.spriteCount) {
      if (this.hdmaRunning) {
        this.executeHDMA();
      }
      if (this.mode0TriggerSTAT) {
        this.interruptsRequested |= 0x2;
        this.checkIRQMatching();
      }
      this.STATTracker = 3;
      this.modeSTAT = 0;
    }
  }
};
GameBoyCore.prototype.clocksUntilLYCMatch = function () {
  if (this.memory[0xFF45] != 0) {
    if (this.memory[0xFF45] > this.actualScanLine) {
      return 456 * (this.memory[0xFF45] - this.actualScanLine);
    }
    return 456 * (154 - this.actualScanLine + this.memory[0xFF45]);
  }
  return (456 * ((this.actualScanLine == 153 && this.memory[0xFF44] == 0) ? 154 : (153 - this.actualScanLine))) + 8;
};
GameBoyCore.prototype.clocksUntilMode0 = function () {
  switch (this.modeSTAT) {
    case 0:
      if (this.actualScanLine == 143) {
        this.updateSpriteCount(0);
        return this.spriteCount + 5016;
      }
      this.updateSpriteCount(this.actualScanLine + 1);
      return this.spriteCount + 456;
    case 2:
    case 3:
      this.updateSpriteCount(this.actualScanLine);
      return this.spriteCount;
    case 1:
      this.updateSpriteCount(0);
      return this.spriteCount + (456 * (154 - this.actualScanLine));
  }
};
GameBoyCore.prototype.updateSpriteCount = function (line) {
  this.spriteCount = 252;
  if (this.cGBC && this.gfxSpriteShow) {                    //Is the window enabled and are we in CGB mode?
    var lineAdjusted = line + 0x10;
    var yoffset = 0;
    var yCap = (this.gfxSpriteNormalHeight) ? 0x8 : 0x10;
    for (var OAMAddress = 0xFE00; OAMAddress < 0xFEA0 && this.spriteCount < 312; OAMAddress += 4) {
      yoffset = lineAdjusted - this.memory[OAMAddress];
      if (yoffset > -1 && yoffset < yCap) {
        this.spriteCount += 6;
      }
    }
  }
};
GameBoyCore.prototype.matchLYC = function () {  //LYC Register Compare
  if (this.memory[0xFF44] == this.memory[0xFF45]) {
    this.memory[0xFF41] |= 0x04;
    if (this.LYCMatchTriggerSTAT) {
      this.interruptsRequested |= 0x2;
      this.checkIRQMatching();
    }
  }
  else {
    this.memory[0xFF41] &= 0x7B;
  }
};
GameBoyCore.prototype.updateCore = function () {
  //Update the clocking for the LCD emulation:
  this.LCDTicks += this.CPUTicks >> this.doubleSpeedShifter;  //LCD Timing
  this.LCDCONTROL[this.actualScanLine](this);         //Scan Line and STAT Mode Control
  //Single-speed relative timing for A/V emulation:
  var timedTicks = this.CPUTicks >> this.doubleSpeedShifter;  //CPU clocking can be updated from the LCD handling.
  this.audioTicks += timedTicks;                //Audio Timing
  this.emulatorTicks += timedTicks;             //Emulator Timing
  //CPU Timers:
  this.DIVTicks += this.CPUTicks;               //DIV Timing
  if (this.TIMAEnabled) {                   //TIMA Timing
    this.timerTicks += this.CPUTicks;
    while (this.timerTicks >= this.TACClocker) {
      this.timerTicks -= this.TACClocker;
      if (++this.memory[0xFF05] == 0x100) {
        this.memory[0xFF05] = this.memory[0xFF06];
        this.interruptsRequested |= 0x4;
        this.checkIRQMatching();
      }
    }
  }
  if (this.serialTimer > 0) {                   //Serial Timing
    //IRQ Counter:
    this.serialTimer -= this.CPUTicks;
    if (this.serialTimer <= 0) {
      this.interruptsRequested |= 0x8;
      this.checkIRQMatching();
    }
    //Bit Shit Counter:
    this.serialShiftTimer -= this.CPUTicks;
    if (this.serialShiftTimer <= 0) {
      this.serialShiftTimer = this.serialShiftTimerAllocated;
      this.memory[0xFF01] = ((this.memory[0xFF01] << 1) & 0xFE) | 0x01; //We could shift in actual link data here if we were to implement such!!!
    }
  }
};
GameBoyCore.prototype.updateCoreFull = function () {
  //Update the state machine:
  this.updateCore();
  //End of iteration routine:
  if (this.emulatorTicks >= this.CPUCyclesTotal) {
    this.iterationEndRoutine();
  }
};
GameBoyCore.prototype.initializeLCDController = function () {
  //Display on hanlding:
  var line = 0;
  while (line < 154) {
    if (line < 143) {
      //We're on a normal scan line:
      this.LINECONTROL[line] = function (parentObj) {
        if (parentObj.LCDTicks < 80) {
          parentObj.scanLineMode2();
        }
        else if (parentObj.LCDTicks < 252) {
          parentObj.scanLineMode3();
        }
        else if (parentObj.LCDTicks < 456) {
          parentObj.scanLineMode0();
        }
        else {
          //We're on a new scan line:
          parentObj.LCDTicks -= 456;
          if (parentObj.STATTracker != 3) {
            //Make sure the mode 0 handler was run at least once per scan line:
            if (parentObj.STATTracker != 2) {
              if (parentObj.STATTracker == 0 && parentObj.mode2TriggerSTAT) {
                parentObj.interruptsRequested |= 0x2;
              }
              parentObj.incrementScanLineQueue();
            }
            if (parentObj.hdmaRunning) {
              parentObj.executeHDMA();
            }
            if (parentObj.mode0TriggerSTAT) {
              parentObj.interruptsRequested |= 0x2;
            }
          }
          //Update the scanline registers and assert the LYC counter:
          parentObj.actualScanLine = ++parentObj.memory[0xFF44];
          //Perform a LYC counter assert:
          if (parentObj.actualScanLine == parentObj.memory[0xFF45]) {
            parentObj.memory[0xFF41] |= 0x04;
            if (parentObj.LYCMatchTriggerSTAT) {
              parentObj.interruptsRequested |= 0x2;
            }
          }
          else {
            parentObj.memory[0xFF41] &= 0x7B;
          }
          parentObj.checkIRQMatching();
          //Reset our mode contingency variables:
          parentObj.STATTracker = 0;
          parentObj.modeSTAT = 2;
          parentObj.LINECONTROL[parentObj.actualScanLine](parentObj); //Scan Line and STAT Mode Control.
        }
      };
    }
    else if (line == 143) {
      //We're on the last visible scan line of the LCD screen:
      this.LINECONTROL[143] = function (parentObj) {
        if (parentObj.LCDTicks < 80) {
          parentObj.scanLineMode2();
        }
        else if (parentObj.LCDTicks < 252) {
          parentObj.scanLineMode3();
        }
        else if (parentObj.LCDTicks < 456) {
          parentObj.scanLineMode0();
        }
        else {
          //Starting V-Blank:
          //Just finished the last visible scan line:
          parentObj.LCDTicks -= 456;
          if (parentObj.STATTracker != 3) {
            //Make sure the mode 0 handler was run at least once per scan line:
            if (parentObj.STATTracker != 2) {
              if (parentObj.STATTracker == 0 && parentObj.mode2TriggerSTAT) {
                parentObj.interruptsRequested |= 0x2;
              }
              parentObj.incrementScanLineQueue();
            }
            if (parentObj.hdmaRunning) {
              parentObj.executeHDMA();
            }
            if (parentObj.mode0TriggerSTAT) {
              parentObj.interruptsRequested |= 0x2;
            }
          }
          //Update the scanline registers and assert the LYC counter:
          parentObj.actualScanLine = parentObj.memory[0xFF44] = 144;
          //Perform a LYC counter assert:
          if (parentObj.memory[0xFF45] == 144) {
            parentObj.memory[0xFF41] |= 0x04;
            if (parentObj.LYCMatchTriggerSTAT) {
              parentObj.interruptsRequested |= 0x2;
            }
          }
          else {
            parentObj.memory[0xFF41] &= 0x7B;
          }
          //Reset our mode contingency variables:
          parentObj.STATTracker = 0;
          //Update our state for v-blank:
          parentObj.modeSTAT = 1;
          parentObj.interruptsRequested |= (parentObj.mode1TriggerSTAT) ? 0x3 : 0x1;
          parentObj.checkIRQMatching();
          //Attempt to blit out to our canvas:
          if (parentObj.drewBlank == 0) {
            //Ensure JIT framing alignment:
            if (parentObj.totalLinesPassed < 144 || (parentObj.totalLinesPassed == 144 && parentObj.midScanlineOffset > -1)) {
              //Make sure our gfx are up-to-date:
              parentObj.graphicsJITVBlank();
              //Draw the frame:
              parentObj.prepareFrame();
            }
          }
          else {
            //LCD off takes at least 2 frames:
            --parentObj.drewBlank;
          }
          parentObj.LINECONTROL[144](parentObj);  //Scan Line and STAT Mode Control.
        }
      };
    }
    else if (line < 153) {
      //In VBlank
      this.LINECONTROL[line] = function (parentObj) {
        if (parentObj.LCDTicks >= 456) {
          //We're on a new scan line:
          parentObj.LCDTicks -= 456;
          parentObj.actualScanLine = ++parentObj.memory[0xFF44];
          //Perform a LYC counter assert:
          if (parentObj.actualScanLine == parentObj.memory[0xFF45]) {
            parentObj.memory[0xFF41] |= 0x04;
            if (parentObj.LYCMatchTriggerSTAT) {
              parentObj.interruptsRequested |= 0x2;
              parentObj.checkIRQMatching();
            }
          }
          else {
            parentObj.memory[0xFF41] &= 0x7B;
          }
          parentObj.LINECONTROL[parentObj.actualScanLine](parentObj); //Scan Line and STAT Mode Control.
        }
      };
    }
    else {
      //VBlank Ending (We're on the last actual scan line)
      this.LINECONTROL[153] = function (parentObj) {
        if (parentObj.LCDTicks >= 8) {
          if (parentObj.STATTracker != 4 && parentObj.memory[0xFF44] == 153) {
            parentObj.memory[0xFF44] = 0; //LY register resets to 0 early.
            //Perform a LYC counter assert:
            if (parentObj.memory[0xFF45] == 0) {
              parentObj.memory[0xFF41] |= 0x04;
              if (parentObj.LYCMatchTriggerSTAT) {
                parentObj.interruptsRequested |= 0x2;
                parentObj.checkIRQMatching();
              }
            }
            else {
              parentObj.memory[0xFF41] &= 0x7B;
            }
            parentObj.STATTracker = 4;
          }
          if (parentObj.LCDTicks >= 456) {
            //We reset back to the beginning:
            parentObj.LCDTicks -= 456;
            parentObj.STATTracker = parentObj.actualScanLine = 0;
            parentObj.LINECONTROL[0](parentObj);  //Scan Line and STAT Mode Control.
          }
        }
      };
    }
    ++line;
  }
};
GameBoyCore.prototype.DisplayShowOff = function () {
  if (this.drewBlank == 0) {
    //Output a blank screen to the output framebuffer:
    this.clearFrameBuffer();
    this.drewFrame = true;
  }
  this.drewBlank = 2;
};
GameBoyCore.prototype.executeHDMA = function () {
  this.DMAWrite(1);
  if (this.halt) {
    if ((this.LCDTicks - this.spriteCount) < ((4 >> this.doubleSpeedShifter) | 0x20)) {
      //HALT clocking correction:
      this.CPUTicks = 4 + ((0x20 + this.spriteCount) << this.doubleSpeedShifter);
      this.LCDTicks = this.spriteCount + ((4 >> this.doubleSpeedShifter) | 0x20);
    }
  }
  else {
    this.LCDTicks += (4 >> this.doubleSpeedShifter) | 0x20;     //LCD Timing Update For HDMA.
  }
  if (this.memory[0xFF55] == 0) {
    this.hdmaRunning = false;
    this.memory[0xFF55] = 0xFF; //Transfer completed ("Hidden last step," since some ROMs don't imply this, but most do).
  }
  else {
    --this.memory[0xFF55];
  }
};
GameBoyCore.prototype.clockUpdate = function () {
  if (this.cTIMER) {
    var dateObj = new Date();
    var newTime = dateObj.getTime();
    var timeElapsed = newTime - this.lastIteration; //Get the numnber of milliseconds since this last executed.
    this.lastIteration = newTime;
    if (this.cTIMER && !this.RTCHALT) {
      //Update the MBC3 RTC:
      this.RTCSeconds += timeElapsed / 1000;
      while (this.RTCSeconds >= 60) { //System can stutter, so the seconds difference can get large, thus the "while".
        this.RTCSeconds -= 60;
        ++this.RTCMinutes;
        if (this.RTCMinutes >= 60) {
          this.RTCMinutes -= 60;
          ++this.RTCHours;
          if (this.RTCHours >= 24) {
            this.RTCHours -= 24;
            this.RTCDays++;
            if (this.RTCDays >= 512) {
              this.RTCDays -= 512;
              this.RTCDayOverFlow = true;
            }
          }
        }
      }
    }
  }
};
GameBoyCore.prototype.prepareFrame = function () {
  //Copy the internal frame buffer to the output buffer:
  this.swizzleFrameBuffer();
  this.drewFrame = true;
};
GameBoyCore.prototype.requestDraw = function () {
  if (this.drewFrame) {
    this.dispatchDraw();
  }
};
GameBoyCore.prototype.dispatchDraw = function () {
  if (this.offscreenRGBCount > 0) {
    this.processDraw(this.swizzledFrame);
  }
};
GameBoyCore.prototype.processDraw = function (frameBuffer) {
  var canvasRGBALength = this.offscreenRGBCount;
  var canvasData = this.canvasBuffer.data;
  var bufferIndex = 0;
  for (var canvasIndex = 0; canvasIndex < canvasRGBALength; ++canvasIndex) {
    canvasData[canvasIndex++] = frameBuffer[bufferIndex++];
    canvasData[canvasIndex++] = frameBuffer[bufferIndex++];
    canvasData[canvasIndex++] = frameBuffer[bufferIndex++];
  }
  this.graphicsBlit();
  this.drewFrame = false;
  if (this.opts.drawEvents) this.emit('draw');
};
GameBoyCore.prototype.swizzleFrameBuffer = function () {
  //Convert our dirty 24-bit (24-bit, with internal render flags above it) framebuffer to an 8-bit buffer with separate indices for the RGB channels:
  var frameBuffer = this.frameBuffer;
  var swizzledFrame = this.swizzledFrame;
  var bufferIndex = 0;
  for (var canvasIndex = 0; canvasIndex < 69120;) {
    swizzledFrame[canvasIndex++] = (frameBuffer[bufferIndex] >> 16) & 0xFF;   //Red
    swizzledFrame[canvasIndex++] = (frameBuffer[bufferIndex] >> 8) & 0xFF;    //Green
    swizzledFrame[canvasIndex++] = frameBuffer[bufferIndex++] & 0xFF;     //Blue
  }
};
GameBoyCore.prototype.clearFrameBuffer = function () {
  var bufferIndex = 0;
  var frameBuffer = this.swizzledFrame;
  if (this.cGBC || this.colorizedGBPalettes) {
    while (bufferIndex < 69120) {
      frameBuffer[bufferIndex++] = 248;
    }
  }
  else {
    while (bufferIndex < 69120) {
      frameBuffer[bufferIndex++] = 239;
      frameBuffer[bufferIndex++] = 255;
      frameBuffer[bufferIndex++] = 222;
    }
  }
};
GameBoyCore.prototype.renderScanLine = function (scanlineToRender) {
  this.pixelStart = scanlineToRender * 160;
  if (this.bgEnabled) {
    this.pixelEnd = 160;
    this.BGLayerRender(scanlineToRender);
    this.WindowLayerRender(scanlineToRender);
  }
  else {
    var pixelLine = (scanlineToRender + 1) * 160;
    var defaultColor = (this.cGBC || this.colorizedGBPalettes) ? 0xF8F8F8 : 0xEFFFDE;
    for (var pixelPosition = (scanlineToRender * 160) + this.currentX; pixelPosition < pixelLine; pixelPosition++) {
      this.frameBuffer[pixelPosition] = defaultColor;
    }
  }
  this.SpriteLayerRender(scanlineToRender);
  this.currentX = 0;
  this.midScanlineOffset = -1;
};
GameBoyCore.prototype.renderMidScanLine = function () {
  if (this.actualScanLine < 144 && this.modeSTAT == 3) {
    //TODO: Get this accurate:
    if (this.midScanlineOffset == -1) {
      this.midScanlineOffset = this.backgroundX & 0x7;
    }
    if (this.LCDTicks >= 82) {
      this.pixelEnd = this.LCDTicks - 74;
      this.pixelEnd = Math.min(this.pixelEnd - this.midScanlineOffset - (this.pixelEnd % 0x8), 160);
      if (this.bgEnabled) {
        this.pixelStart = this.lastUnrenderedLine * 160;
        this.BGLayerRender(this.lastUnrenderedLine);
        this.WindowLayerRender(this.lastUnrenderedLine);
        //TODO: Do midscanline JIT for sprites...
      }
      else {
        var pixelLine = (this.lastUnrenderedLine * 160) + this.pixelEnd;
        var defaultColor = (this.cGBC || this.colorizedGBPalettes) ? 0xF8F8F8 : 0xEFFFDE;
        for (var pixelPosition = (this.lastUnrenderedLine * 160) + this.currentX; pixelPosition < pixelLine; pixelPosition++) {
          this.frameBuffer[pixelPosition] = defaultColor;
        }
      }
      this.currentX = this.pixelEnd;
    }
  }
};
GameBoyCore.prototype.initializeModeSpecificArrays = function () {
  this.LCDCONTROL = (this.LCDisOn) ? this.LINECONTROL : this.DISPLAYOFFCONTROL;
  if (this.cGBC) {
    this.gbcOBJRawPalette = this.getTypedArray(0x40, 0, "uint8");
    this.gbcBGRawPalette = this.getTypedArray(0x40, 0, "uint8");
    this.gbcOBJPalette = this.getTypedArray(0x20, 0x1000000, "int32");
    this.gbcBGPalette = this.getTypedArray(0x40, 0, "int32");
    this.BGCHRBank2 = this.getTypedArray(0x800, 0, "uint8");
    this.BGCHRCurrentBank = (this.currVRAMBank > 0) ? this.BGCHRBank2 : this.BGCHRBank1;
    this.tileCache = this.generateCacheArray(0xF80);
  }
  else {
    this.gbOBJPalette = this.getTypedArray(8, 0, "int32");
    this.gbBGPalette = this.getTypedArray(4, 0, "int32");
    this.BGPalette = this.gbBGPalette;
    this.OBJPalette = this.gbOBJPalette;
    this.tileCache = this.generateCacheArray(0x700);
    this.sortBuffer = this.getTypedArray(0x100, 0, "uint8");
    this.OAMAddressCache = this.getTypedArray(10, 0, "int32");
  }
  this.renderPathBuild();
};
GameBoyCore.prototype.GBCtoGBModeAdjust = function () {
  debug("Stepping down from GBC mode.", 0);
  this.VRAM = this.GBCMemory = this.BGCHRCurrentBank = this.BGCHRBank2 = null;
  this.tileCache.length = 0x700;
  if (this.opts.colorizeGb) {
    this.gbBGColorizedPalette = this.getTypedArray(4, 0, "int32");
    this.gbOBJColorizedPalette = this.getTypedArray(8, 0, "int32");
    this.cachedBGPaletteConversion = this.getTypedArray(4, 0, "int32");
    this.cachedOBJPaletteConversion = this.getTypedArray(8, 0, "int32");
    this.BGPalette = this.gbBGColorizedPalette;
    this.OBJPalette = this.gbOBJColorizedPalette;
    this.gbOBJPalette = this.gbBGPalette = null;
    this.getGBCColor();
  }
  else {
    this.gbOBJPalette = this.getTypedArray(8, 0, "int32");
    this.gbBGPalette = this.getTypedArray(4, 0, "int32");
    this.BGPalette = this.gbBGPalette;
    this.OBJPalette = this.gbOBJPalette;
  }
  this.sortBuffer = this.getTypedArray(0x100, 0, "uint8");
  this.OAMAddressCache = this.getTypedArray(10, 0, "int32");
  this.renderPathBuild();
  this.memoryReadJumpCompile();
  this.memoryWriteJumpCompile();
};
GameBoyCore.prototype.renderPathBuild = function () {
  if (!this.cGBC) {
    this.BGLayerRender = this.BGGBLayerRender;
    this.WindowLayerRender = this.WindowGBLayerRender;
    this.SpriteLayerRender = this.SpriteGBLayerRender;
  }
  else {
    this.priorityFlaggingPathRebuild();
    this.SpriteLayerRender = this.SpriteGBCLayerRender;
  }
};
GameBoyCore.prototype.priorityFlaggingPathRebuild = function () {
  if (this.BGPriorityEnabled) {
    this.BGLayerRender = this.BGGBCLayerRender;
    this.WindowLayerRender = this.WindowGBCLayerRender;
  }
  else {
    this.BGLayerRender = this.BGGBCLayerRenderNoPriorityFlagging;
    this.WindowLayerRender = this.WindowGBCLayerRenderNoPriorityFlagging;
  }
};
GameBoyCore.prototype.initializeReferencesFromSaveState = function () {
  this.LCDCONTROL = (this.LCDisOn) ? this.LINECONTROL : this.DISPLAYOFFCONTROL;
  var tileIndex = 0;
  if (!this.cGBC) {
    if (this.colorizedGBPalettes) {
      this.BGPalette = this.gbBGColorizedPalette;
      this.OBJPalette = this.gbOBJColorizedPalette;
      this.updateGBBGPalette = this.updateGBColorizedBGPalette;
      this.updateGBOBJPalette = this.updateGBColorizedOBJPalette;
      
    }
    else {
      this.BGPalette = this.gbBGPalette;
      this.OBJPalette = this.gbOBJPalette;
    }
    this.tileCache = this.generateCacheArray(0x700);
    for (tileIndex = 0x8000; tileIndex < 0x9000; tileIndex += 2) {
      this.generateGBOAMTileLine(tileIndex);
    }
    for (tileIndex = 0x9000; tileIndex < 0x9800; tileIndex += 2) {
      this.generateGBTileLine(tileIndex);
    }
    this.sortBuffer = this.getTypedArray(0x100, 0, "uint8");
    this.OAMAddressCache = this.getTypedArray(10, 0, "int32");
  }
  else {
    this.BGCHRCurrentBank = (this.currVRAMBank > 0) ? this.BGCHRBank2 : this.BGCHRBank1;
    this.tileCache = this.generateCacheArray(0xF80);
    for (; tileIndex < 0x1800; tileIndex += 0x10) {
      this.generateGBCTileBank1(tileIndex);
      this.generateGBCTileBank2(tileIndex);
    }
  }
  this.renderPathBuild();
};
GameBoyCore.prototype.RGBTint = function (value) {
  //Adjustment for the GBC's tinting (According to Gambatte):
  var r = value & 0x1F;
  var g = (value >> 5) & 0x1F;
  var b = (value >> 10) & 0x1F;
  return ((r * 13 + g * 2 + b) >> 1) << 16 | (g * 3 + b) << 9 | (r * 3 + g * 2 + b * 11) >> 1;
};
GameBoyCore.prototype.getGBCColor = function () {
  //GBC Colorization of DMG ROMs:
  //BG
  var adjustedIndex;
  for (var counter = 0; counter < 4; counter++) {
    adjustedIndex = counter << 1;
    //BG
    this.cachedBGPaletteConversion[counter] = this.RGBTint((this.gbcBGRawPalette[adjustedIndex | 1] << 8) | this.gbcBGRawPalette[adjustedIndex]);
    //OBJ 1
    this.cachedOBJPaletteConversion[counter] = this.RGBTint((this.gbcOBJRawPalette[adjustedIndex | 1] << 8) | this.gbcOBJRawPalette[adjustedIndex]);
  }
  //OBJ 2
  for (counter = 4; counter < 8; counter++) {
    adjustedIndex = counter << 1;
    this.cachedOBJPaletteConversion[counter] = this.RGBTint((this.gbcOBJRawPalette[adjustedIndex | 1] << 8) | this.gbcOBJRawPalette[adjustedIndex]);
  }
  //Update the palette entries:
  this.updateGBBGPalette = this.updateGBColorizedBGPalette;
  this.updateGBOBJPalette = this.updateGBColorizedOBJPalette;
  this.updateGBBGPalette(this.memory[0xFF47]);
  this.updateGBOBJPalette(0, this.memory[0xFF48]);
  this.updateGBOBJPalette(1, this.memory[0xFF49]);
  this.colorizedGBPalettes = true;
};
GameBoyCore.prototype.updateGBRegularBGPalette = function (data) {
  this.gbBGPalette[0] = this.colors[data & 0x03] | 0x2000000;
  this.gbBGPalette[1] = this.colors[(data >> 2) & 0x03];
  this.gbBGPalette[2] = this.colors[(data >> 4) & 0x03];
  this.gbBGPalette[3] = this.colors[data >> 6];
};
GameBoyCore.prototype.updateGBColorizedBGPalette = function (data) {
  //GB colorization:
  this.gbBGColorizedPalette[0] = this.cachedBGPaletteConversion[data & 0x03] | 0x2000000;
  this.gbBGColorizedPalette[1] = this.cachedBGPaletteConversion[(data >> 2) & 0x03];
  this.gbBGColorizedPalette[2] = this.cachedBGPaletteConversion[(data >> 4) & 0x03];
  this.gbBGColorizedPalette[3] = this.cachedBGPaletteConversion[data >> 6];
};
GameBoyCore.prototype.updateGBRegularOBJPalette = function (index, data) {
  this.gbOBJPalette[index | 1] = this.colors[(data >> 2) & 0x03];
  this.gbOBJPalette[index | 2] = this.colors[(data >> 4) & 0x03];
  this.gbOBJPalette[index | 3] = this.colors[data >> 6];
};
GameBoyCore.prototype.updateGBColorizedOBJPalette = function (index, data) {
  //GB colorization:
  this.gbOBJColorizedPalette[index | 1] = this.cachedOBJPaletteConversion[index | ((data >> 2) & 0x03)];
  this.gbOBJColorizedPalette[index | 2] = this.cachedOBJPaletteConversion[index | ((data >> 4) & 0x03)];
  this.gbOBJColorizedPalette[index | 3] = this.cachedOBJPaletteConversion[index | (data >> 6)];
};
GameBoyCore.prototype.updateGBCBGPalette = function (index, data) {
  if (this.gbcBGRawPalette[index] != data) {
    this.midScanLineJIT();
    //Update the color palette for BG tiles since it changed:
    this.gbcBGRawPalette[index] = data;
    if ((index & 0x06) == 0) {
      //Palette 0 (Special tile Priority stuff)
      data = 0x2000000 | this.RGBTint((this.gbcBGRawPalette[index | 1] << 8) | this.gbcBGRawPalette[index & 0x3E]);
      index >>= 1;
      this.gbcBGPalette[index] = data;
      this.gbcBGPalette[0x20 | index] = 0x1000000 | data;
    }
    else {
      //Regular Palettes (No special crap)
      data = this.RGBTint((this.gbcBGRawPalette[index | 1] << 8) | this.gbcBGRawPalette[index & 0x3E]);
      index >>= 1;
      this.gbcBGPalette[index] = data;
      this.gbcBGPalette[0x20 | index] = 0x1000000 | data;
    }
  }
};
GameBoyCore.prototype.updateGBCOBJPalette = function (index, data) {
  if (this.gbcOBJRawPalette[index] != data) {
    //Update the color palette for OBJ tiles since it changed:
    this.gbcOBJRawPalette[index] = data;
    if ((index & 0x06) > 0) {
      //Regular Palettes (No special crap)
      this.midScanLineJIT();
      this.gbcOBJPalette[index >> 1] = 0x1000000 | this.RGBTint((this.gbcOBJRawPalette[index | 1] << 8) | this.gbcOBJRawPalette[index & 0x3E]);
    }
  }
};
GameBoyCore.prototype.BGGBLayerRender = function (scanlineToRender) {
  var scrollYAdjusted = (this.backgroundY + scanlineToRender) & 0xFF;           //The line of the BG we're at.
  var tileYLine = (scrollYAdjusted & 7) << 3;
  var tileYDown = this.gfxBackgroundCHRBankPosition | ((scrollYAdjusted & 0xF8) << 2);  //The row of cached tiles we're fetching from.
  var scrollXAdjusted = (this.backgroundX + this.currentX) & 0xFF;            //The scroll amount of the BG.
  var pixelPosition = this.pixelStart + this.currentX;                  //Current pixel we're working on.
  var pixelPositionEnd = this.pixelStart + ((this.gfxWindowDisplay && (scanlineToRender - this.windowY) >= 0) ? Math.min(Math.max(this.windowX, 0) + this.currentX, this.pixelEnd) : this.pixelEnd);  //Make sure we do at most 160 pixels a scanline.
  var tileNumber = tileYDown + (scrollXAdjusted >> 3);
  var chrCode = this.BGCHRBank1[tileNumber];
  if (chrCode < this.gfxBackgroundBankOffset) {
    chrCode |= 0x100;
  }
  var tile = this.tileCache[chrCode];
  for (var texel = (scrollXAdjusted & 0x7); texel < 8 && pixelPosition < pixelPositionEnd && scrollXAdjusted < 0x100; ++scrollXAdjusted) {
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[tileYLine | texel++]];
  }
  var scrollXAdjustedAligned = Math.min(pixelPositionEnd - pixelPosition, 0x100 - scrollXAdjusted) >> 3;
  scrollXAdjusted += scrollXAdjustedAligned << 3;
  scrollXAdjustedAligned += tileNumber;
  while (tileNumber < scrollXAdjustedAligned) {
    chrCode = this.BGCHRBank1[++tileNumber];
    if (chrCode < this.gfxBackgroundBankOffset) {
      chrCode |= 0x100;
    }
    tile = this.tileCache[chrCode];
    texel = tileYLine;
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel]];
  }
  if (pixelPosition < pixelPositionEnd) {
    if (scrollXAdjusted < 0x100) {
      chrCode = this.BGCHRBank1[++tileNumber];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      tile = this.tileCache[chrCode];
      for (texel = tileYLine - 1; pixelPosition < pixelPositionEnd && scrollXAdjusted < 0x100; ++scrollXAdjusted) {
        this.frameBuffer[pixelPosition++] = this.BGPalette[tile[++texel]];
      }
    }
    scrollXAdjustedAligned = ((pixelPositionEnd - pixelPosition) >> 3) + tileYDown;
    while (tileYDown < scrollXAdjustedAligned) {
      chrCode = this.BGCHRBank1[tileYDown++];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      tile = this.tileCache[chrCode];
      texel = tileYLine;
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel]];
    }
    if (pixelPosition < pixelPositionEnd) {
      chrCode = this.BGCHRBank1[tileYDown];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      tile = this.tileCache[chrCode];
      switch (pixelPositionEnd - pixelPosition) {
        case 7:
          this.frameBuffer[pixelPosition + 6] = this.BGPalette[tile[tileYLine | 6]];
        case 6:
          this.frameBuffer[pixelPosition + 5] = this.BGPalette[tile[tileYLine | 5]];
        case 5:
          this.frameBuffer[pixelPosition + 4] = this.BGPalette[tile[tileYLine | 4]];
        case 4:
          this.frameBuffer[pixelPosition + 3] = this.BGPalette[tile[tileYLine | 3]];
        case 3:
          this.frameBuffer[pixelPosition + 2] = this.BGPalette[tile[tileYLine | 2]];
        case 2:
          this.frameBuffer[pixelPosition + 1] = this.BGPalette[tile[tileYLine | 1]];
        case 1:
          this.frameBuffer[pixelPosition] = this.BGPalette[tile[tileYLine]];
      }
    }
  }
};
GameBoyCore.prototype.BGGBCLayerRender = function (scanlineToRender) {
  var scrollYAdjusted = (this.backgroundY + scanlineToRender) & 0xFF;           //The line of the BG we're at.
  var tileYLine = (scrollYAdjusted & 7) << 3;
  var tileYDown = this.gfxBackgroundCHRBankPosition | ((scrollYAdjusted & 0xF8) << 2);  //The row of cached tiles we're fetching from.
  var scrollXAdjusted = (this.backgroundX + this.currentX) & 0xFF;            //The scroll amount of the BG.
  var pixelPosition = this.pixelStart + this.currentX;                  //Current pixel we're working on.
  var pixelPositionEnd = this.pixelStart + ((this.gfxWindowDisplay && (scanlineToRender - this.windowY) >= 0) ? Math.min(Math.max(this.windowX, 0) + this.currentX, this.pixelEnd) : this.pixelEnd);  //Make sure we do at most 160 pixels a scanline.
  var tileNumber = tileYDown + (scrollXAdjusted >> 3);
  var chrCode = this.BGCHRBank1[tileNumber];
  if (chrCode < this.gfxBackgroundBankOffset) {
    chrCode |= 0x100;
  }
  var attrCode = this.BGCHRBank2[tileNumber];
  var tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
  var palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
  for (var texel = (scrollXAdjusted & 0x7); texel < 8 && pixelPosition < pixelPositionEnd && scrollXAdjusted < 0x100; ++scrollXAdjusted) {
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[tileYLine | texel++]];
  }
  var scrollXAdjustedAligned = Math.min(pixelPositionEnd - pixelPosition, 0x100 - scrollXAdjusted) >> 3;
  scrollXAdjusted += scrollXAdjustedAligned << 3;
  scrollXAdjustedAligned += tileNumber;
  while (tileNumber < scrollXAdjustedAligned) {
    chrCode = this.BGCHRBank1[++tileNumber];
    if (chrCode < this.gfxBackgroundBankOffset) {
      chrCode |= 0x100;
    }
    attrCode = this.BGCHRBank2[tileNumber];
    tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
    palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
    texel = tileYLine;
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel]];
  }
  if (pixelPosition < pixelPositionEnd) {
    if (scrollXAdjusted < 0x100) {
      chrCode = this.BGCHRBank1[++tileNumber];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      attrCode = this.BGCHRBank2[tileNumber];
      tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
      palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
      for (texel = tileYLine - 1; pixelPosition < pixelPositionEnd && scrollXAdjusted < 0x100; ++scrollXAdjusted) {
        this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[++texel]];
      }
    }
    scrollXAdjustedAligned = ((pixelPositionEnd - pixelPosition) >> 3) + tileYDown;
    while (tileYDown < scrollXAdjustedAligned) {
      chrCode = this.BGCHRBank1[tileYDown];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      attrCode = this.BGCHRBank2[tileYDown++];
      tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
      palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
      texel = tileYLine;
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel]];
    }
    if (pixelPosition < pixelPositionEnd) {
      chrCode = this.BGCHRBank1[tileYDown];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      attrCode = this.BGCHRBank2[tileYDown];
      tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
      palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
      switch (pixelPositionEnd - pixelPosition) {
        case 7:
          this.frameBuffer[pixelPosition + 6] = this.gbcBGPalette[palette | tile[tileYLine | 6]];
        case 6:
          this.frameBuffer[pixelPosition + 5] = this.gbcBGPalette[palette | tile[tileYLine | 5]];
        case 5:
          this.frameBuffer[pixelPosition + 4] = this.gbcBGPalette[palette | tile[tileYLine | 4]];
        case 4:
          this.frameBuffer[pixelPosition + 3] = this.gbcBGPalette[palette | tile[tileYLine | 3]];
        case 3:
          this.frameBuffer[pixelPosition + 2] = this.gbcBGPalette[palette | tile[tileYLine | 2]];
        case 2:
          this.frameBuffer[pixelPosition + 1] = this.gbcBGPalette[palette | tile[tileYLine | 1]];
        case 1:
          this.frameBuffer[pixelPosition] = this.gbcBGPalette[palette | tile[tileYLine]];
      }
    }
  }
};
GameBoyCore.prototype.BGGBCLayerRenderNoPriorityFlagging = function (scanlineToRender) {
  var scrollYAdjusted = (this.backgroundY + scanlineToRender) & 0xFF;           //The line of the BG we're at.
  var tileYLine = (scrollYAdjusted & 7) << 3;
  var tileYDown = this.gfxBackgroundCHRBankPosition | ((scrollYAdjusted & 0xF8) << 2);  //The row of cached tiles we're fetching from.
  var scrollXAdjusted = (this.backgroundX + this.currentX) & 0xFF;            //The scroll amount of the BG.
  var pixelPosition = this.pixelStart + this.currentX;                  //Current pixel we're working on.
  var pixelPositionEnd = this.pixelStart + ((this.gfxWindowDisplay && (scanlineToRender - this.windowY) >= 0) ? Math.min(Math.max(this.windowX, 0) + this.currentX, this.pixelEnd) : this.pixelEnd);  //Make sure we do at most 160 pixels a scanline.
  var tileNumber = tileYDown + (scrollXAdjusted >> 3);
  var chrCode = this.BGCHRBank1[tileNumber];
  if (chrCode < this.gfxBackgroundBankOffset) {
    chrCode |= 0x100;
  }
  var attrCode = this.BGCHRBank2[tileNumber];
  var tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
  var palette = (attrCode & 0x7) << 2;
  for (var texel = (scrollXAdjusted & 0x7); texel < 8 && pixelPosition < pixelPositionEnd && scrollXAdjusted < 0x100; ++scrollXAdjusted) {
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[tileYLine | texel++]];
  }
  var scrollXAdjustedAligned = Math.min(pixelPositionEnd - pixelPosition, 0x100 - scrollXAdjusted) >> 3;
  scrollXAdjusted += scrollXAdjustedAligned << 3;
  scrollXAdjustedAligned += tileNumber;
  while (tileNumber < scrollXAdjustedAligned) {
    chrCode = this.BGCHRBank1[++tileNumber];
    if (chrCode < this.gfxBackgroundBankOffset) {
      chrCode |= 0x100;
    }
    attrCode = this.BGCHRBank2[tileNumber];
    tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
    palette = (attrCode & 0x7) << 2;
    texel = tileYLine;
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
    this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel]];
  }
  if (pixelPosition < pixelPositionEnd) {
    if (scrollXAdjusted < 0x100) {
      chrCode = this.BGCHRBank1[++tileNumber];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      attrCode = this.BGCHRBank2[tileNumber];
      tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
      palette = (attrCode & 0x7) << 2;
      for (texel = tileYLine - 1; pixelPosition < pixelPositionEnd && scrollXAdjusted < 0x100; ++scrollXAdjusted) {
        this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[++texel]];
      }
    }
    scrollXAdjustedAligned = ((pixelPositionEnd - pixelPosition) >> 3) + tileYDown;
    while (tileYDown < scrollXAdjustedAligned) {
      chrCode = this.BGCHRBank1[tileYDown];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      attrCode = this.BGCHRBank2[tileYDown++];
      tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
      palette = (attrCode & 0x7) << 2;
      texel = tileYLine;
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
      this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel]];
    }
    if (pixelPosition < pixelPositionEnd) {
      chrCode = this.BGCHRBank1[tileYDown];
      if (chrCode < this.gfxBackgroundBankOffset) {
        chrCode |= 0x100;
      }
      attrCode = this.BGCHRBank2[tileYDown];
      tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
      palette = (attrCode & 0x7) << 2;
      switch (pixelPositionEnd - pixelPosition) {
        case 7:
          this.frameBuffer[pixelPosition + 6] = this.gbcBGPalette[palette | tile[tileYLine | 6]];
        case 6:
          this.frameBuffer[pixelPosition + 5] = this.gbcBGPalette[palette | tile[tileYLine | 5]];
        case 5:
          this.frameBuffer[pixelPosition + 4] = this.gbcBGPalette[palette | tile[tileYLine | 4]];
        case 4:
          this.frameBuffer[pixelPosition + 3] = this.gbcBGPalette[palette | tile[tileYLine | 3]];
        case 3:
          this.frameBuffer[pixelPosition + 2] = this.gbcBGPalette[palette | tile[tileYLine | 2]];
        case 2:
          this.frameBuffer[pixelPosition + 1] = this.gbcBGPalette[palette | tile[tileYLine | 1]];
        case 1:
          this.frameBuffer[pixelPosition] = this.gbcBGPalette[palette | tile[tileYLine]];
      }
    }
  }
};
GameBoyCore.prototype.WindowGBLayerRender = function (scanlineToRender) {
  if (this.gfxWindowDisplay) {                  //Is the window enabled?
    var scrollYAdjusted = scanlineToRender - this.windowY;    //The line of the BG we're at.
    if (scrollYAdjusted >= 0) {
      var scrollXRangeAdjusted = (this.windowX > 0) ? (this.windowX + this.currentX) : this.currentX;
      var pixelPosition = this.pixelStart + scrollXRangeAdjusted;
      var pixelPositionEnd = this.pixelStart + this.pixelEnd;
      if (pixelPosition < pixelPositionEnd) {
        var tileYLine = (scrollYAdjusted & 0x7) << 3;
        var tileNumber = (this.gfxWindowCHRBankPosition | ((scrollYAdjusted & 0xF8) << 2)) + (this.currentX >> 3);
        var chrCode = this.BGCHRBank1[tileNumber];
        if (chrCode < this.gfxBackgroundBankOffset) {
          chrCode |= 0x100;
        }
        var tile = this.tileCache[chrCode];
        var texel = (scrollXRangeAdjusted - this.windowX) & 0x7;
        scrollXRangeAdjusted = Math.min(8, texel + pixelPositionEnd - pixelPosition);
        while (texel < scrollXRangeAdjusted) {
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[tileYLine | texel++]];
        }
        scrollXRangeAdjusted = tileNumber + ((pixelPositionEnd - pixelPosition) >> 3);
        while (tileNumber < scrollXRangeAdjusted) {
          chrCode = this.BGCHRBank1[++tileNumber];
          if (chrCode < this.gfxBackgroundBankOffset) {
            chrCode |= 0x100;
          }
          tile = this.tileCache[chrCode];
          texel = tileYLine;
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.BGPalette[tile[texel]];
        }
        if (pixelPosition < pixelPositionEnd) {
          chrCode = this.BGCHRBank1[++tileNumber];
          if (chrCode < this.gfxBackgroundBankOffset) {
            chrCode |= 0x100;
          }
          tile = this.tileCache[chrCode];
          switch (pixelPositionEnd - pixelPosition) {
            case 7:
              this.frameBuffer[pixelPosition + 6] = this.BGPalette[tile[tileYLine | 6]];
            case 6:
              this.frameBuffer[pixelPosition + 5] = this.BGPalette[tile[tileYLine | 5]];
            case 5:
              this.frameBuffer[pixelPosition + 4] = this.BGPalette[tile[tileYLine | 4]];
            case 4:
              this.frameBuffer[pixelPosition + 3] = this.BGPalette[tile[tileYLine | 3]];
            case 3:
              this.frameBuffer[pixelPosition + 2] = this.BGPalette[tile[tileYLine | 2]];
            case 2:
              this.frameBuffer[pixelPosition + 1] = this.BGPalette[tile[tileYLine | 1]];
            case 1:
              this.frameBuffer[pixelPosition] = this.BGPalette[tile[tileYLine]];
          }
        }
      }
    }
  }
};
GameBoyCore.prototype.WindowGBCLayerRender = function (scanlineToRender) {
  if (this.gfxWindowDisplay) {                  //Is the window enabled?
    var scrollYAdjusted = scanlineToRender - this.windowY;    //The line of the BG we're at.
    if (scrollYAdjusted >= 0) {
      var scrollXRangeAdjusted = (this.windowX > 0) ? (this.windowX + this.currentX) : this.currentX;
      var pixelPosition = this.pixelStart + scrollXRangeAdjusted;
      var pixelPositionEnd = this.pixelStart + this.pixelEnd;
      if (pixelPosition < pixelPositionEnd) {
        var tileYLine = (scrollYAdjusted & 0x7) << 3;
        var tileNumber = (this.gfxWindowCHRBankPosition | ((scrollYAdjusted & 0xF8) << 2)) + (this.currentX >> 3);
        var chrCode = this.BGCHRBank1[tileNumber];
        if (chrCode < this.gfxBackgroundBankOffset) {
          chrCode |= 0x100;
        }
        var attrCode = this.BGCHRBank2[tileNumber];
        var tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
        var palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
        var texel = (scrollXRangeAdjusted - this.windowX) & 0x7;
        scrollXRangeAdjusted = Math.min(8, texel + pixelPositionEnd - pixelPosition);
        while (texel < scrollXRangeAdjusted) {
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[tileYLine | texel++]];
        }
        scrollXRangeAdjusted = tileNumber + ((pixelPositionEnd - pixelPosition) >> 3);
        while (tileNumber < scrollXRangeAdjusted) {
          chrCode = this.BGCHRBank1[++tileNumber];
          if (chrCode < this.gfxBackgroundBankOffset) {
            chrCode |= 0x100;
          }
          attrCode = this.BGCHRBank2[tileNumber];
          tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
          palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
          texel = tileYLine;
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel]];
        }
        if (pixelPosition < pixelPositionEnd) {
          chrCode = this.BGCHRBank1[++tileNumber];
          if (chrCode < this.gfxBackgroundBankOffset) {
            chrCode |= 0x100;
          }
          attrCode = this.BGCHRBank2[tileNumber];
          tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
          palette = ((attrCode & 0x7) << 2) | ((attrCode & 0x80) >> 2);
          switch (pixelPositionEnd - pixelPosition) {
            case 7:
              this.frameBuffer[pixelPosition + 6] = this.gbcBGPalette[palette | tile[tileYLine | 6]];
            case 6:
              this.frameBuffer[pixelPosition + 5] = this.gbcBGPalette[palette | tile[tileYLine | 5]];
            case 5:
              this.frameBuffer[pixelPosition + 4] = this.gbcBGPalette[palette | tile[tileYLine | 4]];
            case 4:
              this.frameBuffer[pixelPosition + 3] = this.gbcBGPalette[palette | tile[tileYLine | 3]];
            case 3:
              this.frameBuffer[pixelPosition + 2] = this.gbcBGPalette[palette | tile[tileYLine | 2]];
            case 2:
              this.frameBuffer[pixelPosition + 1] = this.gbcBGPalette[palette | tile[tileYLine | 1]];
            case 1:
              this.frameBuffer[pixelPosition] = this.gbcBGPalette[palette | tile[tileYLine]];
          }
        }
      }
    }
  }
};
GameBoyCore.prototype.WindowGBCLayerRenderNoPriorityFlagging = function (scanlineToRender) {
  if (this.gfxWindowDisplay) {                  //Is the window enabled?
    var scrollYAdjusted = scanlineToRender - this.windowY;    //The line of the BG we're at.
    if (scrollYAdjusted >= 0) {
      var scrollXRangeAdjusted = (this.windowX > 0) ? (this.windowX + this.currentX) : this.currentX;
      var pixelPosition = this.pixelStart + scrollXRangeAdjusted;
      var pixelPositionEnd = this.pixelStart + this.pixelEnd;
      if (pixelPosition < pixelPositionEnd) {
        var tileYLine = (scrollYAdjusted & 0x7) << 3;
        var tileNumber = (this.gfxWindowCHRBankPosition | ((scrollYAdjusted & 0xF8) << 2)) + (this.currentX >> 3);
        var chrCode = this.BGCHRBank1[tileNumber];
        if (chrCode < this.gfxBackgroundBankOffset) {
          chrCode |= 0x100;
        }
        var attrCode = this.BGCHRBank2[tileNumber];
        var tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
        var palette = (attrCode & 0x7) << 2;
        var texel = (scrollXRangeAdjusted - this.windowX) & 0x7;
        scrollXRangeAdjusted = Math.min(8, texel + pixelPositionEnd - pixelPosition);
        while (texel < scrollXRangeAdjusted) {
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[tileYLine | texel++]];
        }
        scrollXRangeAdjusted = tileNumber + ((pixelPositionEnd - pixelPosition) >> 3);
        while (tileNumber < scrollXRangeAdjusted) {
          chrCode = this.BGCHRBank1[++tileNumber];
          if (chrCode < this.gfxBackgroundBankOffset) {
            chrCode |= 0x100;
          }
          attrCode = this.BGCHRBank2[tileNumber];
          tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
          palette = (attrCode & 0x7) << 2;
          texel = tileYLine;
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel++]];
          this.frameBuffer[pixelPosition++] = this.gbcBGPalette[palette | tile[texel]];
        }
        if (pixelPosition < pixelPositionEnd) {
          chrCode = this.BGCHRBank1[++tileNumber];
          if (chrCode < this.gfxBackgroundBankOffset) {
            chrCode |= 0x100;
          }
          attrCode = this.BGCHRBank2[tileNumber];
          tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | chrCode];
          palette = (attrCode & 0x7) << 2;
          switch (pixelPositionEnd - pixelPosition) {
            case 7:
              this.frameBuffer[pixelPosition + 6] = this.gbcBGPalette[palette | tile[tileYLine | 6]];
            case 6:
              this.frameBuffer[pixelPosition + 5] = this.gbcBGPalette[palette | tile[tileYLine | 5]];
            case 5:
              this.frameBuffer[pixelPosition + 4] = this.gbcBGPalette[palette | tile[tileYLine | 4]];
            case 4:
              this.frameBuffer[pixelPosition + 3] = this.gbcBGPalette[palette | tile[tileYLine | 3]];
            case 3:
              this.frameBuffer[pixelPosition + 2] = this.gbcBGPalette[palette | tile[tileYLine | 2]];
            case 2:
              this.frameBuffer[pixelPosition + 1] = this.gbcBGPalette[palette | tile[tileYLine | 1]];
            case 1:
              this.frameBuffer[pixelPosition] = this.gbcBGPalette[palette | tile[tileYLine]];
          }
        }
      }
    }
  }
};
GameBoyCore.prototype.SpriteGBLayerRender = function (scanlineToRender) {
  if (this.gfxSpriteShow) {                   //Are sprites enabled?
    var lineAdjusted = scanlineToRender + 0x10;
    var OAMAddress = 0xFE00;
    var yoffset = 0;
    var xcoord = 1;
    var xCoordStart = 0;
    var xCoordEnd = 0;
    var attrCode = 0;
    var palette = 0;
    var tile = null;
    var data = 0;
    var spriteCount = 0;
    var length = 0;
    var currentPixel = 0;
    var linePixel = 0;
    //Clear our x-coord sort buffer:
    while (xcoord < 168) {
      this.sortBuffer[xcoord++] = 0xFF;
    }
    if (this.gfxSpriteNormalHeight) {
      //Draw the visible sprites:
      for (var length = this.findLowestSpriteDrawable(lineAdjusted, 0x7); spriteCount < length; ++spriteCount) {
        OAMAddress = this.OAMAddressCache[spriteCount];
        yoffset = (lineAdjusted - this.memory[OAMAddress]) << 3;
        attrCode = this.memory[OAMAddress | 3];
        palette = (attrCode & 0x10) >> 2;
        tile = this.tileCache[((attrCode & 0x60) << 4) | this.memory[OAMAddress | 0x2]];
        linePixel = xCoordStart = this.memory[OAMAddress | 1];
        xCoordEnd = Math.min(168 - linePixel, 8);
        xcoord = (linePixel > 7) ? 0 : (8 - linePixel);
        for (currentPixel = this.pixelStart + ((linePixel > 8) ? (linePixel - 8) : 0); xcoord < xCoordEnd; ++xcoord, ++currentPixel, ++linePixel) {
          if (this.sortBuffer[linePixel] > xCoordStart) {
            if (this.frameBuffer[currentPixel] >= 0x2000000) {
              data = tile[yoffset | xcoord];
              if (data > 0) {
                this.frameBuffer[currentPixel] = this.OBJPalette[palette | data];
                this.sortBuffer[linePixel] = xCoordStart;
              }
            }
            else if (this.frameBuffer[currentPixel] < 0x1000000) {
              data = tile[yoffset | xcoord];
              if (data > 0 && attrCode < 0x80) {
                this.frameBuffer[currentPixel] = this.OBJPalette[palette | data];
                this.sortBuffer[linePixel] = xCoordStart;
              }
            }
          }
        }
      }
    }
    else {
      //Draw the visible sprites:
      for (var length = this.findLowestSpriteDrawable(lineAdjusted, 0xF); spriteCount < length; ++spriteCount) {
        OAMAddress = this.OAMAddressCache[spriteCount];
        yoffset = (lineAdjusted - this.memory[OAMAddress]) << 3;
        attrCode = this.memory[OAMAddress | 3];
        palette = (attrCode & 0x10) >> 2;
        if ((attrCode & 0x40) == (0x40 & yoffset)) {
          tile = this.tileCache[((attrCode & 0x60) << 4) | (this.memory[OAMAddress | 0x2] & 0xFE)];
        }
        else {
          tile = this.tileCache[((attrCode & 0x60) << 4) | this.memory[OAMAddress | 0x2] | 1];
        }
        yoffset &= 0x3F;
        linePixel = xCoordStart = this.memory[OAMAddress | 1];
        xCoordEnd = Math.min(168 - linePixel, 8);
        xcoord = (linePixel > 7) ? 0 : (8 - linePixel);
        for (currentPixel = this.pixelStart + ((linePixel > 8) ? (linePixel - 8) : 0); xcoord < xCoordEnd; ++xcoord, ++currentPixel, ++linePixel) {
          if (this.sortBuffer[linePixel] > xCoordStart) {
            if (this.frameBuffer[currentPixel] >= 0x2000000) {
              data = tile[yoffset | xcoord];
              if (data > 0) {
                this.frameBuffer[currentPixel] = this.OBJPalette[palette | data];
                this.sortBuffer[linePixel] = xCoordStart;
              }
            }
            else if (this.frameBuffer[currentPixel] < 0x1000000) {
              data = tile[yoffset | xcoord];
              if (data > 0 && attrCode < 0x80) {
                this.frameBuffer[currentPixel] = this.OBJPalette[palette | data];
                this.sortBuffer[linePixel] = xCoordStart;
              }
            }
          }
        }
      }
    }
  }
};
GameBoyCore.prototype.findLowestSpriteDrawable = function (scanlineToRender, drawableRange) {
  var address = 0xFE00;
  var spriteCount = 0;
  var diff = 0;
  while (address < 0xFEA0 && spriteCount < 10) {
    diff = scanlineToRender - this.memory[address];
    if ((diff & drawableRange) == diff) {
      this.OAMAddressCache[spriteCount++] = address;
    }
    address += 4;
  }
  return spriteCount;
};
GameBoyCore.prototype.SpriteGBCLayerRender = function (scanlineToRender) {
  if (this.gfxSpriteShow) {                   //Are sprites enabled?
    var OAMAddress = 0xFE00;
    var lineAdjusted = scanlineToRender + 0x10;
    var yoffset = 0;
    var xcoord = 0;
    var endX = 0;
    var xCounter = 0;
    var attrCode = 0;
    var palette = 0;
    var tile = null;
    var data = 0;
    var currentPixel = 0;
    var spriteCount = 0;
    if (this.gfxSpriteNormalHeight) {
      for (; OAMAddress < 0xFEA0 && spriteCount < 10; OAMAddress += 4) {
        yoffset = lineAdjusted - this.memory[OAMAddress];
        if ((yoffset & 0x7) == yoffset) {
          xcoord = this.memory[OAMAddress | 1] - 8;
          endX = Math.min(160, xcoord + 8);
          attrCode = this.memory[OAMAddress | 3];
          palette = (attrCode & 7) << 2;
          tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | this.memory[OAMAddress | 2]];
          xCounter = (xcoord > 0) ? xcoord : 0;
          xcoord -= yoffset << 3;
          for (currentPixel = this.pixelStart + xCounter; xCounter < endX; ++xCounter, ++currentPixel) {
            if (this.frameBuffer[currentPixel] >= 0x2000000) {
              data = tile[xCounter - xcoord];
              if (data > 0) {
                this.frameBuffer[currentPixel] = this.gbcOBJPalette[palette | data];
              }
            }
            else if (this.frameBuffer[currentPixel] < 0x1000000) {
              data = tile[xCounter - xcoord];
              if (data > 0 && attrCode < 0x80) {    //Don't optimize for attrCode, as LICM-capable JITs should optimize its checks.
                this.frameBuffer[currentPixel] = this.gbcOBJPalette[palette | data];
              }
            }
          }
          ++spriteCount;
        }
      }
    }
    else {
      for (; OAMAddress < 0xFEA0 && spriteCount < 10; OAMAddress += 4) {
        yoffset = lineAdjusted - this.memory[OAMAddress];
        if ((yoffset & 0xF) == yoffset) {
          xcoord = this.memory[OAMAddress | 1] - 8;
          endX = Math.min(160, xcoord + 8);
          attrCode = this.memory[OAMAddress | 3];
          palette = (attrCode & 7) << 2;
          if ((attrCode & 0x40) == (0x40 & (yoffset << 3))) {
            tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | (this.memory[OAMAddress | 0x2] & 0xFE)];
          }
          else {
            tile = this.tileCache[((attrCode & 0x08) << 8) | ((attrCode & 0x60) << 4) | this.memory[OAMAddress | 0x2] | 1];
          }
          xCounter = (xcoord > 0) ? xcoord : 0;
          xcoord -= (yoffset & 0x7) << 3;
          for (currentPixel = this.pixelStart + xCounter; xCounter < endX; ++xCounter, ++currentPixel) {
            if (this.frameBuffer[currentPixel] >= 0x2000000) {
              data = tile[xCounter - xcoord];
              if (data > 0) {
                this.frameBuffer[currentPixel] = this.gbcOBJPalette[palette | data];
              }
            }
            else if (this.frameBuffer[currentPixel] < 0x1000000) {
              data = tile[xCounter - xcoord];
              if (data > 0 && attrCode < 0x80) {    //Don't optimize for attrCode, as LICM-capable JITs should optimize its checks.
                this.frameBuffer[currentPixel] = this.gbcOBJPalette[palette | data];
              }
            }
          }
          ++spriteCount;
        }
      }
    }
  }
};
//Generate only a single tile line for the GB tile cache mode:
GameBoyCore.prototype.generateGBTileLine = function (address) {
  var lineCopy = (this.memory[0x1 | address] << 8) | this.memory[0x9FFE & address];
  var tileBlock = this.tileCache[(address & 0x1FF0) >> 4];
  address = (address & 0xE) << 2;
  tileBlock[address | 7] = ((lineCopy & 0x100) >> 7) | (lineCopy & 0x1);
  tileBlock[address | 6] = ((lineCopy & 0x200) >> 8) | ((lineCopy & 0x2) >> 1);
  tileBlock[address | 5] = ((lineCopy & 0x400) >> 9) | ((lineCopy & 0x4) >> 2);
  tileBlock[address | 4] = ((lineCopy & 0x800) >> 10) | ((lineCopy & 0x8) >> 3);
  tileBlock[address | 3] = ((lineCopy & 0x1000) >> 11) | ((lineCopy & 0x10) >> 4);
  tileBlock[address | 2] = ((lineCopy & 0x2000) >> 12) | ((lineCopy & 0x20) >> 5);
  tileBlock[address | 1] = ((lineCopy & 0x4000) >> 13) | ((lineCopy & 0x40) >> 6);
  tileBlock[address] = ((lineCopy & 0x8000) >> 14) | ((lineCopy & 0x80) >> 7);
};
//Generate only a single tile line for the GBC tile cache mode (Bank 1):
GameBoyCore.prototype.generateGBCTileLineBank1 = function (address) {
  var lineCopy = (this.memory[0x1 | address] << 8) | this.memory[0x9FFE & address];
  address &= 0x1FFE;
  var tileBlock1 = this.tileCache[address >> 4];
  var tileBlock2 = this.tileCache[0x200 | (address >> 4)];
  var tileBlock3 = this.tileCache[0x400 | (address >> 4)];
  var tileBlock4 = this.tileCache[0x600 | (address >> 4)];
  address = (address & 0xE) << 2;
  var addressFlipped = 0x38 - address;
  tileBlock4[addressFlipped] = tileBlock2[address] = tileBlock3[addressFlipped | 7] = tileBlock1[address | 7] = ((lineCopy & 0x100) >> 7) | (lineCopy & 0x1);
  tileBlock4[addressFlipped | 1] = tileBlock2[address | 1] = tileBlock3[addressFlipped | 6] = tileBlock1[address | 6] = ((lineCopy & 0x200) >> 8) | ((lineCopy & 0x2) >> 1);
  tileBlock4[addressFlipped | 2] = tileBlock2[address | 2] = tileBlock3[addressFlipped | 5] = tileBlock1[address | 5] = ((lineCopy & 0x400) >> 9) | ((lineCopy & 0x4) >> 2);
  tileBlock4[addressFlipped | 3] = tileBlock2[address | 3] = tileBlock3[addressFlipped | 4] = tileBlock1[address | 4] = ((lineCopy & 0x800) >> 10) | ((lineCopy & 0x8) >> 3);
  tileBlock4[addressFlipped | 4] = tileBlock2[address | 4] = tileBlock3[addressFlipped | 3] = tileBlock1[address | 3] = ((lineCopy & 0x1000) >> 11) | ((lineCopy & 0x10) >> 4);
  tileBlock4[addressFlipped | 5] = tileBlock2[address | 5] = tileBlock3[addressFlipped | 2] = tileBlock1[address | 2] = ((lineCopy & 0x2000) >> 12) | ((lineCopy & 0x20) >> 5);
  tileBlock4[addressFlipped | 6] = tileBlock2[address | 6] = tileBlock3[addressFlipped | 1] = tileBlock1[address | 1] = ((lineCopy & 0x4000) >> 13) | ((lineCopy & 0x40) >> 6);
  tileBlock4[addressFlipped | 7] = tileBlock2[address | 7] = tileBlock3[addressFlipped] = tileBlock1[address] = ((lineCopy & 0x8000) >> 14) | ((lineCopy & 0x80) >> 7);
};
//Generate all the flip combinations for a full GBC VRAM bank 1 tile:
GameBoyCore.prototype.generateGBCTileBank1 = function (vramAddress) {
  var address = vramAddress >> 4;
  var tileBlock1 = this.tileCache[address];
  var tileBlock2 = this.tileCache[0x200 | address];
  var tileBlock3 = this.tileCache[0x400 | address];
  var tileBlock4 = this.tileCache[0x600 | address];
  var lineCopy = 0;
  vramAddress |= 0x8000;
  address = 0;
  var addressFlipped = 56;
  do {
    lineCopy = (this.memory[0x1 | vramAddress] << 8) | this.memory[vramAddress];
    tileBlock4[addressFlipped] = tileBlock2[address] = tileBlock3[addressFlipped | 7] = tileBlock1[address | 7] = ((lineCopy & 0x100) >> 7) | (lineCopy & 0x1);
    tileBlock4[addressFlipped | 1] = tileBlock2[address | 1] = tileBlock3[addressFlipped | 6] = tileBlock1[address | 6] = ((lineCopy & 0x200) >> 8) | ((lineCopy & 0x2) >> 1);
    tileBlock4[addressFlipped | 2] = tileBlock2[address | 2] = tileBlock3[addressFlipped | 5] = tileBlock1[address | 5] = ((lineCopy & 0x400) >> 9) | ((lineCopy & 0x4) >> 2);
    tileBlock4[addressFlipped | 3] = tileBlock2[address | 3] = tileBlock3[addressFlipped | 4] = tileBlock1[address | 4] = ((lineCopy & 0x800) >> 10) | ((lineCopy & 0x8) >> 3);
    tileBlock4[addressFlipped | 4] = tileBlock2[address | 4] = tileBlock3[addressFlipped | 3] = tileBlock1[address | 3] = ((lineCopy & 0x1000) >> 11) | ((lineCopy & 0x10) >> 4);
    tileBlock4[addressFlipped | 5] = tileBlock2[address | 5] = tileBlock3[addressFlipped | 2] = tileBlock1[address | 2] = ((lineCopy & 0x2000) >> 12) | ((lineCopy & 0x20) >> 5);
    tileBlock4[addressFlipped | 6] = tileBlock2[address | 6] = tileBlock3[addressFlipped | 1] = tileBlock1[address | 1] = ((lineCopy & 0x4000) >> 13) | ((lineCopy & 0x40) >> 6);
    tileBlock4[addressFlipped | 7] = tileBlock2[address | 7] = tileBlock3[addressFlipped] = tileBlock1[address] = ((lineCopy & 0x8000) >> 14) | ((lineCopy & 0x80) >> 7);
    address += 8;
    addressFlipped -= 8;
    vramAddress += 2;
  } while (addressFlipped > -1);
};
//Generate only a single tile line for the GBC tile cache mode (Bank 2):
GameBoyCore.prototype.generateGBCTileLineBank2 = function (address) {
  var lineCopy = (this.VRAM[0x1 | address] << 8) | this.VRAM[0x1FFE & address];
  var tileBlock1 = this.tileCache[0x800 | (address >> 4)];
  var tileBlock2 = this.tileCache[0xA00 | (address >> 4)];
  var tileBlock3 = this.tileCache[0xC00 | (address >> 4)];
  var tileBlock4 = this.tileCache[0xE00 | (address >> 4)];
  address = (address & 0xE) << 2;
  var addressFlipped = 0x38 - address;
  tileBlock4[addressFlipped] = tileBlock2[address] = tileBlock3[addressFlipped | 7] = tileBlock1[address | 7] = ((lineCopy & 0x100) >> 7) | (lineCopy & 0x1);
  tileBlock4[addressFlipped | 1] = tileBlock2[address | 1] = tileBlock3[addressFlipped | 6] = tileBlock1[address | 6] = ((lineCopy & 0x200) >> 8) | ((lineCopy & 0x2) >> 1);
  tileBlock4[addressFlipped | 2] = tileBlock2[address | 2] = tileBlock3[addressFlipped | 5] = tileBlock1[address | 5] = ((lineCopy & 0x400) >> 9) | ((lineCopy & 0x4) >> 2);
  tileBlock4[addressFlipped | 3] = tileBlock2[address | 3] = tileBlock3[addressFlipped | 4] = tileBlock1[address | 4] = ((lineCopy & 0x800) >> 10) | ((lineCopy & 0x8) >> 3);
  tileBlock4[addressFlipped | 4] = tileBlock2[address | 4] = tileBlock3[addressFlipped | 3] = tileBlock1[address | 3] = ((lineCopy & 0x1000) >> 11) | ((lineCopy & 0x10) >> 4);
  tileBlock4[addressFlipped | 5] = tileBlock2[address | 5] = tileBlock3[addressFlipped | 2] = tileBlock1[address | 2] = ((lineCopy & 0x2000) >> 12) | ((lineCopy & 0x20) >> 5);
  tileBlock4[addressFlipped | 6] = tileBlock2[address | 6] = tileBlock3[addressFlipped | 1] = tileBlock1[address | 1] = ((lineCopy & 0x4000) >> 13) | ((lineCopy & 0x40) >> 6);
  tileBlock4[addressFlipped | 7] = tileBlock2[address | 7] = tileBlock3[addressFlipped] = tileBlock1[address] = ((lineCopy & 0x8000) >> 14) | ((lineCopy & 0x80) >> 7);
};
//Generate all the flip combinations for a full GBC VRAM bank 2 tile:
GameBoyCore.prototype.generateGBCTileBank2 = function (vramAddress) {
  var address = vramAddress >> 4;
  var tileBlock1 = this.tileCache[0x800 | address];
  var tileBlock2 = this.tileCache[0xA00 | address];
  var tileBlock3 = this.tileCache[0xC00 | address];
  var tileBlock4 = this.tileCache[0xE00 | address];
  var lineCopy = 0;
  address = 0;
  var addressFlipped = 56;
  do {
    lineCopy = (this.VRAM[0x1 | vramAddress] << 8) | this.VRAM[vramAddress];
    tileBlock4[addressFlipped] = tileBlock2[address] = tileBlock3[addressFlipped | 7] = tileBlock1[address | 7] = ((lineCopy & 0x100) >> 7) | (lineCopy & 0x1);
    tileBlock4[addressFlipped | 1] = tileBlock2[address | 1] = tileBlock3[addressFlipped | 6] = tileBlock1[address | 6] = ((lineCopy & 0x200) >> 8) | ((lineCopy & 0x2) >> 1);
    tileBlock4[addressFlipped | 2] = tileBlock2[address | 2] = tileBlock3[addressFlipped | 5] = tileBlock1[address | 5] = ((lineCopy & 0x400) >> 9) | ((lineCopy & 0x4) >> 2);
    tileBlock4[addressFlipped | 3] = tileBlock2[address | 3] = tileBlock3[addressFlipped | 4] = tileBlock1[address | 4] = ((lineCopy & 0x800) >> 10) | ((lineCopy & 0x8) >> 3);
    tileBlock4[addressFlipped | 4] = tileBlock2[address | 4] = tileBlock3[addressFlipped | 3] = tileBlock1[address | 3] = ((lineCopy & 0x1000) >> 11) | ((lineCopy & 0x10) >> 4);
    tileBlock4[addressFlipped | 5] = tileBlock2[address | 5] = tileBlock3[addressFlipped | 2] = tileBlock1[address | 2] = ((lineCopy & 0x2000) >> 12) | ((lineCopy & 0x20) >> 5);
    tileBlock4[addressFlipped | 6] = tileBlock2[address | 6] = tileBlock3[addressFlipped | 1] = tileBlock1[address | 1] = ((lineCopy & 0x4000) >> 13) | ((lineCopy & 0x40) >> 6);
    tileBlock4[addressFlipped | 7] = tileBlock2[address | 7] = tileBlock3[addressFlipped] = tileBlock1[address] = ((lineCopy & 0x8000) >> 14) | ((lineCopy & 0x80) >> 7);
    address += 8;
    addressFlipped -= 8;
    vramAddress += 2;
  } while (addressFlipped > -1);
};
//Generate only a single tile line for the GB tile cache mode (OAM accessible range):
GameBoyCore.prototype.generateGBOAMTileLine = function (address) {
  var lineCopy = (this.memory[0x1 | address] << 8) | this.memory[0x9FFE & address];
  address &= 0x1FFE;
  var tileBlock1 = this.tileCache[address >> 4];
  var tileBlock2 = this.tileCache[0x200 | (address >> 4)];
  var tileBlock3 = this.tileCache[0x400 | (address >> 4)];
  var tileBlock4 = this.tileCache[0x600 | (address >> 4)];
  address = (address & 0xE) << 2;
  var addressFlipped = 0x38 - address;
  tileBlock4[addressFlipped] = tileBlock2[address] = tileBlock3[addressFlipped | 7] = tileBlock1[address | 7] = ((lineCopy & 0x100) >> 7) | (lineCopy & 0x1);
  tileBlock4[addressFlipped | 1] = tileBlock2[address | 1] = tileBlock3[addressFlipped | 6] = tileBlock1[address | 6] = ((lineCopy & 0x200) >> 8) | ((lineCopy & 0x2) >> 1);
  tileBlock4[addressFlipped | 2] = tileBlock2[address | 2] = tileBlock3[addressFlipped | 5] = tileBlock1[address | 5] = ((lineCopy & 0x400) >> 9) | ((lineCopy & 0x4) >> 2);
  tileBlock4[addressFlipped | 3] = tileBlock2[address | 3] = tileBlock3[addressFlipped | 4] = tileBlock1[address | 4] = ((lineCopy & 0x800) >> 10) | ((lineCopy & 0x8) >> 3);
  tileBlock4[addressFlipped | 4] = tileBlock2[address | 4] = tileBlock3[addressFlipped | 3] = tileBlock1[address | 3] = ((lineCopy & 0x1000) >> 11) | ((lineCopy & 0x10) >> 4);
  tileBlock4[addressFlipped | 5] = tileBlock2[address | 5] = tileBlock3[addressFlipped | 2] = tileBlock1[address | 2] = ((lineCopy & 0x2000) >> 12) | ((lineCopy & 0x20) >> 5);
  tileBlock4[addressFlipped | 6] = tileBlock2[address | 6] = tileBlock3[addressFlipped | 1] = tileBlock1[address | 1] = ((lineCopy & 0x4000) >> 13) | ((lineCopy & 0x40) >> 6);
  tileBlock4[addressFlipped | 7] = tileBlock2[address | 7] = tileBlock3[addressFlipped] = tileBlock1[address] = ((lineCopy & 0x8000) >> 14) | ((lineCopy & 0x80) >> 7);
};
GameBoyCore.prototype.graphicsJIT = function () {
  if (this.LCDisOn) {
    this.totalLinesPassed = 0;      //Mark frame for ensuring a JIT pass for the next framebuffer output.
    this.graphicsJITScanlineGroup();
  }
};
GameBoyCore.prototype.graphicsJITVBlank = function () {
  //JIT the graphics to v-blank framing:
  this.totalLinesPassed += this.queuedScanLines;
  this.graphicsJITScanlineGroup();
};
GameBoyCore.prototype.graphicsJITScanlineGroup = function () {
  //Normal rendering JIT, where we try to do groups of scanlines at once:
  while (this.queuedScanLines > 0) {
    this.renderScanLine(this.lastUnrenderedLine);
    if (this.lastUnrenderedLine < 143) {
      ++this.lastUnrenderedLine;
    }
    else {
      this.lastUnrenderedLine = 0;
    }
    --this.queuedScanLines;
  }
};
GameBoyCore.prototype.incrementScanLineQueue = function () {
  if (this.queuedScanLines < 144) {
    ++this.queuedScanLines;
  }
  else {
    this.currentX = 0;
    this.midScanlineOffset = -1;
    if (this.lastUnrenderedLine < 143) {
      ++this.lastUnrenderedLine;
    }
    else {
      this.lastUnrenderedLine = 0;
    }
  }
};
GameBoyCore.prototype.midScanLineJIT = function () {
  this.graphicsJIT();
  this.renderMidScanLine();
};
//Check for the highest priority IRQ to fire:
GameBoyCore.prototype.launchIRQ = function () {
  var bitShift = 0;
  var testbit = 1;
  do {
    //Check to see if an interrupt is enabled AND requested.
    if ((testbit & this.IRQLineMatched) == testbit) {
      this.IME = false;           //Reset the interrupt enabling.
      this.interruptsRequested -= testbit;  //Reset the interrupt request.
      this.IRQLineMatched = 0;        //Reset the IRQ assertion.
      //Interrupts have a certain clock cycle length:
      this.CPUTicks = 20;
      //Set the stack pointer to the current program counter value:
      this.stackPointer = (this.stackPointer - 1) & 0xFFFF;
      this.memoryWriter[this.stackPointer](this, this.stackPointer, this.programCounter >> 8);
      this.stackPointer = (this.stackPointer - 1) & 0xFFFF;
      this.memoryWriter[this.stackPointer](this, this.stackPointer, this.programCounter & 0xFF);
      //Set the program counter to the interrupt's address:
      this.programCounter = 0x40 | (bitShift << 3);
      //Clock the core for mid-instruction updates:
      this.updateCore();
      return;                 //We only want the highest priority interrupt.
    }
    testbit = 1 << ++bitShift;
  } while (bitShift < 5);
};
/*
  Check for IRQs to be fired while not in HALT:
*/
GameBoyCore.prototype.checkIRQMatching = function () {
  if (this.IME) {
    this.IRQLineMatched = this.interruptsEnabled & this.interruptsRequested & 0x1F;
  }
};
/*
  Handle the HALT opcode by predicting all IRQ cases correctly,
  then selecting the next closest IRQ firing from the prediction to
  clock up to. This prevents hacky looping that doesn't predict, but
  instead just clocks through the core update procedure by one which
  is very slow. Not many emulators do this because they have to cover
  all the IRQ prediction cases and they usually get them wrong.
*/
GameBoyCore.prototype.calculateHALTPeriod = function () {
  //Initialize our variables and start our prediction:
  var currentClocks;
  if (!this.halt) {
    this.halt = true;
    currentClocks = -1;
    var temp_var = 0;
    if (this.LCDisOn) {
      //If the LCD is enabled, then predict the LCD IRQs enabled:
      if ((this.interruptsEnabled & 0x1) == 0x1) {
        currentClocks = ((456 * (((this.modeSTAT == 1) ? 298 : 144) - this.actualScanLine)) - this.LCDTicks) << this.doubleSpeedShifter;
      }
      if ((this.interruptsEnabled & 0x2) == 0x2) {
        if (this.mode0TriggerSTAT) {
          temp_var = (this.clocksUntilMode0() - this.LCDTicks) << this.doubleSpeedShifter;
          if (temp_var <= currentClocks || currentClocks == -1) {
            currentClocks = temp_var;
          }
        }
        if (this.mode1TriggerSTAT && (this.interruptsEnabled & 0x1) == 0) {
          temp_var = ((456 * (((this.modeSTAT == 1) ? 298 : 144) - this.actualScanLine)) - this.LCDTicks) << this.doubleSpeedShifter;
          if (temp_var <= currentClocks || currentClocks == -1) {
            currentClocks = temp_var;
          }
        }
        if (this.mode2TriggerSTAT) {
          temp_var = (((this.actualScanLine >= 143) ? (456 * (154 - this.actualScanLine)) : 456) - this.LCDTicks) << this.doubleSpeedShifter;
          if (temp_var <= currentClocks || currentClocks == -1) {
            currentClocks = temp_var;
          }
        }
        if (this.LYCMatchTriggerSTAT && this.memory[0xFF45] <= 153) {
          temp_var = (this.clocksUntilLYCMatch() - this.LCDTicks) << this.doubleSpeedShifter;
          if (temp_var <= currentClocks || currentClocks == -1) {
            currentClocks = temp_var;
          }
        }
      }
    }
    if (this.TIMAEnabled && (this.interruptsEnabled & 0x4) == 0x4) {
      //CPU timer IRQ prediction:
      temp_var = ((0x100 - this.memory[0xFF05]) * this.TACClocker) - this.timerTicks;
      if (temp_var <= currentClocks || currentClocks == -1) {
        currentClocks = temp_var;
      }
    }
    if (this.serialTimer > 0 && (this.interruptsEnabled & 0x8) == 0x8) {
      //Serial IRQ prediction:
      if (this.serialTimer <= currentClocks || currentClocks == -1) {
        currentClocks = this.serialTimer;
      }
    }
  }
  else {
    currentClocks = this.remainingClocks;
  }
  var maxClocks = (this.CPUCyclesTotal - this.emulatorTicks) << this.doubleSpeedShifter;
  if (currentClocks >= 0) {
    if (currentClocks <= maxClocks) {
      //Exit out of HALT normally:
      this.CPUTicks = Math.max(currentClocks, this.CPUTicks);
      this.updateCoreFull();
      this.halt = false;
      this.CPUTicks = 0;
    }
    else {
      //Still in HALT, clock only up to the clocks specified per iteration:
      this.CPUTicks = Math.max(maxClocks, this.CPUTicks);
      this.remainingClocks = currentClocks - this.CPUTicks;
    }
  }
  else {
    //Still in HALT, clock only up to the clocks specified per iteration:
    //Will stay in HALT forever (Stuck in HALT forever), but the APU and LCD are still clocked, so don't pause:
    this.CPUTicks += maxClocks;
  }
};
//Memory Reading:
GameBoyCore.prototype.memoryRead = function (address) {
  //Act as a wrapper for reading the returns from the compiled jumps to memory.
  return this.memoryReader[address](this, address); //This seems to be faster than the usual if/else.
};
GameBoyCore.prototype.memoryHighRead = function (address) {
  //Act as a wrapper for reading the returns from the compiled jumps to memory.
  return this.memoryHighReader[address](this, address); //This seems to be faster than the usual if/else.
};
GameBoyCore.prototype.memoryReadJumpCompile = function () {
  //Faster in some browsers, since we are doing less conditionals overall by implementing them in advance.
  for (var index = 0x0000; index <= 0xFFFF; index++) {
    if (index < 0x4000) {
      this.memoryReader[index] = this.memoryReadNormal;
    }
    else if (index < 0x8000) {
      this.memoryReader[index] = this.memoryReadROM;
    }
    else if (index < 0x9800) {
      this.memoryReader[index] = (this.cGBC) ? this.VRAMDATAReadCGBCPU : this.VRAMDATAReadDMGCPU;
    }
    else if (index < 0xA000) {
      this.memoryReader[index] = (this.cGBC) ? this.VRAMCHRReadCGBCPU : this.VRAMCHRReadDMGCPU;
    }
    else if (index >= 0xA000 && index < 0xC000) {
      if ((this.numRAMBanks == 1 / 16 && index < 0xA200) || this.numRAMBanks >= 1) {
        if (this.cMBC7) {
          this.memoryReader[index] = this.memoryReadMBC7;
        }
        else if (!this.cMBC3) {
          this.memoryReader[index] = this.memoryReadMBC;
        }
        else {
          //MBC3 RTC + RAM:
          this.memoryReader[index] = this.memoryReadMBC3;
        }
      }
      else {
        this.memoryReader[index] = this.memoryReadBAD;
      }
    }
    else if (index >= 0xC000 && index < 0xE000) {
      if (!this.cGBC || index < 0xD000) {
        this.memoryReader[index] = this.memoryReadNormal;
      }
      else {
        this.memoryReader[index] = this.memoryReadGBCMemory;
      }
    }
    else if (index >= 0xE000 && index < 0xFE00) {
      if (!this.cGBC || index < 0xF000) {
        this.memoryReader[index] = this.memoryReadECHONormal;
      }
      else {
        this.memoryReader[index] = this.memoryReadECHOGBCMemory;
      }
    }
    else if (index < 0xFEA0) {
      this.memoryReader[index] = this.memoryReadOAM;
    }
    else if (this.cGBC && index >= 0xFEA0 && index < 0xFF00) {
      this.memoryReader[index] = this.memoryReadNormal;
    }
    else if (index >= 0xFF00) {
      switch (index) {
        case 0xFF00:
          //JOYPAD:
          this.memoryHighReader[0] = this.memoryReader[0xFF00] = function (parentObj, address) {
            return 0xC0 | parentObj.memory[0xFF00]; //Top nibble returns as set.
          };
          break;
        case 0xFF01:
          //SB
          this.memoryHighReader[0x01] = this.memoryReader[0xFF01] = function (parentObj, address) {
            return (parentObj.memory[0xFF02] < 0x80) ? parentObj.memory[0xFF01] : 0xFF;
          };
          break;
        case 0xFF02:
          //SC
          if (this.cGBC) {
            this.memoryHighReader[0x02] = this.memoryReader[0xFF02] = function (parentObj, address) {
              return ((parentObj.serialTimer <= 0) ? 0x7C : 0xFC) | parentObj.memory[0xFF02];
            };
          }
          else {
            this.memoryHighReader[0x02] = this.memoryReader[0xFF02] = function (parentObj, address) {
              return ((parentObj.serialTimer <= 0) ? 0x7E : 0xFE) | parentObj.memory[0xFF02];
            };
          }
          break;
        case 0xFF03:
          this.memoryHighReader[0x03] = this.memoryReader[0xFF03] = this.memoryReadBAD;
          break;
        case 0xFF04:
          //DIV
          this.memoryHighReader[0x04] = this.memoryReader[0xFF04] = function (parentObj, address) {
            parentObj.memory[0xFF04] = (parentObj.memory[0xFF04] + (parentObj.DIVTicks >> 8)) & 0xFF;
            parentObj.DIVTicks &= 0xFF;
            return parentObj.memory[0xFF04];
            
          };
          break;
        case 0xFF05:
        case 0xFF06:
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
          this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF07:
          this.memoryHighReader[0x07] = this.memoryReader[0xFF07] = function (parentObj, address) {
            return 0xF8 | parentObj.memory[0xFF07];
          };
          break;
        case 0xFF08:
        case 0xFF09:
        case 0xFF0A:
        case 0xFF0B:
        case 0xFF0C:
        case 0xFF0D:
        case 0xFF0E:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadBAD;
          break;
        case 0xFF0F:
          //IF
          this.memoryHighReader[0x0F] = this.memoryReader[0xFF0F] = function (parentObj, address) {
            return 0xE0 | parentObj.interruptsRequested;
          };
          break;
        case 0xFF10:
          this.memoryHighReader[0x10] = this.memoryReader[0xFF10] = function (parentObj, address) {
            return 0x80 | parentObj.memory[0xFF10];
          };
          break;
        case 0xFF11:
          this.memoryHighReader[0x11] = this.memoryReader[0xFF11] = function (parentObj, address) {
            return 0x3F | parentObj.memory[0xFF11];
          };
          break;
        case 0xFF12:
          this.memoryHighReader[0x12] = this.memoryHighReadNormal;
          this.memoryReader[0xFF12] = this.memoryReadNormal;
          break;
        case 0xFF13:
          this.memoryHighReader[0x13] = this.memoryReader[0xFF13] = this.memoryReadBAD;
          break;
        case 0xFF14:
          this.memoryHighReader[0x14] = this.memoryReader[0xFF14] = function (parentObj, address) {
            return 0xBF | parentObj.memory[0xFF14];
          };
          break;
        case 0xFF15:
          this.memoryHighReader[0x15] = this.memoryReadBAD;
          this.memoryReader[0xFF15] = this.memoryReadBAD;
          break;
        case 0xFF16:
          this.memoryHighReader[0x16] = this.memoryReader[0xFF16] = function (parentObj, address) {
            return 0x3F | parentObj.memory[0xFF16];
          };
          break;
        case 0xFF17:
          this.memoryHighReader[0x17] = this.memoryHighReadNormal;
          this.memoryReader[0xFF17] = this.memoryReadNormal;
          break;
        case 0xFF18:
          this.memoryHighReader[0x18] = this.memoryReader[0xFF18] = this.memoryReadBAD;
          break;
        case 0xFF19:
          this.memoryHighReader[0x19] = this.memoryReader[0xFF19] = function (parentObj, address) {
            return 0xBF | parentObj.memory[0xFF19];
          };
          break;
        case 0xFF1A:
          this.memoryHighReader[0x1A] = this.memoryReader[0xFF1A] = function (parentObj, address) {
            return 0x7F | parentObj.memory[0xFF1A];
          };
          break;
        case 0xFF1B:
          this.memoryHighReader[0x1B] = this.memoryReader[0xFF1B] = this.memoryReadBAD;
          break;
        case 0xFF1C:
          this.memoryHighReader[0x1C] = this.memoryReader[0xFF1C] = function (parentObj, address) {
            return 0x9F | parentObj.memory[0xFF1C];
          };
          break;
        case 0xFF1D:
          this.memoryHighReader[0x1D] = this.memoryReader[0xFF1D] = this.memoryReadBAD;
          break;
        case 0xFF1E:
          this.memoryHighReader[0x1E] = this.memoryReader[0xFF1E] = function (parentObj, address) {
            return 0xBF | parentObj.memory[0xFF1E];
          };
          break;
        case 0xFF1F:
        case 0xFF20:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadBAD;
          break;
        case 0xFF21:
        case 0xFF22:
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
          this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF23:
          this.memoryHighReader[0x23] = this.memoryReader[0xFF23] = function (parentObj, address) {
            return 0xBF | parentObj.memory[0xFF23];
          };
          break;
        case 0xFF24:
        case 0xFF25:
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
          this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF26:
          this.memoryHighReader[0x26] = this.memoryReader[0xFF26] = function (parentObj, address) {
            parentObj.audioJIT();
            return 0x70 | parentObj.memory[0xFF26];
          };
          break;
        case 0xFF27:
        case 0xFF28:
        case 0xFF29:
        case 0xFF2A:
        case 0xFF2B:
        case 0xFF2C:
        case 0xFF2D:
        case 0xFF2E:
        case 0xFF2F:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadBAD;
          break;
        case 0xFF30:
        case 0xFF31:
        case 0xFF32:
        case 0xFF33:
        case 0xFF34:
        case 0xFF35:
        case 0xFF36:
        case 0xFF37:
        case 0xFF38:
        case 0xFF39:
        case 0xFF3A:
        case 0xFF3B:
        case 0xFF3C:
        case 0xFF3D:
        case 0xFF3E:
        case 0xFF3F:
          this.memoryReader[index] = function (parentObj, address) {
            return (parentObj.channel3canPlay) ? parentObj.memory[0xFF00 | (parentObj.channel3lastSampleLookup >> 1)] : parentObj.memory[address];
          };
          this.memoryHighReader[index & 0xFF] = function (parentObj, address) {
            return (parentObj.channel3canPlay) ? parentObj.memory[0xFF00 | (parentObj.channel3lastSampleLookup >> 1)] : parentObj.memory[0xFF00 | address];
          };
          break;
        case 0xFF40:
          this.memoryHighReader[0x40] = this.memoryHighReadNormal;
          this.memoryReader[0xFF40] = this.memoryReadNormal;
          break;
        case 0xFF41:
          this.memoryHighReader[0x41] = this.memoryReader[0xFF41] = function (parentObj, address) {
            return 0x80 | parentObj.memory[0xFF41] | parentObj.modeSTAT;
          };
          break;
        case 0xFF42:
          this.memoryHighReader[0x42] = this.memoryReader[0xFF42] = function (parentObj, address) {
            return parentObj.backgroundY;
          };
          break;
        case 0xFF43:
          this.memoryHighReader[0x43] = this.memoryReader[0xFF43] = function (parentObj, address) {
            return parentObj.backgroundX;
          };
          break;
        case 0xFF44:
          this.memoryHighReader[0x44] = this.memoryReader[0xFF44] = function (parentObj, address) {
            return ((parentObj.LCDisOn) ? parentObj.memory[0xFF44] : 0);
          };
          break;
        case 0xFF45:
        case 0xFF46:
        case 0xFF47:
        case 0xFF48:
        case 0xFF49:
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
          this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF4A:
          //WY
          this.memoryHighReader[0x4A] = this.memoryReader[0xFF4A] = function (parentObj, address) {
            return parentObj.windowY;
          };
          break;
        case 0xFF4B:
          this.memoryHighReader[0x4B] = this.memoryHighReadNormal;
          this.memoryReader[0xFF4B] = this.memoryReadNormal;
          break;
        case 0xFF4C:
          this.memoryHighReader[0x4C] = this.memoryReader[0xFF4C] = this.memoryReadBAD;
          break;
        case 0xFF4D:
          this.memoryHighReader[0x4D] = this.memoryHighReadNormal;
          this.memoryReader[0xFF4D] = this.memoryReadNormal;
          break;
        case 0xFF4E:
          this.memoryHighReader[0x4E] = this.memoryReader[0xFF4E] = this.memoryReadBAD;
          break;
        case 0xFF4F:
          this.memoryHighReader[0x4F] = this.memoryReader[0xFF4F] = function (parentObj, address) {
            return parentObj.currVRAMBank;
          };
          break;
        case 0xFF50:
        case 0xFF51:
        case 0xFF52:
        case 0xFF53:
        case 0xFF54:
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
          this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF55:
          if (this.cGBC) {
            this.memoryHighReader[0x55] = this.memoryReader[0xFF55] = function (parentObj, address) {
              if (!parentObj.LCDisOn && parentObj.hdmaRunning) {  //Undocumented behavior alert: HDMA becomes GDMA when LCD is off (Worms Armageddon Fix).
                //DMA
                parentObj.DMAWrite((parentObj.memory[0xFF55] & 0x7F) + 1);
                parentObj.memory[0xFF55] = 0xFF;  //Transfer completed.
                parentObj.hdmaRunning = false;
              }
              return parentObj.memory[0xFF55];
            };
          }
          else {
            this.memoryReader[0xFF55] = this.memoryReadNormal;
            this.memoryHighReader[0x55] = this.memoryHighReadNormal;
          }
          break;
        case 0xFF56:
          if (this.cGBC) {
            this.memoryHighReader[0x56] = this.memoryReader[0xFF56] = function (parentObj, address) {
              //Return IR "not connected" status:
              return 0x3C | ((parentObj.memory[0xFF56] >= 0xC0) ? (0x2 | (parentObj.memory[0xFF56] & 0xC1)) : (parentObj.memory[0xFF56] & 0xC3));
            };
          }
          else {
            this.memoryReader[0xFF56] = this.memoryReadNormal;
            this.memoryHighReader[0x56] = this.memoryHighReadNormal;
          }
          break;
        case 0xFF57:
        case 0xFF58:
        case 0xFF59:
        case 0xFF5A:
        case 0xFF5B:
        case 0xFF5C:
        case 0xFF5D:
        case 0xFF5E:
        case 0xFF5F:
        case 0xFF60:
        case 0xFF61:
        case 0xFF62:
        case 0xFF63:
        case 0xFF64:
        case 0xFF65:
        case 0xFF66:
        case 0xFF67:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadBAD;
          break;
        case 0xFF68:
        case 0xFF69:
        case 0xFF6A:
        case 0xFF6B:
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
          this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF6C:
          if (this.cGBC) {
            this.memoryHighReader[0x6C] = this.memoryReader[0xFF6C] = function (parentObj, address) {
              return 0xFE | parentObj.memory[0xFF6C];
            };
          }
          else {
            this.memoryHighReader[0x6C] = this.memoryReader[0xFF6C] = this.memoryReadBAD;
          }
          break;
        case 0xFF6D:
        case 0xFF6E:
        case 0xFF6F:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadBAD;
          break;
        case 0xFF70:
          if (this.cGBC) {
            //SVBK
            this.memoryHighReader[0x70] = this.memoryReader[0xFF70] = function (parentObj, address) {
              return 0x40 | parentObj.memory[0xFF70];
            };
          }
          else {
            this.memoryHighReader[0x70] = this.memoryReader[0xFF70] = this.memoryReadBAD;
          }
          break;
        case 0xFF71:
          this.memoryHighReader[0x71] = this.memoryReader[0xFF71] = this.memoryReadBAD;
          break;
        case 0xFF72:
        case 0xFF73:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadNormal;
          break;
        case 0xFF74:
          if (this.cGBC) {
            this.memoryHighReader[0x74] = this.memoryReader[0xFF74] = this.memoryReadNormal;
          }
          else {
            this.memoryHighReader[0x74] = this.memoryReader[0xFF74] = this.memoryReadBAD;
          }
          break;
        case 0xFF75:
          this.memoryHighReader[0x75] = this.memoryReader[0xFF75] = function (parentObj, address) {
            return 0x8F | parentObj.memory[0xFF75];
          };
          break;
        case 0xFF76:
        case 0xFF77:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = function (parentObj, address) {
            return 0;
          };
          break;
        case 0xFF78:
        case 0xFF79:
        case 0xFF7A:
        case 0xFF7B:
        case 0xFF7C:
        case 0xFF7D:
        case 0xFF7E:
        case 0xFF7F:
          this.memoryHighReader[index & 0xFF] = this.memoryReader[index] = this.memoryReadBAD;
          break;
        case 0xFFFF:
          //IE
          this.memoryHighReader[0xFF] = this.memoryReader[0xFFFF] = function (parentObj, address) {
            return parentObj.interruptsEnabled;
          };
          break;
        default:
          this.memoryReader[index] = this.memoryReadNormal;
          this.memoryHighReader[index & 0xFF] = this.memoryHighReadNormal;
      }
    }
    else {
      this.memoryReader[index] = this.memoryReadBAD;
    }
  }
};
GameBoyCore.prototype.memoryReadNormal = function (parentObj, address) {
  return parentObj.memory[address];
};
GameBoyCore.prototype.memoryHighReadNormal = function (parentObj, address) {
  return parentObj.memory[0xFF00 | address];
};
GameBoyCore.prototype.memoryReadROM = function (parentObj, address) {
  return parentObj.ROM[parentObj.currentROMBank + address];
};
GameBoyCore.prototype.memoryReadMBC = function (parentObj, address) {
  //Switchable RAM
  //[jf] changed "this" to "parentObj" below
  if (parentObj.MBCRAMBanksEnabled || parentObj.opts.overrideMbc) {
    return parentObj.MBCRam[address + parentObj.currMBCRAMBankPosition];
  }
  //debug("Reading from disabled RAM.", 1);
  return 0xFF;
};
GameBoyCore.prototype.memoryReadMBC7 = function (parentObj, address) {
  //Switchable RAM
  //[jf] changed "this" to "parentObj" below
  if (parentObj.MBCRAMBanksEnabled || parentObj.opts.overrideMbc) {
    switch (address) {
      case 0xA000:
      case 0xA060:
      case 0xA070:
        return 0;
      case 0xA080:
        //TODO: Gyro Control Register
        return 0;
      case 0xA050:
        //Y High Byte
        return parentObj.highY;
      case 0xA040:
        //Y Low Byte
        return parentObj.lowY;
      case 0xA030:
        //X High Byte
        return parentObj.highX;
      case 0xA020:
        //X Low Byte:
        return parentObj.lowX;
      default:
        return parentObj.MBCRam[address + parentObj.currMBCRAMBankPosition];
    }
  }
  //debug("Reading from disabled RAM.", 1);
  return 0xFF;
};
GameBoyCore.prototype.memoryReadMBC3 = function (parentObj, address) {
  //Switchable RAM
  //[jf] changed "this" to "parentObj" below
  if (parentObj.MBCRAMBanksEnabled || parentObj.opts.overrideMbc) {
    switch (parentObj.currMBCRAMBank) {
      case 0x00:
      case 0x01:
      case 0x02:
      case 0x03:
        return parentObj.MBCRam[address + parentObj.currMBCRAMBankPosition];
      case 0x08:
        return parentObj.latchedSeconds;
      case 0x09:
        return parentObj.latchedMinutes;
      case 0x0A:
        return parentObj.latchedHours;
      case 0x0B:
        return parentObj.latchedLDays;
      case 0x0C:
        return (((parentObj.RTCDayOverFlow) ? 0x80 : 0) + ((parentObj.RTCHALT) ? 0x40 : 0)) + parentObj.latchedHDays;
    }
  }
  //debug("Reading from invalid or disabled RAM.", 1);
  return 0xFF;
};
GameBoyCore.prototype.memoryReadGBCMemory = function (parentObj, address) {
  return parentObj.GBCMemory[address + parentObj.gbcRamBankPosition];
};
GameBoyCore.prototype.memoryReadOAM = function (parentObj, address) {
  return (parentObj.modeSTAT > 1) ?  0xFF : parentObj.memory[address];
};
GameBoyCore.prototype.memoryReadECHOGBCMemory = function (parentObj, address) {
  return parentObj.GBCMemory[address + parentObj.gbcRamBankPositionECHO];
};
GameBoyCore.prototype.memoryReadECHONormal = function (parentObj, address) {
  return parentObj.memory[address - 0x2000];
};
GameBoyCore.prototype.memoryReadBAD = function (parentObj, address) {
  return 0xFF;
};
GameBoyCore.prototype.VRAMDATAReadCGBCPU = function (parentObj, address) {
  //CPU Side Reading The VRAM (Optimized for GameBoy Color)
  return (parentObj.modeSTAT > 2) ? 0xFF : ((parentObj.currVRAMBank == 0) ? parentObj.memory[address] : parentObj.VRAM[address & 0x1FFF]);
};
GameBoyCore.prototype.VRAMDATAReadDMGCPU = function (parentObj, address) {
  //CPU Side Reading The VRAM (Optimized for classic GameBoy)
  return (parentObj.modeSTAT > 2) ? 0xFF : parentObj.memory[address];
};
GameBoyCore.prototype.VRAMCHRReadCGBCPU = function (parentObj, address) {
  //CPU Side Reading the Character Data Map:
  return (parentObj.modeSTAT > 2) ? 0xFF : parentObj.BGCHRCurrentBank[address & 0x7FF];
};
GameBoyCore.prototype.VRAMCHRReadDMGCPU = function (parentObj, address) {
  //CPU Side Reading the Character Data Map:
  return (parentObj.modeSTAT > 2) ? 0xFF : parentObj.BGCHRBank1[address & 0x7FF];
};
GameBoyCore.prototype.setCurrentMBC1ROMBank = function () {
  //Read the cartridge ROM data from RAM memory:
  switch (this.ROMBank1offs) {
    case 0x00:
    case 0x20:
    case 0x40:
    case 0x60:
      //Bank calls for 0x00, 0x20, 0x40, and 0x60 are really for 0x01, 0x21, 0x41, and 0x61.
      this.currentROMBank = (this.ROMBank1offs % this.ROMBankEdge) << 14;
      break;
    default:
      this.currentROMBank = ((this.ROMBank1offs % this.ROMBankEdge) - 1) << 14;
  }
};
GameBoyCore.prototype.setCurrentMBC2AND3ROMBank = function () {
  //Read the cartridge ROM data from RAM memory:
  //Only map bank 0 to bank 1 here (MBC2 is like MBC1, but can only do 16 banks, so only the bank 0 quirk appears for MBC2):
  this.currentROMBank = Math.max((this.ROMBank1offs % this.ROMBankEdge) - 1, 0) << 14;
};
GameBoyCore.prototype.setCurrentMBC5ROMBank = function () {
  //Read the cartridge ROM data from RAM memory:
  this.currentROMBank = ((this.ROMBank1offs % this.ROMBankEdge) - 1) << 14;
};
//Memory Writing:
GameBoyCore.prototype.memoryWrite = function (address, data) {
  //Act as a wrapper for writing by compiled jumps to specific memory writing functions.
  this.memoryWriter[address](this, address, data);
};
//0xFFXX fast path:
GameBoyCore.prototype.memoryHighWrite = function (address, data) {
  //Act as a wrapper for writing by compiled jumps to specific memory writing functions.
  this.memoryHighWriter[address](this, address, data);
};
GameBoyCore.prototype.memoryWriteJumpCompile = function () {
  //Faster in some browsers, since we are doing less conditionals overall by implementing them in advance.
  for (var index = 0x0000; index <= 0xFFFF; index++) {
    if (index < 0x8000) {
      if (this.cMBC1) {
        if (index < 0x2000) {
          this.memoryWriter[index] = this.MBCWriteEnable;
        }
        else if (index < 0x4000) {
          this.memoryWriter[index] = this.MBC1WriteROMBank;
        }
        else if (index < 0x6000) {
          this.memoryWriter[index] = this.MBC1WriteRAMBank;
        }
        else {
          this.memoryWriter[index] = this.MBC1WriteType;
        }
      }
      else if (this.cMBC2) {
        if (index < 0x1000) {
          this.memoryWriter[index] = this.MBCWriteEnable;
        }
        else if (index >= 0x2100 && index < 0x2200) {
          this.memoryWriter[index] = this.MBC2WriteROMBank;
        }
        else {
          this.memoryWriter[index] = this.cartIgnoreWrite;
        }
      }
      else if (this.cMBC3) {
        if (index < 0x2000) {
          this.memoryWriter[index] = this.MBCWriteEnable;
        }
        else if (index < 0x4000) {
          this.memoryWriter[index] = this.MBC3WriteROMBank;
        }
        else if (index < 0x6000) {
          this.memoryWriter[index] = this.MBC3WriteRAMBank;
        }
        else {
          this.memoryWriter[index] = this.MBC3WriteRTCLatch;
        }
      }
      else if (this.cMBC5 || this.cRUMBLE || this.cMBC7) {
        if (index < 0x2000) {
          this.memoryWriter[index] = this.MBCWriteEnable;
        }
        else if (index < 0x3000) {
          this.memoryWriter[index] = this.MBC5WriteROMBankLow;
        }
        else if (index < 0x4000) {
          this.memoryWriter[index] = this.MBC5WriteROMBankHigh;
        }
        else if (index < 0x6000) {
          this.memoryWriter[index] = (this.cRUMBLE) ? this.RUMBLEWriteRAMBank : this.MBC5WriteRAMBank;
        }
        else {
          this.memoryWriter[index] = this.cartIgnoreWrite;
        }
      }
      else if (this.cHuC3) {
        if (index < 0x2000) {
          this.memoryWriter[index] = this.MBCWriteEnable;
        }
        else if (index < 0x4000) {
          this.memoryWriter[index] = this.MBC3WriteROMBank;
        }
        else if (index < 0x6000) {
          this.memoryWriter[index] = this.HuC3WriteRAMBank;
        }
        else {
          this.memoryWriter[index] = this.cartIgnoreWrite;
        }
      }
      else {
        this.memoryWriter[index] = this.cartIgnoreWrite;
      }
    }
    else if (index < 0x9000) {
      this.memoryWriter[index] = (this.cGBC) ? this.VRAMGBCDATAWrite : this.VRAMGBDATAWrite;
    }
    else if (index < 0x9800) {
      this.memoryWriter[index] = (this.cGBC) ? this.VRAMGBCDATAWrite : this.VRAMGBDATAUpperWrite;
    }
    else if (index < 0xA000) {
      this.memoryWriter[index] = (this.cGBC) ? this.VRAMGBCCHRMAPWrite : this.VRAMGBCHRMAPWrite;
    }
    else if (index < 0xC000) {
      if ((this.numRAMBanks == 1 / 16 && index < 0xA200) || this.numRAMBanks >= 1) {
        if (!this.cMBC3) {
          this.memoryWriter[index] = this.memoryWriteMBCRAM;
        }
        else {
          //MBC3 RTC + RAM:
          this.memoryWriter[index] = this.memoryWriteMBC3RAM;
        }
      }
      else {
        this.memoryWriter[index] = this.cartIgnoreWrite;
      }
    }
    else if (index < 0xE000) {
      if (this.cGBC && index >= 0xD000) {
        this.memoryWriter[index] = this.memoryWriteGBCRAM;
      }
      else {
        this.memoryWriter[index] = this.memoryWriteNormal;
      }
    }
    else if (index < 0xFE00) {
      if (this.cGBC && index >= 0xF000) {
        this.memoryWriter[index] = this.memoryWriteECHOGBCRAM;
      }
      else {
        this.memoryWriter[index] = this.memoryWriteECHONormal;
      }
    }
    else if (index <= 0xFEA0) {
      this.memoryWriter[index] = this.memoryWriteOAMRAM;
    }
    else if (index < 0xFF00) {
      if (this.cGBC) {                      //Only GBC has access to this RAM.
        this.memoryWriter[index] = this.memoryWriteNormal;
      }
      else {
        this.memoryWriter[index] = this.cartIgnoreWrite;
      }
    }
    else {
      //Start the I/O initialization by filling in the slots as normal memory:
      this.memoryWriter[index] = this.memoryWriteNormal;
      this.memoryHighWriter[index & 0xFF] = this.memoryHighWriteNormal;
    }
  }
  this.registerWriteJumpCompile();        //Compile the I/O write functions separately...
};
GameBoyCore.prototype.MBCWriteEnable = function (parentObj, address, data) {
  //MBC RAM Bank Enable/Disable:
  parentObj.MBCRAMBanksEnabled = ((data & 0x0F) == 0x0A); //If lower nibble is 0x0A, then enable, otherwise disable.
};
GameBoyCore.prototype.MBC1WriteROMBank = function (parentObj, address, data) {
  //MBC1 ROM bank switching:
  parentObj.ROMBank1offs = (parentObj.ROMBank1offs & 0x60) | (data & 0x1F);
  parentObj.setCurrentMBC1ROMBank();
};
GameBoyCore.prototype.MBC1WriteRAMBank = function (parentObj, address, data) {
  //MBC1 RAM bank switching
  if (parentObj.MBC1Mode) {
    //4/32 Mode
    parentObj.currMBCRAMBank = data & 0x03;
    parentObj.currMBCRAMBankPosition = (parentObj.currMBCRAMBank << 13) - 0xA000;
  }
  else {
    //16/8 Mode
    parentObj.ROMBank1offs = ((data & 0x03) << 5) | (parentObj.ROMBank1offs & 0x1F);
    parentObj.setCurrentMBC1ROMBank();
  }
};
GameBoyCore.prototype.MBC1WriteType = function (parentObj, address, data) {
  //MBC1 mode setting:
  parentObj.MBC1Mode = ((data & 0x1) == 0x1);
  if (parentObj.MBC1Mode) {
    parentObj.ROMBank1offs &= 0x1F;
    parentObj.setCurrentMBC1ROMBank();
  }
  else {
    parentObj.currMBCRAMBank = 0;
    parentObj.currMBCRAMBankPosition = -0xA000;
  }
};
GameBoyCore.prototype.MBC2WriteROMBank = function (parentObj, address, data) {
  //MBC2 ROM bank switching:
  parentObj.ROMBank1offs = data & 0x0F;
  parentObj.setCurrentMBC2AND3ROMBank();
};
GameBoyCore.prototype.MBC3WriteROMBank = function (parentObj, address, data) {
  //MBC3 ROM bank switching:
  parentObj.ROMBank1offs = data & 0x7F;
  parentObj.setCurrentMBC2AND3ROMBank();
};
GameBoyCore.prototype.MBC3WriteRAMBank = function (parentObj, address, data) {
  parentObj.currMBCRAMBank = data;
  if (data < 4) {
    //MBC3 RAM bank switching
    parentObj.currMBCRAMBankPosition = (parentObj.currMBCRAMBank << 13) - 0xA000;
  }
};
GameBoyCore.prototype.MBC3WriteRTCLatch = function (parentObj, address, data) {
  if (data == 0) {
    parentObj.RTCisLatched = false;
  }
  else if (!parentObj.RTCisLatched) {
    //Copy over the current RTC time for reading.
    parentObj.RTCisLatched = true;
    parentObj.latchedSeconds = parentObj.RTCSeconds | 0;
    parentObj.latchedMinutes = parentObj.RTCMinutes;
    parentObj.latchedHours = parentObj.RTCHours;
    parentObj.latchedLDays = (parentObj.RTCDays & 0xFF);
    parentObj.latchedHDays = parentObj.RTCDays >> 8;
  }
};
GameBoyCore.prototype.MBC5WriteROMBankLow = function (parentObj, address, data) {
  //MBC5 ROM bank switching:
  parentObj.ROMBank1offs = (parentObj.ROMBank1offs & 0x100) | data;
  parentObj.setCurrentMBC5ROMBank();
};
GameBoyCore.prototype.MBC5WriteROMBankHigh = function (parentObj, address, data) {
  //MBC5 ROM bank switching (by least significant bit):
  parentObj.ROMBank1offs  = ((data & 0x01) << 8) | (parentObj.ROMBank1offs & 0xFF);
  parentObj.setCurrentMBC5ROMBank();
};
GameBoyCore.prototype.MBC5WriteRAMBank = function (parentObj, address, data) {
  //MBC5 RAM bank switching
  parentObj.currMBCRAMBank = data & 0xF;
  parentObj.currMBCRAMBankPosition = (parentObj.currMBCRAMBank << 13) - 0xA000;
};
GameBoyCore.prototype.RUMBLEWriteRAMBank = function (parentObj, address, data) {
  //MBC5 RAM bank switching
  //Like MBC5, but bit 3 of the lower nibble is used for rumbling and bit 2 is ignored.
  parentObj.currMBCRAMBank = data & 0x03;
  parentObj.currMBCRAMBankPosition = (parentObj.currMBCRAMBank << 13) - 0xA000;
};
GameBoyCore.prototype.HuC3WriteRAMBank = function (parentObj, address, data) {
  //HuC3 RAM bank switching
  parentObj.currMBCRAMBank = data & 0x03;
  parentObj.currMBCRAMBankPosition = (parentObj.currMBCRAMBank << 13) - 0xA000;
};
GameBoyCore.prototype.cartIgnoreWrite = function (parentObj, address, data) {
  //We might have encountered illegal RAM writing or such, so just do nothing...
};
GameBoyCore.prototype.memoryWriteNormal = function (parentObj, address, data) {
  parentObj.memory[address] = data;
};
GameBoyCore.prototype.memoryHighWriteNormal = function (parentObj, address, data) {
  parentObj.memory[0xFF00 | address] = data;
};
GameBoyCore.prototype.memoryWriteMBCRAM = function (parentObj, address, data) {
  //[jf] changed "this" to "parentObj" below  
  if (parentObj.MBCRAMBanksEnabled || parentObj.opts.overrideMbc) {
    parentObj.MBCRam[address + parentObj.currMBCRAMBankPosition] = data;
  }
};
GameBoyCore.prototype.memoryWriteMBC3RAM = function (parentObj, address, data) {
  //[jf] changed "this" to "parentObj" below
  if (parentObj.MBCRAMBanksEnabled || parentObj.opts.overrideMbc) {
    switch (parentObj.currMBCRAMBank) {
      case 0x00:
      case 0x01:
      case 0x02:
      case 0x03:
        parentObj.MBCRam[address + parentObj.currMBCRAMBankPosition] = data;
        break;
      case 0x08:
        if (data < 60) {
          parentObj.RTCSeconds = data;
        }
        else {
          debug("(Bank #" + parentObj.currMBCRAMBank + ") RTC write out of range: " + data, 1);
        }
        break;
      case 0x09:
        if (data < 60) {
          parentObj.RTCMinutes = data;
        }
        else {
          debug("(Bank #" + parentObj.currMBCRAMBank + ") RTC write out of range: " + data, 1);
        }
        break;
      case 0x0A:
        if (data < 24) {
          parentObj.RTCHours = data;
        }
        else {
          debug("(Bank #" + parentObj.currMBCRAMBank + ") RTC write out of range: " + data, 1);
        }
        break;
      case 0x0B:
        parentObj.RTCDays = (data & 0xFF) | (parentObj.RTCDays & 0x100);
        break;
      case 0x0C:
        parentObj.RTCDayOverFlow = (data > 0x7F);
        parentObj.RTCHalt = (data & 0x40) == 0x40;
        parentObj.RTCDays = ((data & 0x1) << 8) | (parentObj.RTCDays & 0xFF);
        break;
      default:
        debug("Invalid MBC3 bank address selected: " + parentObj.currMBCRAMBank, 0);
    }
  }
};
GameBoyCore.prototype.memoryWriteGBCRAM = function (parentObj, address, data) {
  parentObj.GBCMemory[address + parentObj.gbcRamBankPosition] = data;
};
GameBoyCore.prototype.memoryWriteOAMRAM = function (parentObj, address, data) {
  if (parentObj.modeSTAT < 2) {   //OAM RAM cannot be written to in mode 2 & 3
    if (parentObj.memory[address] != data) {
      parentObj.graphicsJIT();
      parentObj.memory[address] = data;
    }
  }
};
GameBoyCore.prototype.memoryWriteECHOGBCRAM = function (parentObj, address, data) {
  parentObj.GBCMemory[address + parentObj.gbcRamBankPositionECHO] = data;
};
GameBoyCore.prototype.memoryWriteECHONormal = function (parentObj, address, data) {
  parentObj.memory[address - 0x2000] = data;
};
GameBoyCore.prototype.VRAMGBDATAWrite = function (parentObj, address, data) {
  if (parentObj.modeSTAT < 3) { //VRAM cannot be written to during mode 3
    if (parentObj.memory[address] != data) {
      //JIT the graphics render queue:
      parentObj.graphicsJIT();
      parentObj.memory[address] = data;
      parentObj.generateGBOAMTileLine(address);
    }
  }
};
GameBoyCore.prototype.VRAMGBDATAUpperWrite = function (parentObj, address, data) {
  if (parentObj.modeSTAT < 3) { //VRAM cannot be written to during mode 3
    if (parentObj.memory[address] != data) {
      //JIT the graphics render queue:
      parentObj.graphicsJIT();
      parentObj.memory[address] = data;
      parentObj.generateGBTileLine(address);
    }
  }
};
GameBoyCore.prototype.VRAMGBCDATAWrite = function (parentObj, address, data) {
  if (parentObj.modeSTAT < 3) { //VRAM cannot be written to during mode 3
    if (parentObj.currVRAMBank == 0) {
      if (parentObj.memory[address] != data) {
        //JIT the graphics render queue:
        parentObj.graphicsJIT();
        parentObj.memory[address] = data;
        parentObj.generateGBCTileLineBank1(address);
      }
    }
    else {
      address &= 0x1FFF;
      if (parentObj.VRAM[address] != data) {
        //JIT the graphics render queue:
        parentObj.graphicsJIT();
        parentObj.VRAM[address] = data;
        parentObj.generateGBCTileLineBank2(address);
      }
    }
  }
};
GameBoyCore.prototype.VRAMGBCHRMAPWrite = function (parentObj, address, data) {
  if (parentObj.modeSTAT < 3) { //VRAM cannot be written to during mode 3
    address &= 0x7FF;
    if (parentObj.BGCHRBank1[address] != data) {
      //JIT the graphics render queue:
      parentObj.graphicsJIT();
      parentObj.BGCHRBank1[address] = data;
    }
  }
};
GameBoyCore.prototype.VRAMGBCCHRMAPWrite = function (parentObj, address, data) {
  if (parentObj.modeSTAT < 3) { //VRAM cannot be written to during mode 3
    address &= 0x7FF;
    if (parentObj.BGCHRCurrentBank[address] != data) {
      //JIT the graphics render queue:
      parentObj.graphicsJIT();
      parentObj.BGCHRCurrentBank[address] = data;
    }
  }
};
GameBoyCore.prototype.DMAWrite = function (tilesToTransfer) {
  if (!this.halt) {
    //Clock the CPU for the DMA transfer (CPU is halted during the transfer):
    this.CPUTicks += 4 | ((tilesToTransfer << 5) << this.doubleSpeedShifter);
  }
  //Source address of the transfer:
  var source = (this.memory[0xFF51] << 8) | this.memory[0xFF52];
  //Destination address in the VRAM memory range:
  var destination = (this.memory[0xFF53] << 8) | this.memory[0xFF54];
  //Creating some references:
  var memoryReader = this.memoryReader;
  //JIT the graphics render queue:
  this.graphicsJIT();
  var memory = this.memory;
  //Determining which bank we're working on so we can optimize:
  if (this.currVRAMBank == 0) {
    //DMA transfer for VRAM bank 0:
    do {
      if (destination < 0x1800) {
        memory[0x8000 | destination] = memoryReader[source](this, source++);
        memory[0x8001 | destination] = memoryReader[source](this, source++);
        memory[0x8002 | destination] = memoryReader[source](this, source++);
        memory[0x8003 | destination] = memoryReader[source](this, source++);
        memory[0x8004 | destination] = memoryReader[source](this, source++);
        memory[0x8005 | destination] = memoryReader[source](this, source++);
        memory[0x8006 | destination] = memoryReader[source](this, source++);
        memory[0x8007 | destination] = memoryReader[source](this, source++);
        memory[0x8008 | destination] = memoryReader[source](this, source++);
        memory[0x8009 | destination] = memoryReader[source](this, source++);
        memory[0x800A | destination] = memoryReader[source](this, source++);
        memory[0x800B | destination] = memoryReader[source](this, source++);
        memory[0x800C | destination] = memoryReader[source](this, source++);
        memory[0x800D | destination] = memoryReader[source](this, source++);
        memory[0x800E | destination] = memoryReader[source](this, source++);
        memory[0x800F | destination] = memoryReader[source](this, source++);
        this.generateGBCTileBank1(destination);
        destination += 0x10;
      }
      else {
        destination &= 0x7F0;
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank1[destination++] = memoryReader[source](this, source++);
        destination = (destination + 0x1800) & 0x1FF0;
      }
      source &= 0xFFF0;
      --tilesToTransfer;
    } while (tilesToTransfer > 0);
  }
  else {
    var VRAM = this.VRAM;
    //DMA transfer for VRAM bank 1:
    do {
      if (destination < 0x1800) {
        VRAM[destination] = memoryReader[source](this, source++);
        VRAM[destination | 0x1] = memoryReader[source](this, source++);
        VRAM[destination | 0x2] = memoryReader[source](this, source++);
        VRAM[destination | 0x3] = memoryReader[source](this, source++);
        VRAM[destination | 0x4] = memoryReader[source](this, source++);
        VRAM[destination | 0x5] = memoryReader[source](this, source++);
        VRAM[destination | 0x6] = memoryReader[source](this, source++);
        VRAM[destination | 0x7] = memoryReader[source](this, source++);
        VRAM[destination | 0x8] = memoryReader[source](this, source++);
        VRAM[destination | 0x9] = memoryReader[source](this, source++);
        VRAM[destination | 0xA] = memoryReader[source](this, source++);
        VRAM[destination | 0xB] = memoryReader[source](this, source++);
        VRAM[destination | 0xC] = memoryReader[source](this, source++);
        VRAM[destination | 0xD] = memoryReader[source](this, source++);
        VRAM[destination | 0xE] = memoryReader[source](this, source++);
        VRAM[destination | 0xF] = memoryReader[source](this, source++);
        this.generateGBCTileBank2(destination);
        destination += 0x10;
      }
      else {
        destination &= 0x7F0;
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        this.BGCHRBank2[destination++] = memoryReader[source](this, source++);
        destination = (destination + 0x1800) & 0x1FF0;
      }
      source &= 0xFFF0;
      --tilesToTransfer;
    } while (tilesToTransfer > 0);
  }
  //Update the HDMA registers to their next addresses:
  memory[0xFF51] = source >> 8;
  memory[0xFF52] = source & 0xF0;
  memory[0xFF53] = destination >> 8;
  memory[0xFF54] = destination & 0xF0;
};
GameBoyCore.prototype.registerWriteJumpCompile = function () {
  //I/O Registers (GB + GBC):
  //JoyPad
  this.memoryHighWriter[0] = this.memoryWriter[0xFF00] = function (parentObj, address, data) {
    parentObj.memory[0xFF00] = (data & 0x30) | ((((data & 0x20) == 0) ? (parentObj.JoyPad >> 4) : 0xF) & (((data & 0x10) == 0) ? (parentObj.JoyPad & 0xF) : 0xF));
  };
  //SB (Serial Transfer Data)
  this.memoryHighWriter[0x1] = this.memoryWriter[0xFF01] = function (parentObj, address, data) {
    if (parentObj.memory[0xFF02] < 0x80) {  //Cannot write while a serial transfer is active.
      parentObj.memory[0xFF01] = data;
    }
  };
  //SC (Serial Transfer Control):
  this.memoryHighWriter[0x2] = this.memoryHighWriteNormal;
  this.memoryWriter[0xFF02] = this.memoryWriteNormal;
  //Unmapped I/O:
  this.memoryHighWriter[0x3] = this.memoryWriter[0xFF03] = this.cartIgnoreWrite;
  //DIV
  this.memoryHighWriter[0x4] = this.memoryWriter[0xFF04] = function (parentObj, address, data) {
    parentObj.DIVTicks &= 0xFF; //Update DIV for realignment.
    parentObj.memory[0xFF04] = 0;
  };
  //TIMA
  this.memoryHighWriter[0x5] = this.memoryWriter[0xFF05] = function (parentObj, address, data) {
    parentObj.memory[0xFF05] = data;
  };
  //TMA
  this.memoryHighWriter[0x6] = this.memoryWriter[0xFF06] = function (parentObj, address, data) {
    parentObj.memory[0xFF06] = data;
  };
  //TAC
  this.memoryHighWriter[0x7] = this.memoryWriter[0xFF07] = function (parentObj, address, data) {
    parentObj.memory[0xFF07] = data & 0x07;
    parentObj.TIMAEnabled = (data & 0x04) == 0x04;
    parentObj.TACClocker = Math.pow(4, ((data & 0x3) != 0) ? (data & 0x3) : 4) << 2;  //TODO: Find a way to not make a conditional in here...
  };
  //Unmapped I/O:
  this.memoryHighWriter[0x8] = this.memoryWriter[0xFF08] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x9] = this.memoryWriter[0xFF09] = this.cartIgnoreWrite;
  this.memoryHighWriter[0xA] = this.memoryWriter[0xFF0A] = this.cartIgnoreWrite;
  this.memoryHighWriter[0xB] = this.memoryWriter[0xFF0B] = this.cartIgnoreWrite;
  this.memoryHighWriter[0xC] = this.memoryWriter[0xFF0C] = this.cartIgnoreWrite;
  this.memoryHighWriter[0xD] = this.memoryWriter[0xFF0D] = this.cartIgnoreWrite;
  this.memoryHighWriter[0xE] = this.memoryWriter[0xFF0E] = this.cartIgnoreWrite;
  //IF (Interrupt Request)
  this.memoryHighWriter[0xF] = this.memoryWriter[0xFF0F] = function (parentObj, address, data) {
    parentObj.interruptsRequested = data;
    parentObj.checkIRQMatching();
  };
  //NR10:
  this.memoryHighWriter[0x10] = this.memoryWriter[0xFF10] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (parentObj.channel1decreaseSweep && (data & 0x08) == 0) {
        if (parentObj.channel1Swept) {
          parentObj.channel1SweepFault = true;
        }
      }
      parentObj.channel1lastTimeSweep = (data & 0x70) >> 4;
      parentObj.channel1frequencySweepDivider = data & 0x07;
      parentObj.channel1decreaseSweep = ((data & 0x08) == 0x08);
      parentObj.memory[0xFF10] = data;
      parentObj.channel1EnableCheck();
    }
  };
  //NR11:
  this.memoryHighWriter[0x11] = this.memoryWriter[0xFF11] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled || !parentObj.cGBC) {
      if (parentObj.soundMasterEnabled) {
        parentObj.audioJIT();
      }
      else {
        data &= 0x3F;
      }
      parentObj.channel1CachedDuty = parentObj.dutyLookup[data >> 6];
      parentObj.channel1totalLength = 0x40 - (data & 0x3F);
      parentObj.memory[0xFF11] = data;
      parentObj.channel1EnableCheck();
    }
  };
  //NR12:
  this.memoryHighWriter[0x12] = this.memoryWriter[0xFF12] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (parentObj.channel1Enabled && parentObj.channel1envelopeSweeps == 0) {
        //Zombie Volume PAPU Bug:
        if (((parentObj.memory[0xFF12] ^ data) & 0x8) == 0x8) {
          if ((parentObj.memory[0xFF12] & 0x8) == 0) {
            if ((parentObj.memory[0xFF12] & 0x7) == 0x7) {
              parentObj.channel1envelopeVolume += 2;
            }
            else {
              ++parentObj.channel1envelopeVolume;
            }
          }
          parentObj.channel1envelopeVolume = (16 - parentObj.channel1envelopeVolume) & 0xF;
        }
        else if ((parentObj.memory[0xFF12] & 0xF) == 0x8) {
          parentObj.channel1envelopeVolume = (1 + parentObj.channel1envelopeVolume) & 0xF;
        }
        parentObj.channel1OutputLevelCache();
      }
      parentObj.channel1envelopeType = ((data & 0x08) == 0x08);
      parentObj.memory[0xFF12] = data;
      parentObj.channel1VolumeEnableCheck();
    }
  };
  //NR13:
  this.memoryHighWriter[0x13] = this.memoryWriter[0xFF13] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      parentObj.channel1frequency = (parentObj.channel1frequency & 0x700) | data;
      parentObj.channel1FrequencyTracker = (0x800 - parentObj.channel1frequency) << 2;
    }
  };
  //NR14:
  this.memoryHighWriter[0x14] = this.memoryWriter[0xFF14] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      parentObj.channel1consecutive = ((data & 0x40) == 0x0);
      parentObj.channel1frequency = ((data & 0x7) << 8) | (parentObj.channel1frequency & 0xFF);
      parentObj.channel1FrequencyTracker = (0x800 - parentObj.channel1frequency) << 2;
      if (data > 0x7F) {
        //Reload 0xFF10:
        parentObj.channel1timeSweep = parentObj.channel1lastTimeSweep;
        parentObj.channel1Swept = false;
        //Reload 0xFF12:
        var nr12 = parentObj.memory[0xFF12];
        parentObj.channel1envelopeVolume = nr12 >> 4;
        parentObj.channel1OutputLevelCache();
        parentObj.channel1envelopeSweepsLast = (nr12 & 0x7) - 1;
        if (parentObj.channel1totalLength == 0) {
          parentObj.channel1totalLength = 0x40;
        }
        if (parentObj.channel1lastTimeSweep > 0 || parentObj.channel1frequencySweepDivider > 0) {
          parentObj.memory[0xFF26] |= 0x1;
        }
        else {
          parentObj.memory[0xFF26] &= 0xFE;
        }
        if ((data & 0x40) == 0x40) {
          parentObj.memory[0xFF26] |= 0x1;
        }
        parentObj.channel1ShadowFrequency = parentObj.channel1frequency;
        //Reset frequency overflow check + frequency sweep type check:
        parentObj.channel1SweepFault = false;
        //Supposed to run immediately:
        parentObj.channel1AudioSweepPerformDummy();
      }
      parentObj.channel1EnableCheck();
      parentObj.memory[0xFF14] = data;
    }
  };
  //NR20 (Unused I/O):
  this.memoryHighWriter[0x15] = this.memoryWriter[0xFF15] = this.cartIgnoreWrite;
  //NR21:
  this.memoryHighWriter[0x16] = this.memoryWriter[0xFF16] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled || !parentObj.cGBC) {
      if (parentObj.soundMasterEnabled) {
        parentObj.audioJIT();
      }
      else {
        data &= 0x3F;
      }
      parentObj.channel2CachedDuty = parentObj.dutyLookup[data >> 6];
      parentObj.channel2totalLength = 0x40 - (data & 0x3F);
      parentObj.memory[0xFF16] = data;
      parentObj.channel2EnableCheck();
    }
  };
  //NR22:
  this.memoryHighWriter[0x17] = this.memoryWriter[0xFF17] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (parentObj.channel2Enabled && parentObj.channel2envelopeSweeps == 0) {
        //Zombie Volume PAPU Bug:
        if (((parentObj.memory[0xFF17] ^ data) & 0x8) == 0x8) {
          if ((parentObj.memory[0xFF17] & 0x8) == 0) {
            if ((parentObj.memory[0xFF17] & 0x7) == 0x7) {
              parentObj.channel2envelopeVolume += 2;
            }
            else {
              ++parentObj.channel2envelopeVolume;
            }
          }
          parentObj.channel2envelopeVolume = (16 - parentObj.channel2envelopeVolume) & 0xF;
        }
        else if ((parentObj.memory[0xFF17] & 0xF) == 0x8) {
          parentObj.channel2envelopeVolume = (1 + parentObj.channel2envelopeVolume) & 0xF;
        }
        parentObj.channel2OutputLevelCache();
      }
      parentObj.channel2envelopeType = ((data & 0x08) == 0x08);
      parentObj.memory[0xFF17] = data;
      parentObj.channel2VolumeEnableCheck();
    }
  };
  //NR23:
  this.memoryHighWriter[0x18] = this.memoryWriter[0xFF18] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      parentObj.channel2frequency = (parentObj.channel2frequency & 0x700) | data;
      parentObj.channel2FrequencyTracker = (0x800 - parentObj.channel2frequency) << 2;
    }
  };
  //NR24:
  this.memoryHighWriter[0x19] = this.memoryWriter[0xFF19] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (data > 0x7F) {
        //Reload 0xFF17:
        var nr22 = parentObj.memory[0xFF17];
        parentObj.channel2envelopeVolume = nr22 >> 4;
        parentObj.channel2OutputLevelCache();
        parentObj.channel2envelopeSweepsLast = (nr22 & 0x7) - 1;
        if (parentObj.channel2totalLength == 0) {
          parentObj.channel2totalLength = 0x40;
        }
        if ((data & 0x40) == 0x40) {
          parentObj.memory[0xFF26] |= 0x2;
        }
      }
      parentObj.channel2consecutive = ((data & 0x40) == 0x0);
      parentObj.channel2frequency = ((data & 0x7) << 8) | (parentObj.channel2frequency & 0xFF);
      parentObj.channel2FrequencyTracker = (0x800 - parentObj.channel2frequency) << 2;
      parentObj.memory[0xFF19] = data;
      parentObj.channel2EnableCheck();
    }
  };
  //NR30:
  this.memoryHighWriter[0x1A] = this.memoryWriter[0xFF1A] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (!parentObj.channel3canPlay && data >= 0x80) {
        parentObj.channel3lastSampleLookup = 0;
        parentObj.channel3UpdateCache();
      }
      parentObj.channel3canPlay = (data > 0x7F);
      if (parentObj.channel3canPlay && parentObj.memory[0xFF1A] > 0x7F && !parentObj.channel3consecutive) {
        parentObj.memory[0xFF26] |= 0x4;
      }
      parentObj.memory[0xFF1A] = data;
      //parentObj.channel3EnableCheck();
    }
  };
  //NR31:
  this.memoryHighWriter[0x1B] = this.memoryWriter[0xFF1B] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled || !parentObj.cGBC) {
      if (parentObj.soundMasterEnabled) {
        parentObj.audioJIT();
      }
      parentObj.channel3totalLength = 0x100 - data;
      parentObj.channel3EnableCheck();
    }
  };
  //NR32:
  this.memoryHighWriter[0x1C] = this.memoryWriter[0xFF1C] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      data &= 0x60;
      parentObj.memory[0xFF1C] = data;
      parentObj.channel3patternType = (data == 0) ? 4 : ((data >> 5) - 1);
    }
  };
  //NR33:
  this.memoryHighWriter[0x1D] = this.memoryWriter[0xFF1D] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      parentObj.channel3frequency = (parentObj.channel3frequency & 0x700) | data;
      parentObj.channel3FrequencyPeriod = (0x800 - parentObj.channel3frequency) << 1;
    }
  };
  //NR34:
  this.memoryHighWriter[0x1E] = this.memoryWriter[0xFF1E] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (data > 0x7F) {
        if (parentObj.channel3totalLength == 0) {
          parentObj.channel3totalLength = 0x100;
        }
        parentObj.channel3lastSampleLookup = 0;
        if ((data & 0x40) == 0x40) {
          parentObj.memory[0xFF26] |= 0x4;
        }
      }
      parentObj.channel3consecutive = ((data & 0x40) == 0x0);
      parentObj.channel3frequency = ((data & 0x7) << 8) | (parentObj.channel3frequency & 0xFF);
      parentObj.channel3FrequencyPeriod = (0x800 - parentObj.channel3frequency) << 1;
      parentObj.memory[0xFF1E] = data;
      parentObj.channel3EnableCheck();
    }
  };
  //NR40 (Unused I/O):
  this.memoryHighWriter[0x1F] = this.memoryWriter[0xFF1F] = this.cartIgnoreWrite;
  //NR41:
  this.memoryHighWriter[0x20] = this.memoryWriter[0xFF20] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled || !parentObj.cGBC) {
      if (parentObj.soundMasterEnabled) {
        parentObj.audioJIT();
      }
      parentObj.channel4totalLength = 0x40 - (data & 0x3F);
      parentObj.channel4EnableCheck();
    }
  };
  //NR42:
  this.memoryHighWriter[0x21] = this.memoryWriter[0xFF21] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      if (parentObj.channel4Enabled && parentObj.channel4envelopeSweeps == 0) {
        //Zombie Volume PAPU Bug:
        if (((parentObj.memory[0xFF21] ^ data) & 0x8) == 0x8) {
          if ((parentObj.memory[0xFF21] & 0x8) == 0) {
            if ((parentObj.memory[0xFF21] & 0x7) == 0x7) {
              parentObj.channel4envelopeVolume += 2;
            }
            else {
              ++parentObj.channel4envelopeVolume;
            }
          }
          parentObj.channel4envelopeVolume = (16 - parentObj.channel4envelopeVolume) & 0xF;
        }
        else if ((parentObj.memory[0xFF21] & 0xF) == 0x8) {
          parentObj.channel4envelopeVolume = (1 + parentObj.channel4envelopeVolume) & 0xF;
        }
        parentObj.channel4currentVolume = parentObj.channel4envelopeVolume << parentObj.channel4VolumeShifter;
      }
      parentObj.channel4envelopeType = ((data & 0x08) == 0x08);
      parentObj.memory[0xFF21] = data;
      parentObj.channel4UpdateCache();
      parentObj.channel4VolumeEnableCheck();
    }
  };
  //NR43:
  this.memoryHighWriter[0x22] = this.memoryWriter[0xFF22] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      parentObj.channel4FrequencyPeriod = Math.max((data & 0x7) << 4, 8) << (data >> 4);
      var bitWidth = (data & 0x8);
      if ((bitWidth == 0x8 && parentObj.channel4BitRange == 0x7FFF) || (bitWidth == 0 && parentObj.channel4BitRange == 0x7F)) {
        parentObj.channel4lastSampleLookup = 0;
        parentObj.channel4BitRange = (bitWidth == 0x8) ? 0x7F : 0x7FFF;
        parentObj.channel4VolumeShifter = (bitWidth == 0x8) ? 7 : 15;
        parentObj.channel4currentVolume = parentObj.channel4envelopeVolume << parentObj.channel4VolumeShifter;
        parentObj.noiseSampleTable = (bitWidth == 0x8) ? parentObj.LSFR7Table : parentObj.LSFR15Table;
      }
      parentObj.memory[0xFF22] = data;
      parentObj.channel4UpdateCache();
    }
  };
  //NR44:
  this.memoryHighWriter[0x23] = this.memoryWriter[0xFF23] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled) {
      parentObj.audioJIT();
      parentObj.memory[0xFF23] = data;
      parentObj.channel4consecutive = ((data & 0x40) == 0x0);
      if (data > 0x7F) {
        var nr42 = parentObj.memory[0xFF21];
        parentObj.channel4envelopeVolume = nr42 >> 4;
        parentObj.channel4currentVolume = parentObj.channel4envelopeVolume << parentObj.channel4VolumeShifter;
        parentObj.channel4envelopeSweepsLast = (nr42 & 0x7) - 1;
        if (parentObj.channel4totalLength == 0) {
          parentObj.channel4totalLength = 0x40;
        }
        if ((data & 0x40) == 0x40) {
          parentObj.memory[0xFF26] |= 0x8;
        }
      }
      parentObj.channel4EnableCheck();
    }
  };
  //NR50:
  this.memoryHighWriter[0x24] = this.memoryWriter[0xFF24] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled && parentObj.memory[0xFF24] != data) {
      parentObj.audioJIT();
      parentObj.memory[0xFF24] = data;
      parentObj.VinLeftChannelMasterVolume = ((data >> 4) & 0x07) + 1;
      parentObj.VinRightChannelMasterVolume = (data & 0x07) + 1;
      parentObj.mixerOutputLevelCache();
    }
  };
  //NR51:
  this.memoryHighWriter[0x25] = this.memoryWriter[0xFF25] = function (parentObj, address, data) {
    if (parentObj.soundMasterEnabled && parentObj.memory[0xFF25] != data) {
      parentObj.audioJIT();
      parentObj.memory[0xFF25] = data;
      parentObj.rightChannel1 = ((data & 0x01) == 0x01);
      parentObj.rightChannel2 = ((data & 0x02) == 0x02);
      parentObj.rightChannel3 = ((data & 0x04) == 0x04);
      parentObj.rightChannel4 = ((data & 0x08) == 0x08);
      parentObj.leftChannel1 = ((data & 0x10) == 0x10);
      parentObj.leftChannel2 = ((data & 0x20) == 0x20);
      parentObj.leftChannel3 = ((data & 0x40) == 0x40);
      parentObj.leftChannel4 = (data > 0x7F);
      parentObj.channel1OutputLevelCache();
      parentObj.channel2OutputLevelCache();
      parentObj.channel3OutputLevelCache();
      parentObj.channel4OutputLevelCache();
    }
  };
  //NR52:
  this.memoryHighWriter[0x26] = this.memoryWriter[0xFF26] = function (parentObj, address, data) {
    parentObj.audioJIT();
    if (!parentObj.soundMasterEnabled && data > 0x7F) {
      parentObj.memory[0xFF26] = 0x80;
      parentObj.soundMasterEnabled = true;
      parentObj.initializeAudioStartState();
    }
    else if (parentObj.soundMasterEnabled && data < 0x80) {
      parentObj.memory[0xFF26] = 0;
      parentObj.soundMasterEnabled = false;
      //GBDev wiki says the registers are written with zeros on power off:
      for (var index = 0xFF10; index < 0xFF26; index++) {
        parentObj.memoryWriter[index](parentObj, index, 0);
      }
    }
  };
  //0xFF27 to 0xFF2F don't do anything...
  this.memoryHighWriter[0x27] = this.memoryWriter[0xFF27] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x28] = this.memoryWriter[0xFF28] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x29] = this.memoryWriter[0xFF29] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x2A] = this.memoryWriter[0xFF2A] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x2B] = this.memoryWriter[0xFF2B] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x2C] = this.memoryWriter[0xFF2C] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x2D] = this.memoryWriter[0xFF2D] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x2E] = this.memoryWriter[0xFF2E] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x2F] = this.memoryWriter[0xFF2F] = this.cartIgnoreWrite;
  //WAVE PCM RAM:
  this.memoryHighWriter[0x30] = this.memoryWriter[0xFF30] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0, data);
  };
  this.memoryHighWriter[0x31] = this.memoryWriter[0xFF31] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x1, data);
  };
  this.memoryHighWriter[0x32] = this.memoryWriter[0xFF32] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x2, data);
  };
  this.memoryHighWriter[0x33] = this.memoryWriter[0xFF33] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x3, data);
  };
  this.memoryHighWriter[0x34] = this.memoryWriter[0xFF34] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x4, data);
  };
  this.memoryHighWriter[0x35] = this.memoryWriter[0xFF35] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x5, data);
  };
  this.memoryHighWriter[0x36] = this.memoryWriter[0xFF36] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x6, data);
  };
  this.memoryHighWriter[0x37] = this.memoryWriter[0xFF37] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x7, data);
  };
  this.memoryHighWriter[0x38] = this.memoryWriter[0xFF38] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x8, data);
  };
  this.memoryHighWriter[0x39] = this.memoryWriter[0xFF39] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0x9, data);
  };
  this.memoryHighWriter[0x3A] = this.memoryWriter[0xFF3A] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0xA, data);
  };
  this.memoryHighWriter[0x3B] = this.memoryWriter[0xFF3B] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0xB, data);
  };
  this.memoryHighWriter[0x3C] = this.memoryWriter[0xFF3C] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0xC, data);
  };
  this.memoryHighWriter[0x3D] = this.memoryWriter[0xFF3D] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0xD, data);
  };
  this.memoryHighWriter[0x3E] = this.memoryWriter[0xFF3E] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0xE, data);
  };
  this.memoryHighWriter[0x3F] = this.memoryWriter[0xFF3F] = function (parentObj, address, data) {
    parentObj.channel3WriteRAM(0xF, data);
  };
  //SCY
  this.memoryHighWriter[0x42] = this.memoryWriter[0xFF42] = function (parentObj, address, data) {
    if (parentObj.backgroundY != data) {
      parentObj.midScanLineJIT();
      parentObj.backgroundY = data;
    }
  };
  //SCX
  this.memoryHighWriter[0x43] = this.memoryWriter[0xFF43] = function (parentObj, address, data) {
    if (parentObj.backgroundX != data) {
      parentObj.midScanLineJIT();
      parentObj.backgroundX = data;
    }
  };
  //LY
  this.memoryHighWriter[0x44] = this.memoryWriter[0xFF44] = function (parentObj, address, data) {
    //Read Only:
    if (parentObj.LCDisOn) {
      //Gambatte says to do this:
      parentObj.modeSTAT = 2;
      parentObj.midScanlineOffset = -1;
      parentObj.totalLinesPassed = parentObj.currentX = parentObj.queuedScanLines = parentObj.lastUnrenderedLine = parentObj.LCDTicks = parentObj.STATTracker = parentObj.actualScanLine = parentObj.memory[0xFF44] = 0;
    }
  };
  //LYC
  this.memoryHighWriter[0x45] = this.memoryWriter[0xFF45] = function (parentObj, address, data) {
    if (parentObj.memory[0xFF45] != data) {
      parentObj.memory[0xFF45] = data;
      if (parentObj.LCDisOn) {
        parentObj.matchLYC(); //Get the compare of the first scan line.
      }
    }
  };
  //WY
  this.memoryHighWriter[0x4A] = this.memoryWriter[0xFF4A] = function (parentObj, address, data) {
    if (parentObj.windowY != data) {
      parentObj.midScanLineJIT();
      parentObj.windowY = data;
    }
  };
  //WX
  this.memoryHighWriter[0x4B] = this.memoryWriter[0xFF4B] = function (parentObj, address, data) {
    if (parentObj.memory[0xFF4B] != data) {
      parentObj.midScanLineJIT();
      parentObj.memory[0xFF4B] = data;
      parentObj.windowX = data - 7;
    }
  };
  this.memoryHighWriter[0x72] = this.memoryWriter[0xFF72] = function (parentObj, address, data) {
    parentObj.memory[0xFF72] = data;
  };
  this.memoryHighWriter[0x73] = this.memoryWriter[0xFF73] = function (parentObj, address, data) {
    parentObj.memory[0xFF73] = data;
  };
  this.memoryHighWriter[0x75] = this.memoryWriter[0xFF75] = function (parentObj, address, data) {
    parentObj.memory[0xFF75] = data;
  };
  this.memoryHighWriter[0x76] = this.memoryWriter[0xFF76] = this.cartIgnoreWrite;
  this.memoryHighWriter[0x77] = this.memoryWriter[0xFF77] = this.cartIgnoreWrite;
  //IE (Interrupt Enable)
  this.memoryHighWriter[0xFF] = this.memoryWriter[0xFFFF] = function (parentObj, address, data) {
    parentObj.interruptsEnabled = data;
    parentObj.checkIRQMatching();
  };
  this.recompileModelSpecificIOWriteHandling();
  this.recompileBootIOWriteHandling();
};
GameBoyCore.prototype.recompileModelSpecificIOWriteHandling = function () {
  if (this.cGBC) {
    //GameBoy Color Specific I/O:
    //SC (Serial Transfer Control Register)
    this.memoryHighWriter[0x2] = this.memoryWriter[0xFF02] = function (parentObj, address, data) {
      if (((data & 0x1) == 0x1)) {
        //Internal clock:
        parentObj.memory[0xFF02] = (data & 0x7F);
        parentObj.serialTimer = ((data & 0x2) == 0) ? 4096 : 128; //Set the Serial IRQ counter.
        parentObj.serialShiftTimer = parentObj.serialShiftTimerAllocated = ((data & 0x2) == 0) ? 512 : 16;  //Set the transfer data shift counter.
      }
      else {
        //External clock:
        parentObj.memory[0xFF02] = data;
        parentObj.serialShiftTimer = parentObj.serialShiftTimerAllocated = parentObj.serialTimer = 0; //Zero the timers, since we're emulating as if nothing is connected.
      }
    };
    this.memoryHighWriter[0x40] = this.memoryWriter[0xFF40] = function (parentObj, address, data) {
      if (parentObj.memory[0xFF40] != data) {
        parentObj.midScanLineJIT();
        var temp_var = (data > 0x7F);
        if (temp_var != parentObj.LCDisOn) {
          //When the display mode changes...
          parentObj.LCDisOn = temp_var;
          parentObj.memory[0xFF41] &= 0x78;
          parentObj.midScanlineOffset = -1;
          parentObj.totalLinesPassed = parentObj.currentX = parentObj.queuedScanLines = parentObj.lastUnrenderedLine = parentObj.STATTracker = parentObj.LCDTicks = parentObj.actualScanLine = parentObj.memory[0xFF44] = 0;
          if (parentObj.LCDisOn) {
            parentObj.modeSTAT = 2;
            parentObj.matchLYC(); //Get the compare of the first scan line.
            parentObj.LCDCONTROL = parentObj.LINECONTROL;
          }
          else {
            parentObj.modeSTAT = 0;
            parentObj.LCDCONTROL = parentObj.DISPLAYOFFCONTROL;
            parentObj.DisplayShowOff();
          }
          parentObj.interruptsRequested &= 0xFD;
        }
        parentObj.gfxWindowCHRBankPosition = ((data & 0x40) == 0x40) ? 0x400 : 0;
        parentObj.gfxWindowDisplay = ((data & 0x20) == 0x20);
        parentObj.gfxBackgroundBankOffset = ((data & 0x10) == 0x10) ? 0 : 0x80;
        parentObj.gfxBackgroundCHRBankPosition = ((data & 0x08) == 0x08) ? 0x400 : 0;
        parentObj.gfxSpriteNormalHeight = ((data & 0x04) == 0);
        parentObj.gfxSpriteShow = ((data & 0x02) == 0x02);
        parentObj.BGPriorityEnabled = ((data & 0x01) == 0x01);
        parentObj.priorityFlaggingPathRebuild();  //Special case the priority flagging as an optimization.
        parentObj.memory[0xFF40] = data;
      }
    };
    this.memoryHighWriter[0x41] = this.memoryWriter[0xFF41] = function (parentObj, address, data) {
      parentObj.LYCMatchTriggerSTAT = ((data & 0x40) == 0x40);
      parentObj.mode2TriggerSTAT = ((data & 0x20) == 0x20);
      parentObj.mode1TriggerSTAT = ((data & 0x10) == 0x10);
      parentObj.mode0TriggerSTAT = ((data & 0x08) == 0x08);
      parentObj.memory[0xFF41] = data & 0x78;
    };
    this.memoryHighWriter[0x46] = this.memoryWriter[0xFF46] = function (parentObj, address, data) {
      parentObj.memory[0xFF46] = data;
      if (data < 0xE0) {
        data <<= 8;
        address = 0xFE00;
        var stat = parentObj.modeSTAT;
        parentObj.modeSTAT = 0;
        var newData = 0;
        do {
          newData = parentObj.memoryReader[data](parentObj, data++);
          if (newData != parentObj.memory[address]) {
            //JIT the graphics render queue:
            parentObj.modeSTAT = stat;
            parentObj.graphicsJIT();
            parentObj.modeSTAT = 0;
            parentObj.memory[address++] = newData;
            break;
          }
        } while (++address < 0xFEA0);
        if (address < 0xFEA0) {
          do {
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
          } while (address < 0xFEA0);
        }
        parentObj.modeSTAT = stat;
      }
    };
    //KEY1
    this.memoryHighWriter[0x4D] = this.memoryWriter[0xFF4D] = function (parentObj, address, data) {
      parentObj.memory[0xFF4D] = (data & 0x7F) | (parentObj.memory[0xFF4D] & 0x80);
    };
    this.memoryHighWriter[0x4F] = this.memoryWriter[0xFF4F] = function (parentObj, address, data) {
      parentObj.currVRAMBank = data & 0x01;
      if (parentObj.currVRAMBank > 0) {
        parentObj.BGCHRCurrentBank = parentObj.BGCHRBank2;
      }
      else {
        parentObj.BGCHRCurrentBank = parentObj.BGCHRBank1;
      }
      //Only writable by GBC.
    };
    this.memoryHighWriter[0x51] = this.memoryWriter[0xFF51] = function (parentObj, address, data) {
      if (!parentObj.hdmaRunning) {
        parentObj.memory[0xFF51] = data;
      }
    };
    this.memoryHighWriter[0x52] = this.memoryWriter[0xFF52] = function (parentObj, address, data) {
      if (!parentObj.hdmaRunning) {
        parentObj.memory[0xFF52] = data & 0xF0;
      }
    };
    this.memoryHighWriter[0x53] = this.memoryWriter[0xFF53] = function (parentObj, address, data) {
      if (!parentObj.hdmaRunning) {
        parentObj.memory[0xFF53] = data & 0x1F;
      }
    };
    this.memoryHighWriter[0x54] = this.memoryWriter[0xFF54] = function (parentObj, address, data) {
      if (!parentObj.hdmaRunning) {
        parentObj.memory[0xFF54] = data & 0xF0;
      }
    };
    this.memoryHighWriter[0x55] = this.memoryWriter[0xFF55] = function (parentObj, address, data) {
      if (!parentObj.hdmaRunning) {
        if ((data & 0x80) == 0) {
          //DMA
          parentObj.DMAWrite((data & 0x7F) + 1);
          parentObj.memory[0xFF55] = 0xFF;  //Transfer completed.
        }
        else {
          //H-Blank DMA
          parentObj.hdmaRunning = true;
          parentObj.memory[0xFF55] = data & 0x7F;
        }
      }
      else if ((data & 0x80) == 0) {
        //Stop H-Blank DMA
        parentObj.hdmaRunning = false;
        parentObj.memory[0xFF55] |= 0x80;
      }
      else {
        parentObj.memory[0xFF55] = data & 0x7F;
      }
    };
    this.memoryHighWriter[0x68] = this.memoryWriter[0xFF68] = function (parentObj, address, data) {
      parentObj.memory[0xFF69] = parentObj.gbcBGRawPalette[data & 0x3F];
      parentObj.memory[0xFF68] = data;
    };
    this.memoryHighWriter[0x69] = this.memoryWriter[0xFF69] = function (parentObj, address, data) {
      parentObj.updateGBCBGPalette(parentObj.memory[0xFF68] & 0x3F, data);
      if (parentObj.memory[0xFF68] > 0x7F) { // high bit = autoincrement
        var next = ((parentObj.memory[0xFF68] + 1) & 0x3F);
        parentObj.memory[0xFF68] = (next | 0x80);
        parentObj.memory[0xFF69] = parentObj.gbcBGRawPalette[next];
      }
      else {
        parentObj.memory[0xFF69] = data;
      }
    };
    this.memoryHighWriter[0x6A] = this.memoryWriter[0xFF6A] = function (parentObj, address, data) {
      parentObj.memory[0xFF6B] = parentObj.gbcOBJRawPalette[data & 0x3F];
      parentObj.memory[0xFF6A] = data;
    };
    this.memoryHighWriter[0x6B] = this.memoryWriter[0xFF6B] = function (parentObj, address, data) {
      parentObj.updateGBCOBJPalette(parentObj.memory[0xFF6A] & 0x3F, data);
      if (parentObj.memory[0xFF6A] > 0x7F) { // high bit = autoincrement
        var next = ((parentObj.memory[0xFF6A] + 1) & 0x3F);
        parentObj.memory[0xFF6A] = (next | 0x80);
        parentObj.memory[0xFF6B] = parentObj.gbcOBJRawPalette[next];
      }
      else {
        parentObj.memory[0xFF6B] = data;
      }
    };
    //SVBK
    this.memoryHighWriter[0x70] = this.memoryWriter[0xFF70] = function (parentObj, address, data) {
      var addressCheck = (parentObj.memory[0xFF51] << 8) | parentObj.memory[0xFF52];  //Cannot change the RAM bank while WRAM is the source of a running HDMA.
      if (!parentObj.hdmaRunning || addressCheck < 0xD000 || addressCheck >= 0xE000) {
        parentObj.gbcRamBank = Math.max(data & 0x07, 1);  //Bank range is from 1-7
        parentObj.gbcRamBankPosition = ((parentObj.gbcRamBank - 1) << 12) - 0xD000;
        parentObj.gbcRamBankPositionECHO = parentObj.gbcRamBankPosition - 0x2000;
      }
      parentObj.memory[0xFF70] = data;  //Bit 6 cannot be written to.
    };
    this.memoryHighWriter[0x74] = this.memoryWriter[0xFF74] = function (parentObj, address, data) {
      parentObj.memory[0xFF74] = data;
    };
  }
  else {
    //Fill in the GameBoy Color I/O registers as normal RAM for GameBoy compatibility:
    //SC (Serial Transfer Control Register)
    this.memoryHighWriter[0x2] = this.memoryWriter[0xFF02] = function (parentObj, address, data) {
      if (((data & 0x1) == 0x1)) {
        //Internal clock:
        parentObj.memory[0xFF02] = (data & 0x7F);
        parentObj.serialTimer = 4096; //Set the Serial IRQ counter.
        parentObj.serialShiftTimer = parentObj.serialShiftTimerAllocated = 512; //Set the transfer data shift counter.
      }
      else {
        //External clock:
        parentObj.memory[0xFF02] = data;
        parentObj.serialShiftTimer = parentObj.serialShiftTimerAllocated = parentObj.serialTimer = 0; //Zero the timers, since we're emulating as if nothing is connected.
      }
    };
    this.memoryHighWriter[0x40] = this.memoryWriter[0xFF40] = function (parentObj, address, data) {
      if (parentObj.memory[0xFF40] != data) {
        parentObj.midScanLineJIT();
        var temp_var = (data > 0x7F);
        if (temp_var != parentObj.LCDisOn) {
          //When the display mode changes...
          parentObj.LCDisOn = temp_var;
          parentObj.memory[0xFF41] &= 0x78;
          parentObj.midScanlineOffset = -1;
          parentObj.totalLinesPassed = parentObj.currentX = parentObj.queuedScanLines = parentObj.lastUnrenderedLine = parentObj.STATTracker = parentObj.LCDTicks = parentObj.actualScanLine = parentObj.memory[0xFF44] = 0;
          if (parentObj.LCDisOn) {
            parentObj.modeSTAT = 2;
            parentObj.matchLYC(); //Get the compare of the first scan line.
            parentObj.LCDCONTROL = parentObj.LINECONTROL;
          }
          else {
            parentObj.modeSTAT = 0;
            parentObj.LCDCONTROL = parentObj.DISPLAYOFFCONTROL;
            parentObj.DisplayShowOff();
          }
          parentObj.interruptsRequested &= 0xFD;
        }
        parentObj.gfxWindowCHRBankPosition = ((data & 0x40) == 0x40) ? 0x400 : 0;
        parentObj.gfxWindowDisplay = (data & 0x20) == 0x20;
        parentObj.gfxBackgroundBankOffset = ((data & 0x10) == 0x10) ? 0 : 0x80;
        parentObj.gfxBackgroundCHRBankPosition = ((data & 0x08) == 0x08) ? 0x400 : 0;
        parentObj.gfxSpriteNormalHeight = ((data & 0x04) == 0);
        parentObj.gfxSpriteShow = (data & 0x02) == 0x02;
        parentObj.bgEnabled = ((data & 0x01) == 0x01);
        parentObj.memory[0xFF40] = data;
      }
    };
    this.memoryHighWriter[0x41] = this.memoryWriter[0xFF41] = function (parentObj, address, data) {
      parentObj.LYCMatchTriggerSTAT = ((data & 0x40) == 0x40);
      parentObj.mode2TriggerSTAT = ((data & 0x20) == 0x20);
      parentObj.mode1TriggerSTAT = ((data & 0x10) == 0x10);
      parentObj.mode0TriggerSTAT = ((data & 0x08) == 0x08);
      parentObj.memory[0xFF41] = data & 0x78;
      if ((!parentObj.usedBootROM || !parentObj.usedGBCBootROM) && parentObj.LCDisOn && parentObj.modeSTAT < 2) {
        parentObj.interruptsRequested |= 0x2;
        parentObj.checkIRQMatching();
      }
    };
    this.memoryHighWriter[0x46] = this.memoryWriter[0xFF46] = function (parentObj, address, data) {
      parentObj.memory[0xFF46] = data;
      if (data > 0x7F && data < 0xE0) { //DMG cannot DMA from the ROM banks.
        data <<= 8;
        address = 0xFE00;
        var stat = parentObj.modeSTAT;
        parentObj.modeSTAT = 0;
        var newData = 0;
        do {
          newData = parentObj.memoryReader[data](parentObj, data++);
          if (newData != parentObj.memory[address]) {
            //JIT the graphics render queue:
            parentObj.modeSTAT = stat;
            parentObj.graphicsJIT();
            parentObj.modeSTAT = 0;
            parentObj.memory[address++] = newData;
            break;
          }
        } while (++address < 0xFEA0);
        if (address < 0xFEA0) {
          do {
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
            parentObj.memory[address++] = parentObj.memoryReader[data](parentObj, data++);
          } while (address < 0xFEA0);
        }
        parentObj.modeSTAT = stat;
      }
    };
    this.memoryHighWriter[0x47] = this.memoryWriter[0xFF47] = function (parentObj, address, data) {
      if (parentObj.memory[0xFF47] != data) {
        parentObj.midScanLineJIT();
        parentObj.updateGBBGPalette(data);
        parentObj.memory[0xFF47] = data;
      }
    };
    this.memoryHighWriter[0x48] = this.memoryWriter[0xFF48] = function (parentObj, address, data) {
      if (parentObj.memory[0xFF48] != data) {
        parentObj.midScanLineJIT();
        parentObj.updateGBOBJPalette(0, data);
        parentObj.memory[0xFF48] = data;
      }
    };
    this.memoryHighWriter[0x49] = this.memoryWriter[0xFF49] = function (parentObj, address, data) {
      if (parentObj.memory[0xFF49] != data) {
        parentObj.midScanLineJIT();
        parentObj.updateGBOBJPalette(4, data);
        parentObj.memory[0xFF49] = data;
      }
    };
    this.memoryHighWriter[0x4D] = this.memoryWriter[0xFF4D] = function (parentObj, address, data) {
      parentObj.memory[0xFF4D] = data;
    };
    this.memoryHighWriter[0x4F] = this.memoryWriter[0xFF4F] = this.cartIgnoreWrite; //Not writable in DMG mode.
    this.memoryHighWriter[0x55] = this.memoryWriter[0xFF55] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x68] = this.memoryWriter[0xFF68] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x69] = this.memoryWriter[0xFF69] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x6A] = this.memoryWriter[0xFF6A] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x6B] = this.memoryWriter[0xFF6B] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x6C] = this.memoryWriter[0xFF6C] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x70] = this.memoryWriter[0xFF70] = this.cartIgnoreWrite;
    this.memoryHighWriter[0x74] = this.memoryWriter[0xFF74] = this.cartIgnoreWrite;
  }
};
GameBoyCore.prototype.recompileBootIOWriteHandling = function () {
  //Boot I/O Registers:
  if (this.inBootstrap) {
    this.memoryHighWriter[0x50] = this.memoryWriter[0xFF50] = function (parentObj, address, data) {
      debug("Boot ROM reads blocked: Bootstrap process has ended.", 0);
      parentObj.inBootstrap = false;
      parentObj.disableBootROM();     //Fill in the boot ROM ranges with ROM  bank 0 ROM ranges
      parentObj.memory[0xFF50] = data;  //Bits are sustained in memory?
    };
    if (this.cGBC) {
      this.memoryHighWriter[0x6C] = this.memoryWriter[0xFF6C] = function (parentObj, address, data) {
        if (parentObj.inBootstrap) {
          parentObj.cGBC = ((data & 0x1) == 0);
          //Exception to the GBC identifying code:
          if (parentObj.name + parentObj.gameCode + parentObj.ROM[0x143] == "Game and Watch 50") {
            parentObj.cGBC = true;
            debug("Created a boot exception for Game and Watch Gallery 2 (GBC ID byte is wrong on the cartridge).", 1);
          }
          debug("Booted to GBC Mode: " + parentObj.cGBC, 0);
        }
        parentObj.memory[0xFF6C] = data;
      };
    }
  }
  else {
    //Lockout the ROMs from accessing the BOOT ROM control register:
    this.memoryHighWriter[0x50] = this.memoryWriter[0xFF50] = this.cartIgnoreWrite;
  }
};
//Helper Functions
GameBoyCore.prototype.toTypedArray = function (baseArray, memtype) {
  try {
    if (!this.opts.typedArrays) {
      return baseArray;
    }
    if (!baseArray || !baseArray.length) {
      return [];
    }
    var length = baseArray.length;
    switch (memtype) {
      case "uint8":
        var typedArrayTemp = new Uint8Array(length);
        break;
      case "int8":
        var typedArrayTemp = new Int8Array(length);
        break;
      case "int32":
        var typedArrayTemp = new Int32Array(length);
        break;
      case "float32":
        var typedArrayTemp = new Float32Array(length);
    }
    for (var index = 0; index < length; index++) {
      typedArrayTemp[index] = baseArray[index];
    }
    return typedArrayTemp;
  }
  catch (error) {
    debug("Could not convert an array to a typed array: " + error.message, 1);
    return baseArray;
  }
};
GameBoyCore.prototype.fromTypedArray = function (baseArray) {
  try {
    if (!baseArray || !baseArray.length) {
      return [];
    }
    var arrayTemp = [];
    for (var index = 0; index < baseArray.length; ++index) {
      arrayTemp[index] = baseArray[index];
    }
    return arrayTemp;
  }
  catch (error) {
    debug("Conversion from a typed array failed: " + error.message, 1);
    return baseArray;
  }
};
GameBoyCore.prototype.getTypedArray = function (length, defaultValue, numberType) {
  var arrayHandle;
  try {
    if (!this.opts.typedArrays) {
      throw(new Error("Settings forced typed arrays to be disabled."));
    }
    switch (numberType) {
      case "int8":
        arrayHandle = new Int8Array(length);
        break;
      case "uint8":
        arrayHandle = new Uint8Array(length);
        break;
      case "int32":
        arrayHandle = new Int32Array(length);
        break;
      case "float32":
        arrayHandle = new Float32Array(length);
    }
    if (defaultValue != 0) {
      var index = 0;
      while (index < length) {
        arrayHandle[index++] = defaultValue;
      }
    }
  }
  catch (error) {
    debug("Could not convert an array to a typed array: " + error.message, 1);
    var arrayHandle = [];
    var index = 0;
    while (index < length) {
      arrayHandle[index++] = defaultValue;
    }
  }
  return arrayHandle;
};

window.GameBoyCore = GameBoyCore;
    </script>

    <!-- XAudioServer -->
    <script type="module">
// export {XAudioServer};
//2010-2013 Grant Galitz - XAudioJS realtime audio output compatibility library:
var XAudioJSscriptsHandle = document.getElementsByTagName("script");
var XAudioJSsourceHandle = XAudioJSscriptsHandle[XAudioJSscriptsHandle.length-1].src;
function XAudioServer(channels, sampleRate, minBufferSize, maxBufferSize, underRunCallback, volume, failureCallback) {
	XAudioJSChannelsAllocated = Math.max(channels, 1);
	this.XAudioJSSampleRate = Math.abs(sampleRate);
	XAudioJSMinBufferSize = (minBufferSize >= (XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated) && minBufferSize < maxBufferSize) ? (minBufferSize & (-XAudioJSChannelsAllocated)) : (XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated);
	XAudioJSMaxBufferSize = (Math.floor(maxBufferSize) > XAudioJSMinBufferSize + XAudioJSChannelsAllocated) ? (maxBufferSize & (-XAudioJSChannelsAllocated)) : (XAudioJSMinBufferSize * XAudioJSChannelsAllocated);
	this.underRunCallback = (typeof underRunCallback == "function") ? underRunCallback : function () {};
	XAudioJSVolume = (volume >= 0 && volume <= 1) ? volume : 1;
	this.failureCallback = (typeof failureCallback == "function") ? failureCallback : function () { throw(new Error("XAudioJS has encountered a fatal error.")); };
	this.initializeAudio();
}
XAudioServer.prototype.MOZWriteAudioNoCallback = function (buffer) {
    //Resample before passing to the moz audio api:
    var bufferLength  = buffer.length;
    for (var bufferIndex = 0; bufferIndex < bufferLength;) {
        var sliceLength = Math.min(bufferLength - bufferIndex, XAudioJSMaxBufferSize);
        for (var sliceIndex = 0; sliceIndex < sliceLength; ++sliceIndex) {
            XAudioJSAudioContextSampleBuffer[sliceIndex] = buffer[bufferIndex++];
        }
        var resampleLength = XAudioJSResampleControl.resampler(XAudioJSGetArraySlice(XAudioJSAudioContextSampleBuffer, sliceIndex));
        if (resampleLength > 0) {
            var resampledResult = XAudioJSResampleControl.outputBuffer;
            var resampledBuffer = XAudioJSGetArraySlice(resampledResult, resampleLength);
            this.samplesAlreadyWritten += this.audioHandleMoz.mozWriteAudio(resampledBuffer);
        }
    }
}
XAudioServer.prototype.callbackBasedWriteAudioNoCallback = function (buffer) {
	//Callback-centered audio APIs:
	var length = buffer.length;
	for (var bufferCounter = 0; bufferCounter < length && XAudioJSAudioBufferSize < XAudioJSMaxBufferSize;) {
		XAudioJSAudioContextSampleBuffer[XAudioJSAudioBufferSize++] = buffer[bufferCounter++];
	}
}
/*Pass your samples into here!
Pack your samples as a one-dimenional array
With the channel samples packed uniformly.
examples:
    mono - [left, left, left, left]
    stereo - [left, right, left, right, left, right, left, right]
*/
XAudioServer.prototype.writeAudio = function (buffer) {
	switch (this.audioType) {
		case 0:
			this.MOZWriteAudioNoCallback(buffer);
			this.MOZExecuteCallback();
			break;
		case 2:
			this.checkFlashInit();
		case 1:
		case 3:
			this.callbackBasedWriteAudioNoCallback(buffer);
			this.callbackBasedExecuteCallback();
			break;
		default:
			this.failureCallback();
	}
}
/*Pass your samples into here if you don't want automatic callback calling:
Pack your samples as a one-dimenional array
With the channel samples packed uniformly.
examples:
    mono - [left, left, left, left]
    stereo - [left, right, left, right, left, right, left, right]
Useful in preventing infinite recursion issues with calling writeAudio inside your callback.
*/
XAudioServer.prototype.writeAudioNoCallback = function (buffer) {
	switch (this.audioType) {
		case 0:
			this.MOZWriteAudioNoCallback(buffer);
			break;
		case 2:
			this.checkFlashInit();
		case 1:
		case 3:
			this.callbackBasedWriteAudioNoCallback(buffer);
			break;
		default:
			this.failureCallback();
	}
}
//Developer can use this to see how many samples to write (example: minimum buffer allotment minus remaining samples left returned from this function to make sure maximum buffering is done...)
//If null is returned, then that means metric could not be done.
XAudioServer.prototype.remainingBuffer = function () {
	switch (this.audioType) {
		case 0:
			return Math.floor((this.samplesAlreadyWritten - this.audioHandleMoz.mozCurrentSampleOffset()) * XAudioJSResampleControl.ratioWeight / XAudioJSChannelsAllocated) * XAudioJSChannelsAllocated;
		case 2:
			this.checkFlashInit();
		case 1:
		case 3:
			return (Math.floor((XAudioJSResampledSamplesLeft() * XAudioJSResampleControl.ratioWeight) / XAudioJSChannelsAllocated) * XAudioJSChannelsAllocated) + XAudioJSAudioBufferSize;
		default:
			this.failureCallback();
			return null;
	}
}
XAudioServer.prototype.MOZExecuteCallback = function () {
	//mozAudio:
	var samplesRequested = XAudioJSMinBufferSize - this.remainingBuffer();
	if (samplesRequested > 0) {
		this.MOZWriteAudioNoCallback(this.underRunCallback(samplesRequested));
	}
}
XAudioServer.prototype.callbackBasedExecuteCallback = function () {
	//WebKit /Flash Audio:
	var samplesRequested = XAudioJSMinBufferSize - this.remainingBuffer();
	if (samplesRequested > 0) {
		this.callbackBasedWriteAudioNoCallback(this.underRunCallback(samplesRequested));
	}
}
//If you just want your callback called for any possible refill (Execution of callback is still conditional):
XAudioServer.prototype.executeCallback = function () {
	switch (this.audioType) {
		case 0:
			this.MOZExecuteCallback();
			break;
		case 2:
			this.checkFlashInit();
		case 1:
		case 3:
			this.callbackBasedExecuteCallback();
			break;
		default:
			this.failureCallback();
	}
}
//DO NOT CALL THIS, the lib calls this internally!
XAudioServer.prototype.initializeAudio = function () {
    try {
        this.initializeMozAudio();
    }
    catch (error) {
        try {
            this.initializeWebAudio();
        }
        catch (error) {
            try {
                this.initializeMediaStream();
            }
            catch (error) {
                try {
                    this.initializeFlashAudio();
                }
                catch (error) {
                    this.audioType = -1;
                    this.failureCallback();
                }
            }
        }
    }
}
XAudioServer.prototype.initializeMediaStream = function () {
	this.audioHandleMediaStream = new Audio();
	this.resetCallbackAPIAudioBuffer(XAudioJSMediaStreamSampleRate);
	if (XAudioJSMediaStreamWorker) {
		//WebWorker is not GC'd, so manually collect it:
		XAudioJSMediaStreamWorker.terminate();
	}
	XAudioJSMediaStreamWorker = new Worker(XAudioJSsourceHandle.substring(0, XAudioJSsourceHandle.length - 3) + "MediaStreamWorker.js");
	this.audioHandleMediaStreamProcessing = new ProcessedMediaStream(XAudioJSMediaStreamWorker, XAudioJSMediaStreamSampleRate, XAudioJSChannelsAllocated);
	this.audioHandleMediaStream.src = this.audioHandleMediaStreamProcessing;
	this.audioHandleMediaStream.volume = XAudioJSVolume;
	XAudioJSMediaStreamWorker.onmessage = XAudioJSMediaStreamPushAudio;
	XAudioJSMediaStreamWorker.postMessage([1, XAudioJSResampleBufferSize, XAudioJSChannelsAllocated]);
	this.audioHandleMediaStream.play();
	this.audioType = 3;
}
XAudioServer.prototype.initializeMozAudio = function () {
    this.audioHandleMoz = new Audio();
	this.audioHandleMoz.mozSetup(XAudioJSChannelsAllocated, XAudioJSMozAudioSampleRate);
	this.audioHandleMoz.volume = XAudioJSVolume;
	this.samplesAlreadyWritten = 0;
	this.audioType = 0;
	//if (navigator.platform != "MacIntel" && navigator.platform != "MacPPC") {
		//Add some additional buffering space to workaround a moz audio api issue:
		var bufferAmount = (this.XAudioJSSampleRate * XAudioJSChannelsAllocated / 10) | 0;
		bufferAmount -= bufferAmount % XAudioJSChannelsAllocated;
		this.samplesAlreadyWritten -= bufferAmount;
	//}
    this.initializeResampler(XAudioJSMozAudioSampleRate);
}
XAudioServer.prototype.initializeWebAudio = function () {
	if (!XAudioJSWebAudioLaunchedContext) {
        try {
            XAudioJSWebAudioContextHandle = new AudioContext();								//Create a system audio context.
        }
        catch (error) {
            XAudioJSWebAudioContextHandle = new webkitAudioContext();							//Create a system audio context.
        }
        XAudioJSWebAudioLaunchedContext = true;
    }
    if (XAudioJSWebAudioAudioNode) {
        XAudioJSWebAudioAudioNode.disconnect();
        XAudioJSWebAudioAudioNode.onaudioprocess = null;
        XAudioJSWebAudioAudioNode = null;
    }
    try {
        XAudioJSWebAudioAudioNode = XAudioJSWebAudioContextHandle.createScriptProcessor(XAudioJSSamplesPerCallback, 0, XAudioJSChannelsAllocated);	//Create the js event node.
    }
    catch (error) {
        XAudioJSWebAudioAudioNode = XAudioJSWebAudioContextHandle.createJavaScriptNode(XAudioJSSamplesPerCallback, 0, XAudioJSChannelsAllocated);	//Create the js event node.
    }
    XAudioJSWebAudioAudioNode.onaudioprocess = XAudioJSWebAudioEvent;																			//Connect the audio processing event to a handling function so we can manipulate output
    XAudioJSWebAudioAudioNode.connect(XAudioJSWebAudioContextHandle.destination);																//Send and chain the output of the audio manipulation to the system audio output.
    this.resetCallbackAPIAudioBuffer(XAudioJSWebAudioContextHandle.sampleRate);
    this.audioType = 1;
    /*
     Firefox has a bug in its web audio implementation...
     The node may randomly stop playing on Mac OS X for no
     good reason. Keep a watchdog timer to restart the failed
     node if it glitches. Google Chrome never had this issue.
     */
    XAudioJSWebAudioWatchDogLast = (new Date()).getTime();
    if (navigator.userAgent.indexOf('Gecko/') > -1) {
        if (XAudioJSWebAudioWatchDogTimer) {
            clearInterval(XAudioJSWebAudioWatchDogTimer);
        }
        var parentObj = this;
        XAudioJSWebAudioWatchDogTimer = setInterval(function () {
            var timeDiff = (new Date()).getTime() - XAudioJSWebAudioWatchDogLast;
            if (timeDiff > 500) {
                parentObj.initializeWebAudio();
            }
        }, 500);
    }
}
XAudioServer.prototype.initializeFlashAudio = function () {
	var existingFlashload = document.getElementById("XAudioJS");
	this.flashInitialized = false;
	this.resetCallbackAPIAudioBuffer(44100);
	switch (XAudioJSChannelsAllocated) {
		case 1:
			XAudioJSFlashTransportEncoder = XAudioJSGenerateFlashMonoString;
			break;
		case 2:
			XAudioJSFlashTransportEncoder = XAudioJSGenerateFlashStereoString;
			break;
		default:
			XAudioJSFlashTransportEncoder = XAudioJSGenerateFlashSurroundString;
	}
	if (existingFlashload == null) {
		this.audioHandleFlash = null;
		var thisObj = this;
		var mainContainerNode = document.createElement("div");
		mainContainerNode.setAttribute("style", "position: fixed; bottom: 0px; right: 0px; margin: 0px; padding: 0px; border: none; width: 8px; height: 8px; overflow: hidden; z-index: -1000; ");
		var containerNode = document.createElement("div");
		containerNode.setAttribute("style", "position: static; border: none; width: 0px; height: 0px; visibility: hidden; margin: 8px; padding: 0px;");
		containerNode.setAttribute("id", "XAudioJS");
		mainContainerNode.appendChild(containerNode);
		document.getElementsByTagName("body")[0].appendChild(mainContainerNode);
		swfobject.embedSWF(
			XAudioJSsourceHandle.substring(0, XAudioJSsourceHandle.length - 9) + "JS.swf",
			"XAudioJS",
			"8",
			"8",
			"9.0.0",
			"",
			{},
			{"allowscriptaccess":"always"},
			{"style":"position: static; visibility: hidden; margin: 8px; padding: 0px; border: none"},
			function (event) {
				if (event.success) {
					thisObj.audioHandleFlash = event.ref;
					thisObj.checkFlashInit();
				}
				else {
					thisObj.failureCallback();
					thisObj.audioType = -1;
				}
			}
		);
	}
	else {
		this.audioHandleFlash = existingFlashload;
		this.checkFlashInit();
	}
	this.audioType = 2;
}
XAudioServer.prototype.changeVolume = function (newVolume) {
	if (newVolume >= 0 && newVolume <= 1) {
		XAudioJSVolume = newVolume;
		switch (this.audioType) {
			case 0:
				this.audioHandleMoz.volume = XAudioJSVolume;
			case 1:
				break;
			case 2:
				if (this.flashInitialized) {
					this.audioHandleFlash.changeVolume(XAudioJSVolume);
				}
				else {
					this.checkFlashInit();
				}
				break;
			case 3:
				this.audioHandleMediaStream.volume = XAudioJSVolume;
				break;
			default:
				this.failureCallback();
		}
	}
}
//Checks to see if the NPAPI Adobe Flash bridge is ready yet:
XAudioServer.prototype.checkFlashInit = function () {
	if (!this.flashInitialized) {
		try {
			if (this.audioHandleFlash && this.audioHandleFlash.initialize) {
				this.flashInitialized = true;
				this.audioHandleFlash.initialize(XAudioJSChannelsAllocated, XAudioJSVolume);
			}
		}
		catch (error) {
			this.flashInitialized = false;
		}
	}
}
//Set up the resampling:
XAudioServer.prototype.resetCallbackAPIAudioBuffer = function (APISampleRate) {
	XAudioJSAudioBufferSize = XAudioJSResampleBufferEnd = XAudioJSResampleBufferStart = 0;
    this.initializeResampler(APISampleRate);
    XAudioJSResampledBuffer = this.getFloat32(XAudioJSResampleBufferSize);
}
XAudioServer.prototype.initializeResampler = function (sampleRate) {
    XAudioJSAudioContextSampleBuffer = this.getFloat32(XAudioJSMaxBufferSize);
    XAudioJSResampleBufferSize = Math.max(XAudioJSMaxBufferSize * Math.ceil(sampleRate / this.XAudioJSSampleRate) + XAudioJSChannelsAllocated, XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated);
	XAudioJSResampleControl = new Resampler(this.XAudioJSSampleRate, sampleRate, XAudioJSChannelsAllocated, XAudioJSResampleBufferSize, true);
}
XAudioServer.prototype.getFloat32 = function (size) {
	try {
		return new Float32Array(size);
	}
	catch (error) {
		return [];
	}
}
function XAudioJSFlashAudioEvent() {		//The callback that flash calls...
	XAudioJSResampleRefill();
	return XAudioJSFlashTransportEncoder();
}
function XAudioJSGenerateFlashSurroundString() {	//Convert the arrays to one long string for speed.
	var XAudioJSTotalSamples = XAudioJSSamplesPerCallback << 1;
	if (XAudioJSBinaryString.length > XAudioJSTotalSamples) {
		XAudioJSBinaryString = [];
	}
	XAudioJSTotalSamples = 0;
	for (var index = 0; index < XAudioJSSamplesPerCallback && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd; ++index) {
		//Sanitize the buffer:
		XAudioJSBinaryString[XAudioJSTotalSamples++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);
		XAudioJSBinaryString[XAudioJSTotalSamples++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);
		XAudioJSResampleBufferStart += XAudioJSChannelsAllocated - 2;
		if (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {
			XAudioJSResampleBufferStart = 0;
		}
	}
	return XAudioJSBinaryString.join("");
}
function XAudioJSGenerateFlashStereoString() {	//Convert the arrays to one long string for speed.
	var XAudioJSTotalSamples = XAudioJSSamplesPerCallback << 1;
	if (XAudioJSBinaryString.length > XAudioJSTotalSamples) {
		XAudioJSBinaryString = [];
	}
	for (var index = 0; index < XAudioJSTotalSamples && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd;) {
		//Sanitize the buffer:
		XAudioJSBinaryString[index++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);
		XAudioJSBinaryString[index++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);
		if (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {
			XAudioJSResampleBufferStart = 0;
		}
	}
	return XAudioJSBinaryString.join("");
}
function XAudioJSGenerateFlashMonoString() {	//Convert the array to one long string for speed.
	if (XAudioJSBinaryString.length > XAudioJSSamplesPerCallback) {
		XAudioJSBinaryString = [];
	}
	for (var index = 0; index < XAudioJSSamplesPerCallback && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd;) {
		//Sanitize the buffer:
		XAudioJSBinaryString[index++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);
		if (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {
			XAudioJSResampleBufferStart = 0;
		}
	}
	return XAudioJSBinaryString.join("");
}
//Some Required Globals:
var XAudioJSWebAudioContextHandle = null;
var XAudioJSWebAudioAudioNode = null;
var XAudioJSWebAudioWatchDogTimer = null;
var XAudioJSWebAudioWatchDogLast = false;
var XAudioJSWebAudioLaunchedContext = false;
var XAudioJSAudioContextSampleBuffer = [];
var XAudioJSResampledBuffer = [];
var XAudioJSMinBufferSize = 15000;
var XAudioJSMaxBufferSize = 25000;
var XAudioJSChannelsAllocated = 1;
var XAudioJSVolume = 1;
var XAudioJSResampleControl = null;
var XAudioJSAudioBufferSize = 0;
var XAudioJSResampleBufferStart = 0;
var XAudioJSResampleBufferEnd = 0;
var XAudioJSResampleBufferSize = 0;
var XAudioJSMediaStreamWorker = null;
var XAudioJSMediaStreamBuffer = [];
var XAudioJSMediaStreamSampleRate = 44100;
var XAudioJSMozAudioSampleRate = 44100;
var XAudioJSSamplesPerCallback = 2048;			//Has to be between 2048 and 4096 (If over, then samples are ignored, if under then silence is added).
var XAudioJSFlashTransportEncoder = null;
var XAudioJSMediaStreamLengthAliasCounter = 0;
var XAudioJSBinaryString = [];
function XAudioJSWebAudioEvent(event) {		//Web Audio API callback...
	if (XAudioJSWebAudioWatchDogTimer) {
		XAudioJSWebAudioWatchDogLast = (new Date()).getTime();
	}
	//Find all output channels:
	for (var bufferCount = 0, buffers = []; bufferCount < XAudioJSChannelsAllocated; ++bufferCount) {
		buffers[bufferCount] = event.outputBuffer.getChannelData(bufferCount);
	}
	//Make sure we have resampled samples ready:
	XAudioJSResampleRefill();
	//Copy samples from XAudioJS to the Web Audio API:
	for (var index = 0; index < XAudioJSSamplesPerCallback && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd; ++index) {
		for (bufferCount = 0; bufferCount < XAudioJSChannelsAllocated; ++bufferCount) {
			buffers[bufferCount][index] = XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] * XAudioJSVolume;
		}
		if (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {
			XAudioJSResampleBufferStart = 0;
		}
	}
	//Pad with silence if we're underrunning:
	while (index < XAudioJSSamplesPerCallback) {
		for (bufferCount = 0; bufferCount < XAudioJSChannelsAllocated; ++bufferCount) {
			buffers[bufferCount][index] = 0;
		}
		++index;
	}
}
//MediaStream API buffer push
function XAudioJSMediaStreamPushAudio(event) {
	var index = 0;
	var audioLengthRequested = event.data;
	var samplesPerCallbackAll = XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated;
	var XAudioJSMediaStreamLengthAlias = audioLengthRequested % XAudioJSSamplesPerCallback;
	audioLengthRequested = audioLengthRequested - (XAudioJSMediaStreamLengthAliasCounter - (XAudioJSMediaStreamLengthAliasCounter % XAudioJSSamplesPerCallback)) - XAudioJSMediaStreamLengthAlias + XAudioJSSamplesPerCallback;
	XAudioJSMediaStreamLengthAliasCounter -= XAudioJSMediaStreamLengthAliasCounter - (XAudioJSMediaStreamLengthAliasCounter % XAudioJSSamplesPerCallback);
	XAudioJSMediaStreamLengthAliasCounter += XAudioJSSamplesPerCallback - XAudioJSMediaStreamLengthAlias;
	if (XAudioJSMediaStreamBuffer.length != samplesPerCallbackAll) {
		XAudioJSMediaStreamBuffer = new Float32Array(samplesPerCallbackAll);
	}
	XAudioJSResampleRefill();
	while (index < audioLengthRequested) {
		var index2 = 0;
		while (index2 < samplesPerCallbackAll && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd) {
			XAudioJSMediaStreamBuffer[index2++] = XAudioJSResampledBuffer[XAudioJSResampleBufferStart++];
			if (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {
				XAudioJSResampleBufferStart = 0;
			}
		}
		XAudioJSMediaStreamWorker.postMessage([0, XAudioJSMediaStreamBuffer]);
		index += XAudioJSSamplesPerCallback;
	}
}
function XAudioJSResampleRefill() {
	if (XAudioJSAudioBufferSize > 0) {
		//Resample a chunk of audio:
		var resampleLength = XAudioJSResampleControl.resampler(XAudioJSGetBufferSamples());
		var resampledResult = XAudioJSResampleControl.outputBuffer;
		for (var index2 = 0; index2 < resampleLength;) {
			XAudioJSResampledBuffer[XAudioJSResampleBufferEnd++] = resampledResult[index2++];
			if (XAudioJSResampleBufferEnd == XAudioJSResampleBufferSize) {
				XAudioJSResampleBufferEnd = 0;
			}
			if (XAudioJSResampleBufferStart == XAudioJSResampleBufferEnd) {
				XAudioJSResampleBufferStart += XAudioJSChannelsAllocated;
				if (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {
					XAudioJSResampleBufferStart = 0;
				}
			}
		}
		XAudioJSAudioBufferSize = 0;
	}
}
function XAudioJSResampledSamplesLeft() {
	return ((XAudioJSResampleBufferStart <= XAudioJSResampleBufferEnd) ? 0 : XAudioJSResampleBufferSize) + XAudioJSResampleBufferEnd - XAudioJSResampleBufferStart;
}
function XAudioJSGetBufferSamples() {
    return XAudioJSGetArraySlice(XAudioJSAudioContextSampleBuffer, XAudioJSAudioBufferSize);
}
function XAudioJSGetArraySlice(buffer, lengthOf) {
	//Typed array and normal array buffer section referencing:
	try {
		return buffer.subarray(0, lengthOf);
	}
	catch (error) {
		try {
			//Regular array pass:
			buffer.length = lengthOf;
			return buffer;
		}
		catch (error) {
			//Nightly Firefox 4 used to have the subarray function named as slice:
			return buffer.slice(0, lengthOf);
		}
	}
}

      window.XAudioServer = XAudioServer;
    </script>
    <!-- GameBoyElement -->
    <script type="module">
// import { GameBoyCore } from "./gameboy-0.2.0.js";
// import { XAudioServer } from "./XAudioServer-899c314.js";
window.debug = function () {};

function gunzipIfNecessary(response) {
  if (response.headers.get("content-type") == "application/x-gzip") {
    return new Response(
      /* global DecompressionStream */
      response.body.pipeThrough(new DecompressionStream("gzip"))
    );
  } else {
    return response;
  }
}

// export class GameBoyElement extends HTMLElement {
window.GameBoyElement = class GameBoyElement extends HTMLElement {
  constructor() {
    super();

    const shadowRoot = this.attachShadow({ mode: "closed" });

    const style = document.createElement("style");
    style.innerText = `
      canvas { background-color: black; }
      .paused { filter: grayscale(80%); }
      .controlButton { cursor: pointer; }
      .pressed { color: greenyellow; }
      div {
        color: gray;
        background-color: black;
        text-align: center;
        user-select: none;
      }
    `;

    shadowRoot.append(style);

    this.setAttribute("width", this.getAttribute("width") || 160);
    this.setAttribute(
      "height",
      this.getAttribute("height") ||
        (144 / 160) * parseInt(this.getAttribute("width"))
    );

    this.canvas = document.createElement("canvas");
    this.canvas.setAttribute("tabindex", "1");
    this.canvas.width = this.getAttribute("width");
    this.canvas.height = this.getAttribute("height");

    shadowRoot.append(this.canvas);

    this.playing = false;
    this.canvas.classList.add("paused");

    const EMULATOR_LOOP_INTERVAL = 8;
    this.runInterval = setInterval(() => {
      if (this.playing) {
        this._runOneStep();
      }
    }, EMULATOR_LOOP_INTERVAL);

    if (this.hasAttribute("controls")) {
      shadowRoot.append(this._buildControls(shadowRoot));
    }

    this.addEventListener("keydown", (event) => {
      switch (event.code) {
        case "KeyR":
          this.reset();
          break;
        case "KeyK":
          this._togglePlaying();
          break;
        case "KeyF":
          this._toggleFullscreen();
          break;
        case "KeyQ":
          if (this.stashedInputSequence) {
            this.inputSequence = this.stashedInputSequence;
            this.stashedInputSequence = null;
            this.reset();
          } else {
            if (this.inputSequence) {
              this.stashedInputSequence = this.inputSequence;
              this.inputSequence = null;
            }
          }
          break;
        case "Period":
          if (!this.playing) {
            this._runOneStep();
          }
          break;
      }
    });

    this.canvas.addEventListener("dblclick", () => this._toggleFullscreen());
    this.canvas.addEventListener("click", () => this._togglePlaying());

    this.keyToButton = {
      ArrowRight: "right",
      ArrowLeft: "left",
      ArrowUp: "up",
      ArrowDown: "down",
      x: "a",
      z: "b",
      Shift: "select",
      Enter: "start",
    };

    this.buttonToKeycode = {
      right: 0,
      left: 1,
      up: 2,
      down: 3,
      a: 4,
      b: 5,
      select: 6,
      start: 7,
    };

    const handleButtonKey = (event) => {
      const key = event.key;
      if (key in this.keyToButton) {
        event.preventDefault();
        const button = this.keyToButton[key];
        const type =
          event.type == "keydown"
            ? "game-boy-button-down"
            : "game-boy-button-up";
        this.dispatchEvent(new CustomEvent(type, { detail: button }));
      }
    };

    const handleGbButton = (event) => {
      if (this.emulator) {
        if (!this.playing) {
          this.play();
        }
        this.emulator.JoyPadEvent(
          this.buttonToKeycode[event.detail],
          event.type == "game-boy-button-down"
        );
      }
    };

    this.addEventListener("game-boy-button-down", handleGbButton);
    this.addEventListener("game-boy-button-up", handleGbButton);

    this.addEventListener("keydown", handleButtonKey);
    this.addEventListener("keyup", handleButtonKey);

    this.addEventListener("game-boy-rom-loaded", (e) => {
      this._setupEmulator();
    });

    shadowRoot.host.style.display = "block";
    shadowRoot.host.style.width = this.getAttribute("width") + "px";

    if (this.hasAttribute("defaultscenario")) {
      const name = this.getAttribute("defaultscenario");
      const scenario = this.querySelector(`game-boy-scenario[name=${name}`);
      this.loadInitialState(scenario.getAttribute("src"));
    }

    if (this.hasAttribute("defaultinputsequence")) {
      const name = this.getAttribute("defaultinputsequence");
      const inputSequence = this.querySelector(
        `game-boy-input-sequence[name=${name}`
      );
      this.loadInputSequence(inputSequence.getAttribute("src"));
    }

    if (this.hasAttribute("loop")) {
      this.addEventListener("game-boy-input-sequence-complete", this.reset);
    }

    if (!this.hasAttribute("ignoreoob")) {
      this.addEventListener("game-boy-out-of-bounds", this.reset);
    }
  }

  _runOneStep() {
    if (this.emulator) {
      if (this.inputSequence && this.iteration < this.inputSequence.length) {
        const input = this.inputSequence[this.iteration];
        for (let button of input.press || []) {
          this.dispatchEvent(
            new CustomEvent("game-boy-button-down", { detail: button })
          );
        }
        for (let button of input.release || []) {
          this.dispatchEvent(
            new CustomEvent("game-boy-button-up", { detail: button })
          );
        }
        this.dispatchEvent(
          new CustomEvent("game-boy-input-sequence-action", {
            detail: input,
          })
        );
      }
      this.emulator.run();
      this.iteration += 1;
      this.dispatchEvent(
        new CustomEvent("game-boy-run", {
          detail: this.iteration,
        })
      );
      if (this.inputSequence && this.inputSequence.length == this.iteration) {
        this.dispatchEvent(new Event("game-boy-input-sequence-complete"));
      }
    }
  }

  _buildControls() {
    const controlBar = document.createElement("div");
    controlBar.addEventListener("click", () => this.canvas.focus());

    const buttonSpecs = [
      ["left", ""],
      ["up", ""],
      ["down", ""],
      ["right", ""],
      ["select", ""],
      ["start", ""],
      ["a", ""],
      ["b", ""],
    ];

    for (let [name, glyph] of buttonSpecs) {
      const elem = document.createElement("span");
      elem.innerText = glyph;
      elem.classList.add("controlButton");
      elem.title = name;
      elem.addEventListener("pointerdown", () => {
        this.dispatchEvent(
          new CustomEvent("game-boy-button-down", { detail: name })
        );
      });
      this.addEventListener("game-boy-button-down", (e) => {
        if (e.detail == name) {
          elem.classList.add("pressed");
        }
      });
      elem.addEventListener("pointerup", () => {
        this.dispatchEvent(
          new CustomEvent("game-boy-button-up", { detail: name })
        );
      });
      this.addEventListener("game-boy-button-up", (e) => {
        if (e.detail == name) {
          elem.classList.remove("pressed");
        }
      });
      controlBar.append(elem);
    }

    const fullscreen = document.createElement("span");
    fullscreen.innerText = "  ";
    fullscreen.addEventListener("click", () => this._toggleFullscreen());
    controlBar.append(fullscreen);

    return controlBar;
  }

  _setupEmulator() {
    this.emulator = GameBoyCore(this.canvas, this.rom, { sound: XAudioServer });
    this.emulator.stopEmulator = 1;
    this.emulator.start();
    this.iteration = 0;
    if (this.initialState) {
      this.restoreState(this.initialState);
    }
    const proxyROM = new Proxy(this.emulator.ROM, {
      get: (memory, addr) => {
        if (this.mask[addr] == 0) {
          this.dispatchEvent(
            new CustomEvent("game-boy-out-of-bounds", { detail: addr })
          );
        }
        return memory[addr];
      },
    });
    this.emulator.ROM = proxyROM;
    if (this.hasAttribute("autoplay")) {
      this.play();
    } else {
      this._runOneStep();
    }
  }

  _toggleFullscreen() {
    if (!document.fullscreenElement) {
      this.canvas.requestFullscreen().then(() => this.canvas.focus());
    } else if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }

  _togglePlaying() {
    if (this.playing) {
      this.pause();
    } else {
      this.play();
    }
  }

  static get observedAttributes() {
    return ["romsrc", "masksrc", "initialstatesrc", "inputsequencesrc"];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    //overkill (should really only reload what's changed)
    if (this.hasAttribute("romsrc")) {
      this.loadRom(this.getAttribute("romsrc"), this.getAttribute("masksrc"));
    }

    if (this.hasAttribute("initialstatesrc")) {
      this.loadInitialState(this.getAttribute("initialstatesrc"));
    }

    if (this.hasAttribute("inputsequencesrc")) {
      this.loadInputSequence(this.getAttribute("inputsequencesrc"));
    }
  }

  // Public API

  play() {
    this.playing = true;
    this.canvas.classList.remove("paused");
  }

  pause() {
    this.playing = false;
    this.canvas.classList.add("paused");
  }

  reset() {
    this._setupEmulator();
  }

  async loadRom(romSrc, maskSrc) {
    this.rom = new Uint8Array(
      await gunzipIfNecessary(await fetch(romSrc)).arrayBuffer()
    );
    if (maskSrc) {
      this.mask = new Uint8Array(
        await gunzipIfNecessary(await fetch(maskSrc)).arrayBuffer()
      );
    } else {
      this.mask = new Uint8Array(this.rom.length).fill(1);
    }
    this.dispatchEvent(new Event("game-boy-rom-loaded"));
  }

  async loadInitialState(initialStateSrc) {
    const response = await fetch(initialStateSrc);
    this.initialState = await gunzipIfNecessary(response).json();
    this.reset();
  }

  async loadInputSequence(inputSequenceSrc) {
    const response = await fetch(inputSequenceSrc);
    this.inputSequence = await gunzipIfNecessary(response).json();
    this.reset();
  }

  saveState() {
    if (this.emulator) {
      const patchedState = this.emulator.saveState();
      patchedState[0] = Array.from(this.emulator.canvasBuffer.data); // replace ROM with canvas pixels
      return patchedState;
    }
  }

  restoreState(patchedState) {
    if (this.emulator && patchedState) {
      const state = patchedState.slice();
      const screenshotData = state[0];
      state[0] = this.emulator.ROM; // restore ROM data
      this.emulator.returnFromState(state);
      this.emulator.canvasBuffer.data.set(screenshotData); // restore canvas pixels
      this.emulator.graphicsBlit();
    }
  }
}

customElements.define("game-boy", GameBoyElement);

    </script>
    <!-- TenmileQuoteElement -->
    <script type="module">
     export class TenmileQuoteElement extends GameBoyElement {
         constructor() {
             super();
             this.setAttribute("title", this.innerHTML);
             this._setupQuote();
         }

         async _setupQuote() {
             const gb = this;
             const src = this.getAttribute("src");

             // Based on in https://tenmile.quote.games/js/quotes.js

             const BORDER_SIZE = 12;
             const SAVESTATE_FRAMEBUFFER = 71;

             async function asyncUnpack(url) {
                 return await(new Response((await fetch(url)).body.pipeThrough(new DecompressionStream("gzip")))).json();
             } 

             async function unpack(url) {
                 const data = await fetch(url);
                 return (new Response(data.body.pipeThrough(new DecompressionStream("gzip")))).json();
             } 
             
             async function unpackAb(url) {
                 const data = await fetch(url);
                 return (new Response(data.body.pipeThrough(new DecompressionStream("gzip")))).arrayBuffer();
             } 
             
             async function unpackDebug(url) {
                 const data = await fetch(url);
                 const rs = new Response(data.body.pipeThrough(new DecompressionStream("gzip")))
                 console.log(await rs.arrayBuffer());
                 debugger
                 return (rs).json();
             } 
             
             async function unpackNoJson(url) {
                 const data = await fetch(url);
                 return (new Response(data.body.pipeThrough(new DecompressionStream("gzip"))));
             } 
             
             // const zip = await jszip.loadAsync(new Uint8Array(decodedBytes));

             // const romOld = await zip.file("ROM.bin").async("uint8array");
             const rom = new Uint8Array(await unpack(romSrcRaw));
             // const mask = await zip.file("ROM.mask").async("uint8array");
             const mask = await unpackAb(maskSrcRaw);
             // debugger

             // const initialState = msgpackLite.decode(
             //     await zip.file("initialState.msgpack").async("uint8array")
             // );

             const initialState = await unpack(initialStateRaw);

             // hacks!
             //  - the [SAVESTATE_FRAMEBUFFER] entry should be recovered from the quote image
             //  - the intended data for [0] isn't present in the quote,but we could approximate
             //    it from the quote image data
             initialState[SAVESTATE_FRAMEBUFFER] = null;
             initialState[0] = Array.from(new Uint8Array(160 * 144 * 4).fill(255));

             // const actions = msgpackLite.decode(
             //     await zip.file("actions.msgpack").async("uint8array")
             // );
             // console.log(actions);
             // debugger

             const actions = await unpack(actionsRaw);
             
             const buttonNames = [
                 "right",
                 "left",
                 "up",
                 "down",
                 "a",
                 "b",
                 "select",
                 "start",
             ];
             
             const inputSequence = actions.map((action) => {
                 let step = {};
                 for (let [i, direction] of action) {
                     let kind = direction ? "press" : "release";
                     if (!step[kind]) {
                         step[kind] = [];
                     }
                     step[kind].push(buttonNames[i]);
                 }
                 return step;
             });

             const romSrc = URL.createObjectURL(new Blob([rom]));
             const maskSrc = URL.createObjectURL(new Blob([mask]));
             const initialStateSrc = URL.createObjectURL(
                 new Blob([JSON.stringify(initialState)], { type: "application/json" })
             );
             const inputSequenceSrc = URL.createObjectURL(
                 new Blob([JSON.stringify(inputSequence)], { type: "application/json" })
             );

             gb.setAttribute("romsrc", romSrc);
             gb.setAttribute("masksrc", maskSrc);
             gb.setAttribute("initialstatesrc", initialStateSrc);
             gb.setAttribute("inputsequencesrc", inputSequenceSrc);
         }
     }

     customElements.define("tenmile-quote", TenmileQuoteElement);

    </script>
    <style>
     game-boy {
         margin: 10px;
         border: thin solid black;
         filter: drop-shadow(0 0 10px #ddd);
     }
    </style>
  </head>
  <body>
      <p>
          <tenmile-quote
              id="gb"
              controls
              autoplay
              width="320"
              src="https://tenmile.s3.amazonaws.com/ALICE-f8eb-6b2bc0db.png"
          ></tenmile-quote>
  </body>
</html>
